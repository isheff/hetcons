{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (1.0.0-dev)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Hetcons_Participant where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Hetcons_Types
import qualified Hetcons_Participant_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Ping_args = Ping_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Ping_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Ping_args where 
  arbitrary = QC.elements [Ping_args]
from_Ping_args :: Ping_args -> T.ThriftVal
from_Ping_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Ping_args :: (T.Protocol p, T.Transport t) => p t -> Ping_args -> P.IO ()
write_Ping_args oprot record = T.writeVal oprot $ from_Ping_args record
encode_Ping_args :: (T.Protocol p, T.Transport t) => p t -> Ping_args -> LBS.ByteString
encode_Ping_args oprot record = T.serializeVal oprot $ from_Ping_args record
to_Ping_args :: T.ThriftVal -> Ping_args
to_Ping_args (T.TStruct fields) = Ping_args{

  }
to_Ping_args _ = P.error "not a struct"
read_Ping_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Ping_args
read_Ping_args iprot = to_Ping_args <$> T.readVal iprot (T.T_STRUCT typemap_Ping_args)
decode_Ping_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Ping_args
decode_Ping_args iprot bs = to_Ping_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Ping_args) bs
typemap_Ping_args :: T.TypeMap
typemap_Ping_args = Map.fromList []
default_Ping_args :: Ping_args
default_Ping_args = Ping_args{
}
data Ping_result = Ping_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Ping_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Ping_result where 
  arbitrary = QC.elements [Ping_result]
from_Ping_result :: Ping_result -> T.ThriftVal
from_Ping_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Ping_result :: (T.Protocol p, T.Transport t) => p t -> Ping_result -> P.IO ()
write_Ping_result oprot record = T.writeVal oprot $ from_Ping_result record
encode_Ping_result :: (T.Protocol p, T.Transport t) => p t -> Ping_result -> LBS.ByteString
encode_Ping_result oprot record = T.serializeVal oprot $ from_Ping_result record
to_Ping_result :: T.ThriftVal -> Ping_result
to_Ping_result (T.TStruct fields) = Ping_result{

  }
to_Ping_result _ = P.error "not a struct"
read_Ping_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Ping_result
read_Ping_result iprot = to_Ping_result <$> T.readVal iprot (T.T_STRUCT typemap_Ping_result)
decode_Ping_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Ping_result
decode_Ping_result iprot bs = to_Ping_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Ping_result) bs
typemap_Ping_result :: T.TypeMap
typemap_Ping_result = Map.fromList []
default_Ping_result :: Ping_result
default_Ping_result = Ping_result{
}
data Proposal_1a_args = Proposal_1a_args  { proposal_1a_args_proposal :: Signed_Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Proposal_1a_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` proposal_1a_args_proposal record  
instance QC.Arbitrary Proposal_1a_args where 
  arbitrary = M.liftM Proposal_1a_args (QC.arbitrary)
  shrink obj | obj == default_Proposal_1a_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Proposal_1a_args{proposal_1a_args_proposal = proposal_1a_args_proposal obj} then P.Nothing else P.Just $ default_Proposal_1a_args{proposal_1a_args_proposal = proposal_1a_args_proposal obj}
    ]
from_Proposal_1a_args :: Proposal_1a_args -> T.ThriftVal
from_Proposal_1a_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v449 -> P.Just (1, ("proposal",from_Signed_Message _v449))) $ proposal_1a_args_proposal record
  ]
write_Proposal_1a_args :: (T.Protocol p, T.Transport t) => p t -> Proposal_1a_args -> P.IO ()
write_Proposal_1a_args oprot record = T.writeVal oprot $ from_Proposal_1a_args record
encode_Proposal_1a_args :: (T.Protocol p, T.Transport t) => p t -> Proposal_1a_args -> LBS.ByteString
encode_Proposal_1a_args oprot record = T.serializeVal oprot $ from_Proposal_1a_args record
to_Proposal_1a_args :: T.ThriftVal -> Proposal_1a_args
to_Proposal_1a_args (T.TStruct fields) = Proposal_1a_args{
  proposal_1a_args_proposal = P.maybe (proposal_1a_args_proposal default_Proposal_1a_args) (\(_,_val451) -> (case _val451 of {T.TStruct _val452 -> (to_Signed_Message (T.TStruct _val452)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Proposal_1a_args _ = P.error "not a struct"
read_Proposal_1a_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Proposal_1a_args
read_Proposal_1a_args iprot = to_Proposal_1a_args <$> T.readVal iprot (T.T_STRUCT typemap_Proposal_1a_args)
decode_Proposal_1a_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Proposal_1a_args
decode_Proposal_1a_args iprot bs = to_Proposal_1a_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Proposal_1a_args) bs
typemap_Proposal_1a_args :: T.TypeMap
typemap_Proposal_1a_args = Map.fromList [(1,("proposal",(T.T_STRUCT typemap_Signed_Message)))]
default_Proposal_1a_args :: Proposal_1a_args
default_Proposal_1a_args = Proposal_1a_args{
  proposal_1a_args_proposal = default_Signed_Message}
data Proposal_1a_result = Proposal_1a_result  { proposal_1a_result_no_supported_hash_sha2_descriptor_provided :: P.Maybe No_Supported_Hash_Sha2_Descriptor_Provided
  , proposal_1a_result_descriptor_does_not_match_hash_sha2 :: P.Maybe Descriptor_Does_Not_Match_Hash_Sha2
  , proposal_1a_result_no_supported_hash_sha3_descriptor_provided :: P.Maybe No_Supported_Hash_Sha3_Descriptor_Provided
  , proposal_1a_result_descriptor_does_not_match_hash_sha3 :: P.Maybe Descriptor_Does_Not_Match_Hash_Sha3
  , proposal_1a_result_no_supported_hash_type_descriptor_provided :: P.Maybe No_Supported_Hash_Type_Descriptor_Provided
  , proposal_1a_result_descriptor_does_not_match_hash :: P.Maybe Descriptor_Does_Not_Match_Hash
  , proposal_1a_result_invalid_public_crypto_key_X509 :: P.Maybe Invalid_Public_Crypto_Key_X509
  , proposal_1a_result_invalid_public_crypto_key_PGP :: P.Maybe Invalid_Public_Crypto_Key_PGP
  , proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided :: P.Maybe No_Supported_Public_Crypto_Key_Type_Descriptor_Provided
  , proposal_1a_result_descriptor_does_not_match_public_crypto_key :: P.Maybe Descriptor_Does_Not_Match_Public_Crypto_Key
  , proposal_1a_result_descriptor_does_not_match_crypto_ID_hash :: P.Maybe Descriptor_Does_Not_Match_Crypto_ID_Hash
  , proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided :: P.Maybe No_Supported_Crypto_ID_Type_Descriptor_Provided
  , proposal_1a_result_descriptor_does_not_match_crypto_ID :: P.Maybe Descriptor_Does_Not_Match_Crypto_ID
  , proposal_1a_result_invalid_signed_hash :: P.Maybe Invalid_Signed_Hash
  , proposal_1a_result_descriptor_does_not_match_signed_hash :: P.Maybe Descriptor_Does_Not_Match_Signed_Hash
  , proposal_1a_result_unparsable_hashable_message :: P.Maybe Unparsable_Hashable_Message
  , proposal_1a_result_invalid_address :: P.Maybe Invalid_Address
  , proposal_1a_result_impossible_observer_graph :: P.Maybe Impossible_Observer_Graph
  , proposal_1a_result_invalid_proposal_1a :: P.Maybe Invalid_Proposal_1a
  , proposal_1a_result_invalid_Phase_1b :: P.Maybe Invalid_Phase_1b
  , proposal_1a_result_invalid_Phase_2a :: P.Maybe Invalid_Phase_2a
  , proposal_1a_result_invalid_Phase_2b :: P.Maybe Invalid_Phase_2b
  , proposal_1a_result_invalid_Proof_of_Consensus :: P.Maybe Invalid_Proof_of_Consensus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Proposal_1a_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` proposal_1a_result_no_supported_hash_sha2_descriptor_provided record   `H.hashWithSalt` proposal_1a_result_descriptor_does_not_match_hash_sha2 record   `H.hashWithSalt` proposal_1a_result_no_supported_hash_sha3_descriptor_provided record   `H.hashWithSalt` proposal_1a_result_descriptor_does_not_match_hash_sha3 record   `H.hashWithSalt` proposal_1a_result_no_supported_hash_type_descriptor_provided record   `H.hashWithSalt` proposal_1a_result_descriptor_does_not_match_hash record   `H.hashWithSalt` proposal_1a_result_invalid_public_crypto_key_X509 record   `H.hashWithSalt` proposal_1a_result_invalid_public_crypto_key_PGP record   `H.hashWithSalt` proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided record   `H.hashWithSalt` proposal_1a_result_descriptor_does_not_match_public_crypto_key record   `H.hashWithSalt` proposal_1a_result_descriptor_does_not_match_crypto_ID_hash record   `H.hashWithSalt` proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided record   `H.hashWithSalt` proposal_1a_result_descriptor_does_not_match_crypto_ID record   `H.hashWithSalt` proposal_1a_result_invalid_signed_hash record   `H.hashWithSalt` proposal_1a_result_descriptor_does_not_match_signed_hash record   `H.hashWithSalt` proposal_1a_result_unparsable_hashable_message record   `H.hashWithSalt` proposal_1a_result_invalid_address record   `H.hashWithSalt` proposal_1a_result_impossible_observer_graph record   `H.hashWithSalt` proposal_1a_result_invalid_proposal_1a record   `H.hashWithSalt` proposal_1a_result_invalid_Phase_1b record   `H.hashWithSalt` proposal_1a_result_invalid_Phase_2a record   `H.hashWithSalt` proposal_1a_result_invalid_Phase_2b record   `H.hashWithSalt` proposal_1a_result_invalid_Proof_of_Consensus record  
instance QC.Arbitrary Proposal_1a_result where 
  arbitrary = M.liftM Proposal_1a_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Proposal_1a_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Proposal_1a_result{proposal_1a_result_no_supported_hash_sha2_descriptor_provided = proposal_1a_result_no_supported_hash_sha2_descriptor_provided obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_no_supported_hash_sha2_descriptor_provided = proposal_1a_result_no_supported_hash_sha2_descriptor_provided obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash_sha2 = proposal_1a_result_descriptor_does_not_match_hash_sha2 obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash_sha2 = proposal_1a_result_descriptor_does_not_match_hash_sha2 obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_no_supported_hash_sha3_descriptor_provided = proposal_1a_result_no_supported_hash_sha3_descriptor_provided obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_no_supported_hash_sha3_descriptor_provided = proposal_1a_result_no_supported_hash_sha3_descriptor_provided obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash_sha3 = proposal_1a_result_descriptor_does_not_match_hash_sha3 obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash_sha3 = proposal_1a_result_descriptor_does_not_match_hash_sha3 obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_no_supported_hash_type_descriptor_provided = proposal_1a_result_no_supported_hash_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_no_supported_hash_type_descriptor_provided = proposal_1a_result_no_supported_hash_type_descriptor_provided obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash = proposal_1a_result_descriptor_does_not_match_hash obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash = proposal_1a_result_descriptor_does_not_match_hash obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_public_crypto_key_X509 = proposal_1a_result_invalid_public_crypto_key_X509 obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_public_crypto_key_X509 = proposal_1a_result_invalid_public_crypto_key_X509 obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_public_crypto_key_PGP = proposal_1a_result_invalid_public_crypto_key_PGP obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_public_crypto_key_PGP = proposal_1a_result_invalid_public_crypto_key_PGP obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided = proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided = proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_public_crypto_key = proposal_1a_result_descriptor_does_not_match_public_crypto_key obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_public_crypto_key = proposal_1a_result_descriptor_does_not_match_public_crypto_key obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_crypto_ID_hash = proposal_1a_result_descriptor_does_not_match_crypto_ID_hash obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_crypto_ID_hash = proposal_1a_result_descriptor_does_not_match_crypto_ID_hash obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided = proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided = proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_crypto_ID = proposal_1a_result_descriptor_does_not_match_crypto_ID obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_crypto_ID = proposal_1a_result_descriptor_does_not_match_crypto_ID obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_signed_hash = proposal_1a_result_invalid_signed_hash obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_signed_hash = proposal_1a_result_invalid_signed_hash obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_signed_hash = proposal_1a_result_descriptor_does_not_match_signed_hash obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_signed_hash = proposal_1a_result_descriptor_does_not_match_signed_hash obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_unparsable_hashable_message = proposal_1a_result_unparsable_hashable_message obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_unparsable_hashable_message = proposal_1a_result_unparsable_hashable_message obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_address = proposal_1a_result_invalid_address obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_address = proposal_1a_result_invalid_address obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_impossible_observer_graph = proposal_1a_result_impossible_observer_graph obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_impossible_observer_graph = proposal_1a_result_impossible_observer_graph obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_proposal_1a = proposal_1a_result_invalid_proposal_1a obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_proposal_1a = proposal_1a_result_invalid_proposal_1a obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_Phase_1b = proposal_1a_result_invalid_Phase_1b obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_Phase_1b = proposal_1a_result_invalid_Phase_1b obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_Phase_2a = proposal_1a_result_invalid_Phase_2a obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_Phase_2a = proposal_1a_result_invalid_Phase_2a obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_Phase_2b = proposal_1a_result_invalid_Phase_2b obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_Phase_2b = proposal_1a_result_invalid_Phase_2b obj}
    , if obj == default_Proposal_1a_result{proposal_1a_result_invalid_Proof_of_Consensus = proposal_1a_result_invalid_Proof_of_Consensus obj} then P.Nothing else P.Just $ default_Proposal_1a_result{proposal_1a_result_invalid_Proof_of_Consensus = proposal_1a_result_invalid_Proof_of_Consensus obj}
    ]
from_Proposal_1a_result :: Proposal_1a_result -> T.ThriftVal
from_Proposal_1a_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v455 -> (1, ("no_supported_hash_sha2_descriptor_provided",from_No_Supported_Hash_Sha2_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_hash_sha2_descriptor_provided record, (\_v455 -> (2, ("descriptor_does_not_match_hash_sha2",from_Descriptor_Does_Not_Match_Hash_Sha2 _v455))) <$> proposal_1a_result_descriptor_does_not_match_hash_sha2 record, (\_v455 -> (3, ("no_supported_hash_sha3_descriptor_provided",from_No_Supported_Hash_Sha3_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_hash_sha3_descriptor_provided record, (\_v455 -> (4, ("descriptor_does_not_match_hash_sha3",from_Descriptor_Does_Not_Match_Hash_Sha3 _v455))) <$> proposal_1a_result_descriptor_does_not_match_hash_sha3 record, (\_v455 -> (5, ("no_supported_hash_type_descriptor_provided",from_No_Supported_Hash_Type_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_hash_type_descriptor_provided record, (\_v455 -> (6, ("descriptor_does_not_match_hash",from_Descriptor_Does_Not_Match_Hash _v455))) <$> proposal_1a_result_descriptor_does_not_match_hash record, (\_v455 -> (7, ("invalid_public_crypto_key_X509",from_Invalid_Public_Crypto_Key_X509 _v455))) <$> proposal_1a_result_invalid_public_crypto_key_X509 record, (\_v455 -> (8, ("invalid_public_crypto_key_PGP",from_Invalid_Public_Crypto_Key_PGP _v455))) <$> proposal_1a_result_invalid_public_crypto_key_PGP record, (\_v455 -> (9, ("no_supported_public_crypto_key_type_descriptor_provided",from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided record, (\_v455 -> (10, ("descriptor_does_not_match_public_crypto_key",from_Descriptor_Does_Not_Match_Public_Crypto_Key _v455))) <$> proposal_1a_result_descriptor_does_not_match_public_crypto_key record, (\_v455 -> (11, ("descriptor_does_not_match_crypto_ID_hash",from_Descriptor_Does_Not_Match_Crypto_ID_Hash _v455))) <$> proposal_1a_result_descriptor_does_not_match_crypto_ID_hash record, (\_v455 -> (12, ("no_supported_crypto_ID_type_descriptor_provided",from_No_Supported_Crypto_ID_Type_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided record, (\_v455 -> (13, ("descriptor_does_not_match_crypto_ID",from_Descriptor_Does_Not_Match_Crypto_ID _v455))) <$> proposal_1a_result_descriptor_does_not_match_crypto_ID record, (\_v455 -> (14, ("invalid_signed_hash",from_Invalid_Signed_Hash _v455))) <$> proposal_1a_result_invalid_signed_hash record, (\_v455 -> (15, ("descriptor_does_not_match_signed_hash",from_Descriptor_Does_Not_Match_Signed_Hash _v455))) <$> proposal_1a_result_descriptor_does_not_match_signed_hash record, (\_v455 -> (16, ("unparsable_hashable_message",from_Unparsable_Hashable_Message _v455))) <$> proposal_1a_result_unparsable_hashable_message record, (\_v455 -> (17, ("invalid_address",from_Invalid_Address _v455))) <$> proposal_1a_result_invalid_address record, (\_v455 -> (18, ("impossible_observer_graph",from_Impossible_Observer_Graph _v455))) <$> proposal_1a_result_impossible_observer_graph record, (\_v455 -> (19, ("invalid_proposal_1a",from_Invalid_Proposal_1a _v455))) <$> proposal_1a_result_invalid_proposal_1a record, (\_v455 -> (20, ("invalid_Phase_1b",from_Invalid_Phase_1b _v455))) <$> proposal_1a_result_invalid_Phase_1b record, (\_v455 -> (21, ("invalid_Phase_2a",from_Invalid_Phase_2a _v455))) <$> proposal_1a_result_invalid_Phase_2a record, (\_v455 -> (22, ("invalid_Phase_2b",from_Invalid_Phase_2b _v455))) <$> proposal_1a_result_invalid_Phase_2b record, (\_v455 -> (23, ("invalid_Proof_of_Consensus",from_Invalid_Proof_of_Consensus _v455))) <$> proposal_1a_result_invalid_Proof_of_Consensus record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v455 -> (1, ("no_supported_hash_sha2_descriptor_provided",from_No_Supported_Hash_Sha2_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_hash_sha2_descriptor_provided record
    , (\_v455 -> (2, ("descriptor_does_not_match_hash_sha2",from_Descriptor_Does_Not_Match_Hash_Sha2 _v455))) <$> proposal_1a_result_descriptor_does_not_match_hash_sha2 record
    , (\_v455 -> (3, ("no_supported_hash_sha3_descriptor_provided",from_No_Supported_Hash_Sha3_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_hash_sha3_descriptor_provided record
    , (\_v455 -> (4, ("descriptor_does_not_match_hash_sha3",from_Descriptor_Does_Not_Match_Hash_Sha3 _v455))) <$> proposal_1a_result_descriptor_does_not_match_hash_sha3 record
    , (\_v455 -> (5, ("no_supported_hash_type_descriptor_provided",from_No_Supported_Hash_Type_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_hash_type_descriptor_provided record
    , (\_v455 -> (6, ("descriptor_does_not_match_hash",from_Descriptor_Does_Not_Match_Hash _v455))) <$> proposal_1a_result_descriptor_does_not_match_hash record
    , (\_v455 -> (7, ("invalid_public_crypto_key_X509",from_Invalid_Public_Crypto_Key_X509 _v455))) <$> proposal_1a_result_invalid_public_crypto_key_X509 record
    , (\_v455 -> (8, ("invalid_public_crypto_key_PGP",from_Invalid_Public_Crypto_Key_PGP _v455))) <$> proposal_1a_result_invalid_public_crypto_key_PGP record
    , (\_v455 -> (9, ("no_supported_public_crypto_key_type_descriptor_provided",from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided record
    , (\_v455 -> (10, ("descriptor_does_not_match_public_crypto_key",from_Descriptor_Does_Not_Match_Public_Crypto_Key _v455))) <$> proposal_1a_result_descriptor_does_not_match_public_crypto_key record
    , (\_v455 -> (11, ("descriptor_does_not_match_crypto_ID_hash",from_Descriptor_Does_Not_Match_Crypto_ID_Hash _v455))) <$> proposal_1a_result_descriptor_does_not_match_crypto_ID_hash record
    , (\_v455 -> (12, ("no_supported_crypto_ID_type_descriptor_provided",from_No_Supported_Crypto_ID_Type_Descriptor_Provided _v455))) <$> proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided record
    , (\_v455 -> (13, ("descriptor_does_not_match_crypto_ID",from_Descriptor_Does_Not_Match_Crypto_ID _v455))) <$> proposal_1a_result_descriptor_does_not_match_crypto_ID record
    , (\_v455 -> (14, ("invalid_signed_hash",from_Invalid_Signed_Hash _v455))) <$> proposal_1a_result_invalid_signed_hash record
    , (\_v455 -> (15, ("descriptor_does_not_match_signed_hash",from_Descriptor_Does_Not_Match_Signed_Hash _v455))) <$> proposal_1a_result_descriptor_does_not_match_signed_hash record
    , (\_v455 -> (16, ("unparsable_hashable_message",from_Unparsable_Hashable_Message _v455))) <$> proposal_1a_result_unparsable_hashable_message record
    , (\_v455 -> (17, ("invalid_address",from_Invalid_Address _v455))) <$> proposal_1a_result_invalid_address record
    , (\_v455 -> (18, ("impossible_observer_graph",from_Impossible_Observer_Graph _v455))) <$> proposal_1a_result_impossible_observer_graph record
    , (\_v455 -> (19, ("invalid_proposal_1a",from_Invalid_Proposal_1a _v455))) <$> proposal_1a_result_invalid_proposal_1a record
    , (\_v455 -> (20, ("invalid_Phase_1b",from_Invalid_Phase_1b _v455))) <$> proposal_1a_result_invalid_Phase_1b record
    , (\_v455 -> (21, ("invalid_Phase_2a",from_Invalid_Phase_2a _v455))) <$> proposal_1a_result_invalid_Phase_2a record
    , (\_v455 -> (22, ("invalid_Phase_2b",from_Invalid_Phase_2b _v455))) <$> proposal_1a_result_invalid_Phase_2b record
    , (\_v455 -> (23, ("invalid_Proof_of_Consensus",from_Invalid_Proof_of_Consensus _v455))) <$> proposal_1a_result_invalid_Proof_of_Consensus record
    ]
    )
write_Proposal_1a_result :: (T.Protocol p, T.Transport t) => p t -> Proposal_1a_result -> P.IO ()
write_Proposal_1a_result oprot record = T.writeVal oprot $ from_Proposal_1a_result record
encode_Proposal_1a_result :: (T.Protocol p, T.Transport t) => p t -> Proposal_1a_result -> LBS.ByteString
encode_Proposal_1a_result oprot record = T.serializeVal oprot $ from_Proposal_1a_result record
to_Proposal_1a_result :: T.ThriftVal -> Proposal_1a_result
to_Proposal_1a_result (T.TStruct fields) = Proposal_1a_result{
  proposal_1a_result_no_supported_hash_sha2_descriptor_provided = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val458 -> (to_No_Supported_Hash_Sha2_Descriptor_Provided (T.TStruct _val458)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  proposal_1a_result_descriptor_does_not_match_hash_sha2 = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val459 -> (to_Descriptor_Does_Not_Match_Hash_Sha2 (T.TStruct _val459)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  proposal_1a_result_no_supported_hash_sha3_descriptor_provided = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val460 -> (to_No_Supported_Hash_Sha3_Descriptor_Provided (T.TStruct _val460)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  proposal_1a_result_descriptor_does_not_match_hash_sha3 = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val461 -> (to_Descriptor_Does_Not_Match_Hash_Sha3 (T.TStruct _val461)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  proposal_1a_result_no_supported_hash_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val462 -> (to_No_Supported_Hash_Type_Descriptor_Provided (T.TStruct _val462)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  proposal_1a_result_descriptor_does_not_match_hash = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val463 -> (to_Descriptor_Does_Not_Match_Hash (T.TStruct _val463)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  proposal_1a_result_invalid_public_crypto_key_X509 = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val464 -> (to_Invalid_Public_Crypto_Key_X509 (T.TStruct _val464)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  proposal_1a_result_invalid_public_crypto_key_PGP = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val465 -> (to_Invalid_Public_Crypto_Key_PGP (T.TStruct _val465)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val466 -> (to_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided (T.TStruct _val466)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  proposal_1a_result_descriptor_does_not_match_public_crypto_key = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val467 -> (to_Descriptor_Does_Not_Match_Public_Crypto_Key (T.TStruct _val467)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  proposal_1a_result_descriptor_does_not_match_crypto_ID_hash = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val468 -> (to_Descriptor_Does_Not_Match_Crypto_ID_Hash (T.TStruct _val468)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val469 -> (to_No_Supported_Crypto_ID_Type_Descriptor_Provided (T.TStruct _val469)); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  proposal_1a_result_descriptor_does_not_match_crypto_ID = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val470 -> (to_Descriptor_Does_Not_Match_Crypto_ID (T.TStruct _val470)); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  proposal_1a_result_invalid_signed_hash = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val471 -> (to_Invalid_Signed_Hash (T.TStruct _val471)); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  proposal_1a_result_descriptor_does_not_match_signed_hash = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val472 -> (to_Descriptor_Does_Not_Match_Signed_Hash (T.TStruct _val472)); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  proposal_1a_result_unparsable_hashable_message = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val473 -> (to_Unparsable_Hashable_Message (T.TStruct _val473)); _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  proposal_1a_result_invalid_address = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val474 -> (to_Invalid_Address (T.TStruct _val474)); _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  proposal_1a_result_impossible_observer_graph = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val475 -> (to_Impossible_Observer_Graph (T.TStruct _val475)); _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  proposal_1a_result_invalid_proposal_1a = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val476 -> (to_Invalid_Proposal_1a (T.TStruct _val476)); _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  proposal_1a_result_invalid_Phase_1b = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val477 -> (to_Invalid_Phase_1b (T.TStruct _val477)); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  proposal_1a_result_invalid_Phase_2a = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val478 -> (to_Invalid_Phase_2a (T.TStruct _val478)); _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  proposal_1a_result_invalid_Phase_2b = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val479 -> (to_Invalid_Phase_2b (T.TStruct _val479)); _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  proposal_1a_result_invalid_Proof_of_Consensus = P.maybe (P.Nothing) (\(_,_val457) -> P.Just (case _val457 of {T.TStruct _val480 -> (to_Invalid_Proof_of_Consensus (T.TStruct _val480)); _ -> P.error "wrong type"})) (Map.lookup (23) fields)
  }
to_Proposal_1a_result _ = P.error "not a struct"
read_Proposal_1a_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Proposal_1a_result
read_Proposal_1a_result iprot = to_Proposal_1a_result <$> T.readVal iprot (T.T_STRUCT typemap_Proposal_1a_result)
decode_Proposal_1a_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Proposal_1a_result
decode_Proposal_1a_result iprot bs = to_Proposal_1a_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Proposal_1a_result) bs
typemap_Proposal_1a_result :: T.TypeMap
typemap_Proposal_1a_result = Map.fromList [(1,("no_supported_hash_sha2_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Sha2_Descriptor_Provided))),(2,("descriptor_does_not_match_hash_sha2",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha2))),(3,("no_supported_hash_sha3_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Sha3_Descriptor_Provided))),(4,("descriptor_does_not_match_hash_sha3",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha3))),(5,("no_supported_hash_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Type_Descriptor_Provided))),(6,("descriptor_does_not_match_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash))),(7,("invalid_public_crypto_key_X509",(T.T_STRUCT typemap_Invalid_Public_Crypto_Key_X509))),(8,("invalid_public_crypto_key_PGP",(T.T_STRUCT typemap_Invalid_Public_Crypto_Key_PGP))),(9,("no_supported_public_crypto_key_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided))),(10,("descriptor_does_not_match_public_crypto_key",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Public_Crypto_Key))),(11,("descriptor_does_not_match_crypto_ID_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID_Hash))),(12,("no_supported_crypto_ID_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Crypto_ID_Type_Descriptor_Provided))),(13,("descriptor_does_not_match_crypto_ID",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID))),(14,("invalid_signed_hash",(T.T_STRUCT typemap_Invalid_Signed_Hash))),(15,("descriptor_does_not_match_signed_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Signed_Hash))),(16,("unparsable_hashable_message",(T.T_STRUCT typemap_Unparsable_Hashable_Message))),(17,("invalid_address",(T.T_STRUCT typemap_Invalid_Address))),(18,("impossible_observer_graph",(T.T_STRUCT typemap_Impossible_Observer_Graph))),(19,("invalid_proposal_1a",(T.T_STRUCT typemap_Invalid_Proposal_1a))),(20,("invalid_Phase_1b",(T.T_STRUCT typemap_Invalid_Phase_1b))),(21,("invalid_Phase_2a",(T.T_STRUCT typemap_Invalid_Phase_2a))),(22,("invalid_Phase_2b",(T.T_STRUCT typemap_Invalid_Phase_2b))),(23,("invalid_Proof_of_Consensus",(T.T_STRUCT typemap_Invalid_Proof_of_Consensus)))]
default_Proposal_1a_result :: Proposal_1a_result
default_Proposal_1a_result = Proposal_1a_result{
  proposal_1a_result_no_supported_hash_sha2_descriptor_provided = P.Nothing,
  proposal_1a_result_descriptor_does_not_match_hash_sha2 = P.Nothing,
  proposal_1a_result_no_supported_hash_sha3_descriptor_provided = P.Nothing,
  proposal_1a_result_descriptor_does_not_match_hash_sha3 = P.Nothing,
  proposal_1a_result_no_supported_hash_type_descriptor_provided = P.Nothing,
  proposal_1a_result_descriptor_does_not_match_hash = P.Nothing,
  proposal_1a_result_invalid_public_crypto_key_X509 = P.Nothing,
  proposal_1a_result_invalid_public_crypto_key_PGP = P.Nothing,
  proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided = P.Nothing,
  proposal_1a_result_descriptor_does_not_match_public_crypto_key = P.Nothing,
  proposal_1a_result_descriptor_does_not_match_crypto_ID_hash = P.Nothing,
  proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided = P.Nothing,
  proposal_1a_result_descriptor_does_not_match_crypto_ID = P.Nothing,
  proposal_1a_result_invalid_signed_hash = P.Nothing,
  proposal_1a_result_descriptor_does_not_match_signed_hash = P.Nothing,
  proposal_1a_result_unparsable_hashable_message = P.Nothing,
  proposal_1a_result_invalid_address = P.Nothing,
  proposal_1a_result_impossible_observer_graph = P.Nothing,
  proposal_1a_result_invalid_proposal_1a = P.Nothing,
  proposal_1a_result_invalid_Phase_1b = P.Nothing,
  proposal_1a_result_invalid_Phase_2a = P.Nothing,
  proposal_1a_result_invalid_Phase_2b = P.Nothing,
  proposal_1a_result_invalid_Proof_of_Consensus = P.Nothing}
data Phase_1b_args = Phase_1b_args  { phase_1b_args_phase_1b_message :: Signed_Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Phase_1b_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` phase_1b_args_phase_1b_message record  
instance QC.Arbitrary Phase_1b_args where 
  arbitrary = M.liftM Phase_1b_args (QC.arbitrary)
  shrink obj | obj == default_Phase_1b_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Phase_1b_args{phase_1b_args_phase_1b_message = phase_1b_args_phase_1b_message obj} then P.Nothing else P.Just $ default_Phase_1b_args{phase_1b_args_phase_1b_message = phase_1b_args_phase_1b_message obj}
    ]
from_Phase_1b_args :: Phase_1b_args -> T.ThriftVal
from_Phase_1b_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v483 -> P.Just (1, ("phase_1b_message",from_Signed_Message _v483))) $ phase_1b_args_phase_1b_message record
  ]
write_Phase_1b_args :: (T.Protocol p, T.Transport t) => p t -> Phase_1b_args -> P.IO ()
write_Phase_1b_args oprot record = T.writeVal oprot $ from_Phase_1b_args record
encode_Phase_1b_args :: (T.Protocol p, T.Transport t) => p t -> Phase_1b_args -> LBS.ByteString
encode_Phase_1b_args oprot record = T.serializeVal oprot $ from_Phase_1b_args record
to_Phase_1b_args :: T.ThriftVal -> Phase_1b_args
to_Phase_1b_args (T.TStruct fields) = Phase_1b_args{
  phase_1b_args_phase_1b_message = P.maybe (phase_1b_args_phase_1b_message default_Phase_1b_args) (\(_,_val485) -> (case _val485 of {T.TStruct _val486 -> (to_Signed_Message (T.TStruct _val486)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Phase_1b_args _ = P.error "not a struct"
read_Phase_1b_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Phase_1b_args
read_Phase_1b_args iprot = to_Phase_1b_args <$> T.readVal iprot (T.T_STRUCT typemap_Phase_1b_args)
decode_Phase_1b_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Phase_1b_args
decode_Phase_1b_args iprot bs = to_Phase_1b_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Phase_1b_args) bs
typemap_Phase_1b_args :: T.TypeMap
typemap_Phase_1b_args = Map.fromList [(1,("phase_1b_message",(T.T_STRUCT typemap_Signed_Message)))]
default_Phase_1b_args :: Phase_1b_args
default_Phase_1b_args = Phase_1b_args{
  phase_1b_args_phase_1b_message = default_Signed_Message}
data Phase_1b_result = Phase_1b_result  { phase_1b_result_no_supported_hash_sha2_descriptor_provided :: P.Maybe No_Supported_Hash_Sha2_Descriptor_Provided
  , phase_1b_result_descriptor_does_not_match_hash_sha2 :: P.Maybe Descriptor_Does_Not_Match_Hash_Sha2
  , phase_1b_result_no_supported_hash_sha3_descriptor_provided :: P.Maybe No_Supported_Hash_Sha3_Descriptor_Provided
  , phase_1b_result_descriptor_does_not_match_hash_sha3 :: P.Maybe Descriptor_Does_Not_Match_Hash_Sha3
  , phase_1b_result_no_supported_hash_type_descriptor_provided :: P.Maybe No_Supported_Hash_Type_Descriptor_Provided
  , phase_1b_result_descriptor_does_not_match_hash :: P.Maybe Descriptor_Does_Not_Match_Hash
  , phase_1b_result_invalid_public_crypto_key_X509 :: P.Maybe Invalid_Public_Crypto_Key_X509
  , phase_1b_result_invalid_public_crypto_key_PGP :: P.Maybe Invalid_Public_Crypto_Key_PGP
  , phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided :: P.Maybe No_Supported_Public_Crypto_Key_Type_Descriptor_Provided
  , phase_1b_result_descriptor_does_not_match_public_crypto_key :: P.Maybe Descriptor_Does_Not_Match_Public_Crypto_Key
  , phase_1b_result_descriptor_does_not_match_crypto_ID_hash :: P.Maybe Descriptor_Does_Not_Match_Crypto_ID_Hash
  , phase_1b_result_no_supported_crypto_ID_type_descriptor_provided :: P.Maybe No_Supported_Crypto_ID_Type_Descriptor_Provided
  , phase_1b_result_descriptor_does_not_match_crypto_ID :: P.Maybe Descriptor_Does_Not_Match_Crypto_ID
  , phase_1b_result_invalid_signed_hash :: P.Maybe Invalid_Signed_Hash
  , phase_1b_result_descriptor_does_not_match_signed_hash :: P.Maybe Descriptor_Does_Not_Match_Signed_Hash
  , phase_1b_result_unparsable_hashable_message :: P.Maybe Unparsable_Hashable_Message
  , phase_1b_result_invalid_address :: P.Maybe Invalid_Address
  , phase_1b_result_impossible_observer_graph :: P.Maybe Impossible_Observer_Graph
  , phase_1b_result_invalid_proposal_1a :: P.Maybe Invalid_Proposal_1a
  , phase_1b_result_invalid_Phase_1b :: P.Maybe Invalid_Phase_1b
  , phase_1b_result_invalid_Phase_2a :: P.Maybe Invalid_Phase_2a
  , phase_1b_result_invalid_Phase_2b :: P.Maybe Invalid_Phase_2b
  , phase_1b_result_invalid_Proof_of_Consensus :: P.Maybe Invalid_Proof_of_Consensus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Phase_1b_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` phase_1b_result_no_supported_hash_sha2_descriptor_provided record   `H.hashWithSalt` phase_1b_result_descriptor_does_not_match_hash_sha2 record   `H.hashWithSalt` phase_1b_result_no_supported_hash_sha3_descriptor_provided record   `H.hashWithSalt` phase_1b_result_descriptor_does_not_match_hash_sha3 record   `H.hashWithSalt` phase_1b_result_no_supported_hash_type_descriptor_provided record   `H.hashWithSalt` phase_1b_result_descriptor_does_not_match_hash record   `H.hashWithSalt` phase_1b_result_invalid_public_crypto_key_X509 record   `H.hashWithSalt` phase_1b_result_invalid_public_crypto_key_PGP record   `H.hashWithSalt` phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided record   `H.hashWithSalt` phase_1b_result_descriptor_does_not_match_public_crypto_key record   `H.hashWithSalt` phase_1b_result_descriptor_does_not_match_crypto_ID_hash record   `H.hashWithSalt` phase_1b_result_no_supported_crypto_ID_type_descriptor_provided record   `H.hashWithSalt` phase_1b_result_descriptor_does_not_match_crypto_ID record   `H.hashWithSalt` phase_1b_result_invalid_signed_hash record   `H.hashWithSalt` phase_1b_result_descriptor_does_not_match_signed_hash record   `H.hashWithSalt` phase_1b_result_unparsable_hashable_message record   `H.hashWithSalt` phase_1b_result_invalid_address record   `H.hashWithSalt` phase_1b_result_impossible_observer_graph record   `H.hashWithSalt` phase_1b_result_invalid_proposal_1a record   `H.hashWithSalt` phase_1b_result_invalid_Phase_1b record   `H.hashWithSalt` phase_1b_result_invalid_Phase_2a record   `H.hashWithSalt` phase_1b_result_invalid_Phase_2b record   `H.hashWithSalt` phase_1b_result_invalid_Proof_of_Consensus record  
instance QC.Arbitrary Phase_1b_result where 
  arbitrary = M.liftM Phase_1b_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Phase_1b_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Phase_1b_result{phase_1b_result_no_supported_hash_sha2_descriptor_provided = phase_1b_result_no_supported_hash_sha2_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_no_supported_hash_sha2_descriptor_provided = phase_1b_result_no_supported_hash_sha2_descriptor_provided obj}
    , if obj == default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash_sha2 = phase_1b_result_descriptor_does_not_match_hash_sha2 obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash_sha2 = phase_1b_result_descriptor_does_not_match_hash_sha2 obj}
    , if obj == default_Phase_1b_result{phase_1b_result_no_supported_hash_sha3_descriptor_provided = phase_1b_result_no_supported_hash_sha3_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_no_supported_hash_sha3_descriptor_provided = phase_1b_result_no_supported_hash_sha3_descriptor_provided obj}
    , if obj == default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash_sha3 = phase_1b_result_descriptor_does_not_match_hash_sha3 obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash_sha3 = phase_1b_result_descriptor_does_not_match_hash_sha3 obj}
    , if obj == default_Phase_1b_result{phase_1b_result_no_supported_hash_type_descriptor_provided = phase_1b_result_no_supported_hash_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_no_supported_hash_type_descriptor_provided = phase_1b_result_no_supported_hash_type_descriptor_provided obj}
    , if obj == default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash = phase_1b_result_descriptor_does_not_match_hash obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash = phase_1b_result_descriptor_does_not_match_hash obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_public_crypto_key_X509 = phase_1b_result_invalid_public_crypto_key_X509 obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_public_crypto_key_X509 = phase_1b_result_invalid_public_crypto_key_X509 obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_public_crypto_key_PGP = phase_1b_result_invalid_public_crypto_key_PGP obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_public_crypto_key_PGP = phase_1b_result_invalid_public_crypto_key_PGP obj}
    , if obj == default_Phase_1b_result{phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided = phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided = phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided obj}
    , if obj == default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_public_crypto_key = phase_1b_result_descriptor_does_not_match_public_crypto_key obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_public_crypto_key = phase_1b_result_descriptor_does_not_match_public_crypto_key obj}
    , if obj == default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_crypto_ID_hash = phase_1b_result_descriptor_does_not_match_crypto_ID_hash obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_crypto_ID_hash = phase_1b_result_descriptor_does_not_match_crypto_ID_hash obj}
    , if obj == default_Phase_1b_result{phase_1b_result_no_supported_crypto_ID_type_descriptor_provided = phase_1b_result_no_supported_crypto_ID_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_no_supported_crypto_ID_type_descriptor_provided = phase_1b_result_no_supported_crypto_ID_type_descriptor_provided obj}
    , if obj == default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_crypto_ID = phase_1b_result_descriptor_does_not_match_crypto_ID obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_crypto_ID = phase_1b_result_descriptor_does_not_match_crypto_ID obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_signed_hash = phase_1b_result_invalid_signed_hash obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_signed_hash = phase_1b_result_invalid_signed_hash obj}
    , if obj == default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_signed_hash = phase_1b_result_descriptor_does_not_match_signed_hash obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_signed_hash = phase_1b_result_descriptor_does_not_match_signed_hash obj}
    , if obj == default_Phase_1b_result{phase_1b_result_unparsable_hashable_message = phase_1b_result_unparsable_hashable_message obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_unparsable_hashable_message = phase_1b_result_unparsable_hashable_message obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_address = phase_1b_result_invalid_address obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_address = phase_1b_result_invalid_address obj}
    , if obj == default_Phase_1b_result{phase_1b_result_impossible_observer_graph = phase_1b_result_impossible_observer_graph obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_impossible_observer_graph = phase_1b_result_impossible_observer_graph obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_proposal_1a = phase_1b_result_invalid_proposal_1a obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_proposal_1a = phase_1b_result_invalid_proposal_1a obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_Phase_1b = phase_1b_result_invalid_Phase_1b obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_Phase_1b = phase_1b_result_invalid_Phase_1b obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_Phase_2a = phase_1b_result_invalid_Phase_2a obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_Phase_2a = phase_1b_result_invalid_Phase_2a obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_Phase_2b = phase_1b_result_invalid_Phase_2b obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_Phase_2b = phase_1b_result_invalid_Phase_2b obj}
    , if obj == default_Phase_1b_result{phase_1b_result_invalid_Proof_of_Consensus = phase_1b_result_invalid_Proof_of_Consensus obj} then P.Nothing else P.Just $ default_Phase_1b_result{phase_1b_result_invalid_Proof_of_Consensus = phase_1b_result_invalid_Proof_of_Consensus obj}
    ]
from_Phase_1b_result :: Phase_1b_result -> T.ThriftVal
from_Phase_1b_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v489 -> (1, ("no_supported_hash_sha2_descriptor_provided",from_No_Supported_Hash_Sha2_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_hash_sha2_descriptor_provided record, (\_v489 -> (2, ("descriptor_does_not_match_hash_sha2",from_Descriptor_Does_Not_Match_Hash_Sha2 _v489))) <$> phase_1b_result_descriptor_does_not_match_hash_sha2 record, (\_v489 -> (3, ("no_supported_hash_sha3_descriptor_provided",from_No_Supported_Hash_Sha3_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_hash_sha3_descriptor_provided record, (\_v489 -> (4, ("descriptor_does_not_match_hash_sha3",from_Descriptor_Does_Not_Match_Hash_Sha3 _v489))) <$> phase_1b_result_descriptor_does_not_match_hash_sha3 record, (\_v489 -> (5, ("no_supported_hash_type_descriptor_provided",from_No_Supported_Hash_Type_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_hash_type_descriptor_provided record, (\_v489 -> (6, ("descriptor_does_not_match_hash",from_Descriptor_Does_Not_Match_Hash _v489))) <$> phase_1b_result_descriptor_does_not_match_hash record, (\_v489 -> (7, ("invalid_public_crypto_key_X509",from_Invalid_Public_Crypto_Key_X509 _v489))) <$> phase_1b_result_invalid_public_crypto_key_X509 record, (\_v489 -> (8, ("invalid_public_crypto_key_PGP",from_Invalid_Public_Crypto_Key_PGP _v489))) <$> phase_1b_result_invalid_public_crypto_key_PGP record, (\_v489 -> (9, ("no_supported_public_crypto_key_type_descriptor_provided",from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided record, (\_v489 -> (10, ("descriptor_does_not_match_public_crypto_key",from_Descriptor_Does_Not_Match_Public_Crypto_Key _v489))) <$> phase_1b_result_descriptor_does_not_match_public_crypto_key record, (\_v489 -> (11, ("descriptor_does_not_match_crypto_ID_hash",from_Descriptor_Does_Not_Match_Crypto_ID_Hash _v489))) <$> phase_1b_result_descriptor_does_not_match_crypto_ID_hash record, (\_v489 -> (12, ("no_supported_crypto_ID_type_descriptor_provided",from_No_Supported_Crypto_ID_Type_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_crypto_ID_type_descriptor_provided record, (\_v489 -> (13, ("descriptor_does_not_match_crypto_ID",from_Descriptor_Does_Not_Match_Crypto_ID _v489))) <$> phase_1b_result_descriptor_does_not_match_crypto_ID record, (\_v489 -> (14, ("invalid_signed_hash",from_Invalid_Signed_Hash _v489))) <$> phase_1b_result_invalid_signed_hash record, (\_v489 -> (15, ("descriptor_does_not_match_signed_hash",from_Descriptor_Does_Not_Match_Signed_Hash _v489))) <$> phase_1b_result_descriptor_does_not_match_signed_hash record, (\_v489 -> (16, ("unparsable_hashable_message",from_Unparsable_Hashable_Message _v489))) <$> phase_1b_result_unparsable_hashable_message record, (\_v489 -> (17, ("invalid_address",from_Invalid_Address _v489))) <$> phase_1b_result_invalid_address record, (\_v489 -> (18, ("impossible_observer_graph",from_Impossible_Observer_Graph _v489))) <$> phase_1b_result_impossible_observer_graph record, (\_v489 -> (19, ("invalid_proposal_1a",from_Invalid_Proposal_1a _v489))) <$> phase_1b_result_invalid_proposal_1a record, (\_v489 -> (20, ("invalid_Phase_1b",from_Invalid_Phase_1b _v489))) <$> phase_1b_result_invalid_Phase_1b record, (\_v489 -> (21, ("invalid_Phase_2a",from_Invalid_Phase_2a _v489))) <$> phase_1b_result_invalid_Phase_2a record, (\_v489 -> (22, ("invalid_Phase_2b",from_Invalid_Phase_2b _v489))) <$> phase_1b_result_invalid_Phase_2b record, (\_v489 -> (23, ("invalid_Proof_of_Consensus",from_Invalid_Proof_of_Consensus _v489))) <$> phase_1b_result_invalid_Proof_of_Consensus record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v489 -> (1, ("no_supported_hash_sha2_descriptor_provided",from_No_Supported_Hash_Sha2_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_hash_sha2_descriptor_provided record
    , (\_v489 -> (2, ("descriptor_does_not_match_hash_sha2",from_Descriptor_Does_Not_Match_Hash_Sha2 _v489))) <$> phase_1b_result_descriptor_does_not_match_hash_sha2 record
    , (\_v489 -> (3, ("no_supported_hash_sha3_descriptor_provided",from_No_Supported_Hash_Sha3_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_hash_sha3_descriptor_provided record
    , (\_v489 -> (4, ("descriptor_does_not_match_hash_sha3",from_Descriptor_Does_Not_Match_Hash_Sha3 _v489))) <$> phase_1b_result_descriptor_does_not_match_hash_sha3 record
    , (\_v489 -> (5, ("no_supported_hash_type_descriptor_provided",from_No_Supported_Hash_Type_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_hash_type_descriptor_provided record
    , (\_v489 -> (6, ("descriptor_does_not_match_hash",from_Descriptor_Does_Not_Match_Hash _v489))) <$> phase_1b_result_descriptor_does_not_match_hash record
    , (\_v489 -> (7, ("invalid_public_crypto_key_X509",from_Invalid_Public_Crypto_Key_X509 _v489))) <$> phase_1b_result_invalid_public_crypto_key_X509 record
    , (\_v489 -> (8, ("invalid_public_crypto_key_PGP",from_Invalid_Public_Crypto_Key_PGP _v489))) <$> phase_1b_result_invalid_public_crypto_key_PGP record
    , (\_v489 -> (9, ("no_supported_public_crypto_key_type_descriptor_provided",from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided record
    , (\_v489 -> (10, ("descriptor_does_not_match_public_crypto_key",from_Descriptor_Does_Not_Match_Public_Crypto_Key _v489))) <$> phase_1b_result_descriptor_does_not_match_public_crypto_key record
    , (\_v489 -> (11, ("descriptor_does_not_match_crypto_ID_hash",from_Descriptor_Does_Not_Match_Crypto_ID_Hash _v489))) <$> phase_1b_result_descriptor_does_not_match_crypto_ID_hash record
    , (\_v489 -> (12, ("no_supported_crypto_ID_type_descriptor_provided",from_No_Supported_Crypto_ID_Type_Descriptor_Provided _v489))) <$> phase_1b_result_no_supported_crypto_ID_type_descriptor_provided record
    , (\_v489 -> (13, ("descriptor_does_not_match_crypto_ID",from_Descriptor_Does_Not_Match_Crypto_ID _v489))) <$> phase_1b_result_descriptor_does_not_match_crypto_ID record
    , (\_v489 -> (14, ("invalid_signed_hash",from_Invalid_Signed_Hash _v489))) <$> phase_1b_result_invalid_signed_hash record
    , (\_v489 -> (15, ("descriptor_does_not_match_signed_hash",from_Descriptor_Does_Not_Match_Signed_Hash _v489))) <$> phase_1b_result_descriptor_does_not_match_signed_hash record
    , (\_v489 -> (16, ("unparsable_hashable_message",from_Unparsable_Hashable_Message _v489))) <$> phase_1b_result_unparsable_hashable_message record
    , (\_v489 -> (17, ("invalid_address",from_Invalid_Address _v489))) <$> phase_1b_result_invalid_address record
    , (\_v489 -> (18, ("impossible_observer_graph",from_Impossible_Observer_Graph _v489))) <$> phase_1b_result_impossible_observer_graph record
    , (\_v489 -> (19, ("invalid_proposal_1a",from_Invalid_Proposal_1a _v489))) <$> phase_1b_result_invalid_proposal_1a record
    , (\_v489 -> (20, ("invalid_Phase_1b",from_Invalid_Phase_1b _v489))) <$> phase_1b_result_invalid_Phase_1b record
    , (\_v489 -> (21, ("invalid_Phase_2a",from_Invalid_Phase_2a _v489))) <$> phase_1b_result_invalid_Phase_2a record
    , (\_v489 -> (22, ("invalid_Phase_2b",from_Invalid_Phase_2b _v489))) <$> phase_1b_result_invalid_Phase_2b record
    , (\_v489 -> (23, ("invalid_Proof_of_Consensus",from_Invalid_Proof_of_Consensus _v489))) <$> phase_1b_result_invalid_Proof_of_Consensus record
    ]
    )
write_Phase_1b_result :: (T.Protocol p, T.Transport t) => p t -> Phase_1b_result -> P.IO ()
write_Phase_1b_result oprot record = T.writeVal oprot $ from_Phase_1b_result record
encode_Phase_1b_result :: (T.Protocol p, T.Transport t) => p t -> Phase_1b_result -> LBS.ByteString
encode_Phase_1b_result oprot record = T.serializeVal oprot $ from_Phase_1b_result record
to_Phase_1b_result :: T.ThriftVal -> Phase_1b_result
to_Phase_1b_result (T.TStruct fields) = Phase_1b_result{
  phase_1b_result_no_supported_hash_sha2_descriptor_provided = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val492 -> (to_No_Supported_Hash_Sha2_Descriptor_Provided (T.TStruct _val492)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  phase_1b_result_descriptor_does_not_match_hash_sha2 = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val493 -> (to_Descriptor_Does_Not_Match_Hash_Sha2 (T.TStruct _val493)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  phase_1b_result_no_supported_hash_sha3_descriptor_provided = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val494 -> (to_No_Supported_Hash_Sha3_Descriptor_Provided (T.TStruct _val494)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  phase_1b_result_descriptor_does_not_match_hash_sha3 = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val495 -> (to_Descriptor_Does_Not_Match_Hash_Sha3 (T.TStruct _val495)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  phase_1b_result_no_supported_hash_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val496 -> (to_No_Supported_Hash_Type_Descriptor_Provided (T.TStruct _val496)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  phase_1b_result_descriptor_does_not_match_hash = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val497 -> (to_Descriptor_Does_Not_Match_Hash (T.TStruct _val497)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  phase_1b_result_invalid_public_crypto_key_X509 = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val498 -> (to_Invalid_Public_Crypto_Key_X509 (T.TStruct _val498)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  phase_1b_result_invalid_public_crypto_key_PGP = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val499 -> (to_Invalid_Public_Crypto_Key_PGP (T.TStruct _val499)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val500 -> (to_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided (T.TStruct _val500)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  phase_1b_result_descriptor_does_not_match_public_crypto_key = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val501 -> (to_Descriptor_Does_Not_Match_Public_Crypto_Key (T.TStruct _val501)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  phase_1b_result_descriptor_does_not_match_crypto_ID_hash = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val502 -> (to_Descriptor_Does_Not_Match_Crypto_ID_Hash (T.TStruct _val502)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  phase_1b_result_no_supported_crypto_ID_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val503 -> (to_No_Supported_Crypto_ID_Type_Descriptor_Provided (T.TStruct _val503)); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  phase_1b_result_descriptor_does_not_match_crypto_ID = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val504 -> (to_Descriptor_Does_Not_Match_Crypto_ID (T.TStruct _val504)); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  phase_1b_result_invalid_signed_hash = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val505 -> (to_Invalid_Signed_Hash (T.TStruct _val505)); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  phase_1b_result_descriptor_does_not_match_signed_hash = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val506 -> (to_Descriptor_Does_Not_Match_Signed_Hash (T.TStruct _val506)); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  phase_1b_result_unparsable_hashable_message = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val507 -> (to_Unparsable_Hashable_Message (T.TStruct _val507)); _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  phase_1b_result_invalid_address = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val508 -> (to_Invalid_Address (T.TStruct _val508)); _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  phase_1b_result_impossible_observer_graph = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val509 -> (to_Impossible_Observer_Graph (T.TStruct _val509)); _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  phase_1b_result_invalid_proposal_1a = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val510 -> (to_Invalid_Proposal_1a (T.TStruct _val510)); _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  phase_1b_result_invalid_Phase_1b = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val511 -> (to_Invalid_Phase_1b (T.TStruct _val511)); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  phase_1b_result_invalid_Phase_2a = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val512 -> (to_Invalid_Phase_2a (T.TStruct _val512)); _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  phase_1b_result_invalid_Phase_2b = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val513 -> (to_Invalid_Phase_2b (T.TStruct _val513)); _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  phase_1b_result_invalid_Proof_of_Consensus = P.maybe (P.Nothing) (\(_,_val491) -> P.Just (case _val491 of {T.TStruct _val514 -> (to_Invalid_Proof_of_Consensus (T.TStruct _val514)); _ -> P.error "wrong type"})) (Map.lookup (23) fields)
  }
to_Phase_1b_result _ = P.error "not a struct"
read_Phase_1b_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Phase_1b_result
read_Phase_1b_result iprot = to_Phase_1b_result <$> T.readVal iprot (T.T_STRUCT typemap_Phase_1b_result)
decode_Phase_1b_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Phase_1b_result
decode_Phase_1b_result iprot bs = to_Phase_1b_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Phase_1b_result) bs
typemap_Phase_1b_result :: T.TypeMap
typemap_Phase_1b_result = Map.fromList [(1,("no_supported_hash_sha2_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Sha2_Descriptor_Provided))),(2,("descriptor_does_not_match_hash_sha2",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha2))),(3,("no_supported_hash_sha3_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Sha3_Descriptor_Provided))),(4,("descriptor_does_not_match_hash_sha3",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha3))),(5,("no_supported_hash_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Type_Descriptor_Provided))),(6,("descriptor_does_not_match_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash))),(7,("invalid_public_crypto_key_X509",(T.T_STRUCT typemap_Invalid_Public_Crypto_Key_X509))),(8,("invalid_public_crypto_key_PGP",(T.T_STRUCT typemap_Invalid_Public_Crypto_Key_PGP))),(9,("no_supported_public_crypto_key_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided))),(10,("descriptor_does_not_match_public_crypto_key",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Public_Crypto_Key))),(11,("descriptor_does_not_match_crypto_ID_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID_Hash))),(12,("no_supported_crypto_ID_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Crypto_ID_Type_Descriptor_Provided))),(13,("descriptor_does_not_match_crypto_ID",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID))),(14,("invalid_signed_hash",(T.T_STRUCT typemap_Invalid_Signed_Hash))),(15,("descriptor_does_not_match_signed_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Signed_Hash))),(16,("unparsable_hashable_message",(T.T_STRUCT typemap_Unparsable_Hashable_Message))),(17,("invalid_address",(T.T_STRUCT typemap_Invalid_Address))),(18,("impossible_observer_graph",(T.T_STRUCT typemap_Impossible_Observer_Graph))),(19,("invalid_proposal_1a",(T.T_STRUCT typemap_Invalid_Proposal_1a))),(20,("invalid_Phase_1b",(T.T_STRUCT typemap_Invalid_Phase_1b))),(21,("invalid_Phase_2a",(T.T_STRUCT typemap_Invalid_Phase_2a))),(22,("invalid_Phase_2b",(T.T_STRUCT typemap_Invalid_Phase_2b))),(23,("invalid_Proof_of_Consensus",(T.T_STRUCT typemap_Invalid_Proof_of_Consensus)))]
default_Phase_1b_result :: Phase_1b_result
default_Phase_1b_result = Phase_1b_result{
  phase_1b_result_no_supported_hash_sha2_descriptor_provided = P.Nothing,
  phase_1b_result_descriptor_does_not_match_hash_sha2 = P.Nothing,
  phase_1b_result_no_supported_hash_sha3_descriptor_provided = P.Nothing,
  phase_1b_result_descriptor_does_not_match_hash_sha3 = P.Nothing,
  phase_1b_result_no_supported_hash_type_descriptor_provided = P.Nothing,
  phase_1b_result_descriptor_does_not_match_hash = P.Nothing,
  phase_1b_result_invalid_public_crypto_key_X509 = P.Nothing,
  phase_1b_result_invalid_public_crypto_key_PGP = P.Nothing,
  phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided = P.Nothing,
  phase_1b_result_descriptor_does_not_match_public_crypto_key = P.Nothing,
  phase_1b_result_descriptor_does_not_match_crypto_ID_hash = P.Nothing,
  phase_1b_result_no_supported_crypto_ID_type_descriptor_provided = P.Nothing,
  phase_1b_result_descriptor_does_not_match_crypto_ID = P.Nothing,
  phase_1b_result_invalid_signed_hash = P.Nothing,
  phase_1b_result_descriptor_does_not_match_signed_hash = P.Nothing,
  phase_1b_result_unparsable_hashable_message = P.Nothing,
  phase_1b_result_invalid_address = P.Nothing,
  phase_1b_result_impossible_observer_graph = P.Nothing,
  phase_1b_result_invalid_proposal_1a = P.Nothing,
  phase_1b_result_invalid_Phase_1b = P.Nothing,
  phase_1b_result_invalid_Phase_2a = P.Nothing,
  phase_1b_result_invalid_Phase_2b = P.Nothing,
  phase_1b_result_invalid_Proof_of_Consensus = P.Nothing}
process_ping (seqid, iprot, oprot, handler) = do
  args <- read_Ping_args iprot
  (X.catch
    (do
      Iface.ping handler
      let res = default_Ping_result
      T.writeMessageBegin oprot ("ping", T.M_REPLY, seqid)
      write_Ping_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("ping", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_proposal_1a (seqid, iprot, oprot, handler) = do
  args <- read_Proposal_1a_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (X.catch
            (X.catch
              (X.catch
                (X.catch
                  (X.catch
                    (X.catch
                      (X.catch
                        (X.catch
                          (X.catch
                            (X.catch
                              (X.catch
                                (X.catch
                                  (X.catch
                                    (X.catch
                                      (X.catch
                                        (X.catch
                                          (X.catch
                                            (X.catch
                                              (X.catch
                                                (X.catch
                                                  (do
                                                    Iface.proposal_1a handler (proposal_1a_args_proposal args)
                                                    let res = default_Proposal_1a_result
                                                    T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                                    write_Proposal_1a_result oprot res
                                                    T.writeMessageEnd oprot
                                                    T.tFlush (T.getTransport oprot))
                                                  (\e  -> do
                                                    let res = default_Proposal_1a_result{proposal_1a_result_no_supported_hash_sha2_descriptor_provided = P.Just e}
                                                    T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                                    write_Proposal_1a_result oprot res
                                                    T.writeMessageEnd oprot
                                                    T.tFlush (T.getTransport oprot)))
                                                (\e  -> do
                                                  let res = default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash_sha2 = P.Just e}
                                                  T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                                  write_Proposal_1a_result oprot res
                                                  T.writeMessageEnd oprot
                                                  T.tFlush (T.getTransport oprot)))
                                              (\e  -> do
                                                let res = default_Proposal_1a_result{proposal_1a_result_no_supported_hash_sha3_descriptor_provided = P.Just e}
                                                T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                                write_Proposal_1a_result oprot res
                                                T.writeMessageEnd oprot
                                                T.tFlush (T.getTransport oprot)))
                                            (\e  -> do
                                              let res = default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash_sha3 = P.Just e}
                                              T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                              write_Proposal_1a_result oprot res
                                              T.writeMessageEnd oprot
                                              T.tFlush (T.getTransport oprot)))
                                          (\e  -> do
                                            let res = default_Proposal_1a_result{proposal_1a_result_no_supported_hash_type_descriptor_provided = P.Just e}
                                            T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                            write_Proposal_1a_result oprot res
                                            T.writeMessageEnd oprot
                                            T.tFlush (T.getTransport oprot)))
                                        (\e  -> do
                                          let res = default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_hash = P.Just e}
                                          T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                          write_Proposal_1a_result oprot res
                                          T.writeMessageEnd oprot
                                          T.tFlush (T.getTransport oprot)))
                                      (\e  -> do
                                        let res = default_Proposal_1a_result{proposal_1a_result_invalid_public_crypto_key_X509 = P.Just e}
                                        T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                        write_Proposal_1a_result oprot res
                                        T.writeMessageEnd oprot
                                        T.tFlush (T.getTransport oprot)))
                                    (\e  -> do
                                      let res = default_Proposal_1a_result{proposal_1a_result_invalid_public_crypto_key_PGP = P.Just e}
                                      T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                      write_Proposal_1a_result oprot res
                                      T.writeMessageEnd oprot
                                      T.tFlush (T.getTransport oprot)))
                                  (\e  -> do
                                    let res = default_Proposal_1a_result{proposal_1a_result_no_supported_public_crypto_key_type_descriptor_provided = P.Just e}
                                    T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                    write_Proposal_1a_result oprot res
                                    T.writeMessageEnd oprot
                                    T.tFlush (T.getTransport oprot)))
                                (\e  -> do
                                  let res = default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_public_crypto_key = P.Just e}
                                  T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                  write_Proposal_1a_result oprot res
                                  T.writeMessageEnd oprot
                                  T.tFlush (T.getTransport oprot)))
                              (\e  -> do
                                let res = default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_crypto_ID_hash = P.Just e}
                                T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                                write_Proposal_1a_result oprot res
                                T.writeMessageEnd oprot
                                T.tFlush (T.getTransport oprot)))
                            (\e  -> do
                              let res = default_Proposal_1a_result{proposal_1a_result_no_supported_crypto_ID_type_descriptor_provided = P.Just e}
                              T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                              write_Proposal_1a_result oprot res
                              T.writeMessageEnd oprot
                              T.tFlush (T.getTransport oprot)))
                          (\e  -> do
                            let res = default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_crypto_ID = P.Just e}
                            T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                            write_Proposal_1a_result oprot res
                            T.writeMessageEnd oprot
                            T.tFlush (T.getTransport oprot)))
                        (\e  -> do
                          let res = default_Proposal_1a_result{proposal_1a_result_invalid_signed_hash = P.Just e}
                          T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                          write_Proposal_1a_result oprot res
                          T.writeMessageEnd oprot
                          T.tFlush (T.getTransport oprot)))
                      (\e  -> do
                        let res = default_Proposal_1a_result{proposal_1a_result_descriptor_does_not_match_signed_hash = P.Just e}
                        T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                        write_Proposal_1a_result oprot res
                        T.writeMessageEnd oprot
                        T.tFlush (T.getTransport oprot)))
                    (\e  -> do
                      let res = default_Proposal_1a_result{proposal_1a_result_unparsable_hashable_message = P.Just e}
                      T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                      write_Proposal_1a_result oprot res
                      T.writeMessageEnd oprot
                      T.tFlush (T.getTransport oprot)))
                  (\e  -> do
                    let res = default_Proposal_1a_result{proposal_1a_result_invalid_address = P.Just e}
                    T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                    write_Proposal_1a_result oprot res
                    T.writeMessageEnd oprot
                    T.tFlush (T.getTransport oprot)))
                (\e  -> do
                  let res = default_Proposal_1a_result{proposal_1a_result_impossible_observer_graph = P.Just e}
                  T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                  write_Proposal_1a_result oprot res
                  T.writeMessageEnd oprot
                  T.tFlush (T.getTransport oprot)))
              (\e  -> do
                let res = default_Proposal_1a_result{proposal_1a_result_invalid_proposal_1a = P.Just e}
                T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
                write_Proposal_1a_result oprot res
                T.writeMessageEnd oprot
                T.tFlush (T.getTransport oprot)))
            (\e  -> do
              let res = default_Proposal_1a_result{proposal_1a_result_invalid_Phase_1b = P.Just e}
              T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
              write_Proposal_1a_result oprot res
              T.writeMessageEnd oprot
              T.tFlush (T.getTransport oprot)))
          (\e  -> do
            let res = default_Proposal_1a_result{proposal_1a_result_invalid_Phase_2a = P.Just e}
            T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
            write_Proposal_1a_result oprot res
            T.writeMessageEnd oprot
            T.tFlush (T.getTransport oprot)))
        (\e  -> do
          let res = default_Proposal_1a_result{proposal_1a_result_invalid_Phase_2b = P.Just e}
          T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
          write_Proposal_1a_result oprot res
          T.writeMessageEnd oprot
          T.tFlush (T.getTransport oprot)))
      (\e  -> do
        let res = default_Proposal_1a_result{proposal_1a_result_invalid_Proof_of_Consensus = P.Just e}
        T.writeMessageBegin oprot ("proposal_1a", T.M_REPLY, seqid)
        write_Proposal_1a_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("proposal_1a", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_phase_1b (seqid, iprot, oprot, handler) = do
  args <- read_Phase_1b_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (X.catch
            (X.catch
              (X.catch
                (X.catch
                  (X.catch
                    (X.catch
                      (X.catch
                        (X.catch
                          (X.catch
                            (X.catch
                              (X.catch
                                (X.catch
                                  (X.catch
                                    (X.catch
                                      (X.catch
                                        (X.catch
                                          (X.catch
                                            (X.catch
                                              (X.catch
                                                (X.catch
                                                  (do
                                                    Iface.phase_1b handler (phase_1b_args_phase_1b_message args)
                                                    let res = default_Phase_1b_result
                                                    T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                                    write_Phase_1b_result oprot res
                                                    T.writeMessageEnd oprot
                                                    T.tFlush (T.getTransport oprot))
                                                  (\e  -> do
                                                    let res = default_Phase_1b_result{phase_1b_result_no_supported_hash_sha2_descriptor_provided = P.Just e}
                                                    T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                                    write_Phase_1b_result oprot res
                                                    T.writeMessageEnd oprot
                                                    T.tFlush (T.getTransport oprot)))
                                                (\e  -> do
                                                  let res = default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash_sha2 = P.Just e}
                                                  T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                                  write_Phase_1b_result oprot res
                                                  T.writeMessageEnd oprot
                                                  T.tFlush (T.getTransport oprot)))
                                              (\e  -> do
                                                let res = default_Phase_1b_result{phase_1b_result_no_supported_hash_sha3_descriptor_provided = P.Just e}
                                                T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                                write_Phase_1b_result oprot res
                                                T.writeMessageEnd oprot
                                                T.tFlush (T.getTransport oprot)))
                                            (\e  -> do
                                              let res = default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash_sha3 = P.Just e}
                                              T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                              write_Phase_1b_result oprot res
                                              T.writeMessageEnd oprot
                                              T.tFlush (T.getTransport oprot)))
                                          (\e  -> do
                                            let res = default_Phase_1b_result{phase_1b_result_no_supported_hash_type_descriptor_provided = P.Just e}
                                            T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                            write_Phase_1b_result oprot res
                                            T.writeMessageEnd oprot
                                            T.tFlush (T.getTransport oprot)))
                                        (\e  -> do
                                          let res = default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_hash = P.Just e}
                                          T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                          write_Phase_1b_result oprot res
                                          T.writeMessageEnd oprot
                                          T.tFlush (T.getTransport oprot)))
                                      (\e  -> do
                                        let res = default_Phase_1b_result{phase_1b_result_invalid_public_crypto_key_X509 = P.Just e}
                                        T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                        write_Phase_1b_result oprot res
                                        T.writeMessageEnd oprot
                                        T.tFlush (T.getTransport oprot)))
                                    (\e  -> do
                                      let res = default_Phase_1b_result{phase_1b_result_invalid_public_crypto_key_PGP = P.Just e}
                                      T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                      write_Phase_1b_result oprot res
                                      T.writeMessageEnd oprot
                                      T.tFlush (T.getTransport oprot)))
                                  (\e  -> do
                                    let res = default_Phase_1b_result{phase_1b_result_no_supported_public_crypto_key_type_descriptor_provided = P.Just e}
                                    T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                    write_Phase_1b_result oprot res
                                    T.writeMessageEnd oprot
                                    T.tFlush (T.getTransport oprot)))
                                (\e  -> do
                                  let res = default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_public_crypto_key = P.Just e}
                                  T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                  write_Phase_1b_result oprot res
                                  T.writeMessageEnd oprot
                                  T.tFlush (T.getTransport oprot)))
                              (\e  -> do
                                let res = default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_crypto_ID_hash = P.Just e}
                                T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                                write_Phase_1b_result oprot res
                                T.writeMessageEnd oprot
                                T.tFlush (T.getTransport oprot)))
                            (\e  -> do
                              let res = default_Phase_1b_result{phase_1b_result_no_supported_crypto_ID_type_descriptor_provided = P.Just e}
                              T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                              write_Phase_1b_result oprot res
                              T.writeMessageEnd oprot
                              T.tFlush (T.getTransport oprot)))
                          (\e  -> do
                            let res = default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_crypto_ID = P.Just e}
                            T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                            write_Phase_1b_result oprot res
                            T.writeMessageEnd oprot
                            T.tFlush (T.getTransport oprot)))
                        (\e  -> do
                          let res = default_Phase_1b_result{phase_1b_result_invalid_signed_hash = P.Just e}
                          T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                          write_Phase_1b_result oprot res
                          T.writeMessageEnd oprot
                          T.tFlush (T.getTransport oprot)))
                      (\e  -> do
                        let res = default_Phase_1b_result{phase_1b_result_descriptor_does_not_match_signed_hash = P.Just e}
                        T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                        write_Phase_1b_result oprot res
                        T.writeMessageEnd oprot
                        T.tFlush (T.getTransport oprot)))
                    (\e  -> do
                      let res = default_Phase_1b_result{phase_1b_result_unparsable_hashable_message = P.Just e}
                      T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                      write_Phase_1b_result oprot res
                      T.writeMessageEnd oprot
                      T.tFlush (T.getTransport oprot)))
                  (\e  -> do
                    let res = default_Phase_1b_result{phase_1b_result_invalid_address = P.Just e}
                    T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                    write_Phase_1b_result oprot res
                    T.writeMessageEnd oprot
                    T.tFlush (T.getTransport oprot)))
                (\e  -> do
                  let res = default_Phase_1b_result{phase_1b_result_impossible_observer_graph = P.Just e}
                  T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                  write_Phase_1b_result oprot res
                  T.writeMessageEnd oprot
                  T.tFlush (T.getTransport oprot)))
              (\e  -> do
                let res = default_Phase_1b_result{phase_1b_result_invalid_proposal_1a = P.Just e}
                T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
                write_Phase_1b_result oprot res
                T.writeMessageEnd oprot
                T.tFlush (T.getTransport oprot)))
            (\e  -> do
              let res = default_Phase_1b_result{phase_1b_result_invalid_Phase_1b = P.Just e}
              T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
              write_Phase_1b_result oprot res
              T.writeMessageEnd oprot
              T.tFlush (T.getTransport oprot)))
          (\e  -> do
            let res = default_Phase_1b_result{phase_1b_result_invalid_Phase_2a = P.Just e}
            T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
            write_Phase_1b_result oprot res
            T.writeMessageEnd oprot
            T.tFlush (T.getTransport oprot)))
        (\e  -> do
          let res = default_Phase_1b_result{phase_1b_result_invalid_Phase_2b = P.Just e}
          T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
          write_Phase_1b_result oprot res
          T.writeMessageEnd oprot
          T.tFlush (T.getTransport oprot)))
      (\e  -> do
        let res = default_Phase_1b_result{phase_1b_result_invalid_Proof_of_Consensus = P.Just e}
        T.writeMessageBegin oprot ("phase_1b", T.M_REPLY, seqid)
        write_Phase_1b_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("phase_1b", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "ping" -> process_ping (seqid,iprot,oprot,handler)
  "proposal_1a" -> process_proposal_1a (seqid,iprot,oprot,handler)
  "phase_1b" -> process_phase_1b (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
