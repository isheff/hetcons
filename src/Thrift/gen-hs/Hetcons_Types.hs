{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (1.0.0-dev)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Hetcons_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


type Hash_Sha2_Descriptor = Set.HashSet I.Int8

type Hash_Sha2 = LBS.ByteString

type Hash_Sha3_Descriptor = Set.HashSet I.Int8

type Hash_Sha3 = LBS.ByteString

type Public_Crypto_Key_X509 = LBS.ByteString

type Public_Crypto_Key_PGP = LBS.ByteString

type Wishful_Thinking = LT.Text

type Hashable_Message = LBS.ByteString

type Timestamp = I.Int64

type DNS_Name = LT.Text

type Port_Number = I.Int32

type Participant_Set = Set.HashSet Participant_ID

type Quorum = Set.HashSet Participant_ID

type Observer_Graph = Set.HashSet Observer_Trust_Constraint

type Observer_Quorums = Map.HashMap Participant_ID (Set.HashSet (Set.HashSet Participant_ID))

type Value_Witness = LBS.ByteString

type Value_Payload = LBS.ByteString

type Value = LBS.ByteString

type Slot = I.Int64

data No_Supported_Hash_Sha2_Descriptor_Provided = No_Supported_Hash_Sha2_Descriptor_Provided  { no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor :: P.Maybe (Set.HashSet I.Int8)
  , no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor :: P.Maybe (Set.HashSet I.Int8)
  , no_Supported_Hash_Sha2_Descriptor_Provided_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception No_Supported_Hash_Sha2_Descriptor_Provided
instance H.Hashable No_Supported_Hash_Sha2_Descriptor_Provided where
  hashWithSalt salt record = salt   `H.hashWithSalt` no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor record   `H.hashWithSalt` no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor record   `H.hashWithSalt` no_Supported_Hash_Sha2_Descriptor_Provided_explanation record  
instance QC.Arbitrary No_Supported_Hash_Sha2_Descriptor_Provided where 
  arbitrary = M.liftM No_Supported_Hash_Sha2_Descriptor_Provided (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_No_Supported_Hash_Sha2_Descriptor_Provided = []
             | P.otherwise = M.catMaybes
    [ if obj == default_No_Supported_Hash_Sha2_Descriptor_Provided{no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor = no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Sha2_Descriptor_Provided{no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor = no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor obj}
    , if obj == default_No_Supported_Hash_Sha2_Descriptor_Provided{no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor = no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Sha2_Descriptor_Provided{no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor = no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor obj}
    , if obj == default_No_Supported_Hash_Sha2_Descriptor_Provided{no_Supported_Hash_Sha2_Descriptor_Provided_explanation = no_Supported_Hash_Sha2_Descriptor_Provided_explanation obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Sha2_Descriptor_Provided{no_Supported_Hash_Sha2_Descriptor_Provided_explanation = no_Supported_Hash_Sha2_Descriptor_Provided_explanation obj}
    ]
from_No_Supported_Hash_Sha2_Descriptor_Provided :: No_Supported_Hash_Sha2_Descriptor_Provided -> T.ThriftVal
from_No_Supported_Hash_Sha2_Descriptor_Provided record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> (1, ("offending_hash_sha2_descriptor",T.TSet T.T_BYTE $ P.map (\_v4 -> T.TByte _v4) $ Set.toList _v2))) <$> no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor record
  , (\_v2 -> (2, ("supported_hash_sha2_descriptor",T.TSet T.T_BYTE $ P.map (\_v6 -> T.TByte _v6) $ Set.toList _v2))) <$> no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor record
  , (\_v2 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v2))) <$> no_Supported_Hash_Sha2_Descriptor_Provided_explanation record
  ]
write_No_Supported_Hash_Sha2_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Hash_Sha2_Descriptor_Provided -> P.IO ()
write_No_Supported_Hash_Sha2_Descriptor_Provided oprot record = T.writeVal oprot $ from_No_Supported_Hash_Sha2_Descriptor_Provided record
encode_No_Supported_Hash_Sha2_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Hash_Sha2_Descriptor_Provided -> LBS.ByteString
encode_No_Supported_Hash_Sha2_Descriptor_Provided oprot record = T.serializeVal oprot $ from_No_Supported_Hash_Sha2_Descriptor_Provided record
to_No_Supported_Hash_Sha2_Descriptor_Provided :: T.ThriftVal -> No_Supported_Hash_Sha2_Descriptor_Provided
to_No_Supported_Hash_Sha2_Descriptor_Provided (T.TStruct fields) = No_Supported_Hash_Sha2_Descriptor_Provided{
  no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TSet _ _val9 -> (Set.fromList $ P.map (\_v10 -> (case _v10 of {T.TByte _val11 -> _val11; _ -> P.error "wrong type"})) _val9); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TSet _ _val12 -> (Set.fromList $ P.map (\_v13 -> (case _v13 of {T.TByte _val14 -> _val14; _ -> P.error "wrong type"})) _val12); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  no_Supported_Hash_Sha2_Descriptor_Provided_explanation = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TString _val15 -> E.decodeUtf8 _val15; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_No_Supported_Hash_Sha2_Descriptor_Provided _ = P.error "not a struct"
read_No_Supported_Hash_Sha2_Descriptor_Provided :: (T.Transport t, T.Protocol p) => p t -> P.IO No_Supported_Hash_Sha2_Descriptor_Provided
read_No_Supported_Hash_Sha2_Descriptor_Provided iprot = to_No_Supported_Hash_Sha2_Descriptor_Provided <$> T.readVal iprot (T.T_STRUCT typemap_No_Supported_Hash_Sha2_Descriptor_Provided)
decode_No_Supported_Hash_Sha2_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> No_Supported_Hash_Sha2_Descriptor_Provided
decode_No_Supported_Hash_Sha2_Descriptor_Provided iprot bs = to_No_Supported_Hash_Sha2_Descriptor_Provided $ T.deserializeVal iprot (T.T_STRUCT typemap_No_Supported_Hash_Sha2_Descriptor_Provided) bs
typemap_No_Supported_Hash_Sha2_Descriptor_Provided :: T.TypeMap
typemap_No_Supported_Hash_Sha2_Descriptor_Provided = Map.fromList [(1,("offending_hash_sha2_descriptor",(T.T_SET T.T_BYTE))),(2,("supported_hash_sha2_descriptor",(T.T_SET T.T_BYTE))),(3,("explanation",T.T_STRING))]
default_No_Supported_Hash_Sha2_Descriptor_Provided :: No_Supported_Hash_Sha2_Descriptor_Provided
default_No_Supported_Hash_Sha2_Descriptor_Provided = No_Supported_Hash_Sha2_Descriptor_Provided{
  no_Supported_Hash_Sha2_Descriptor_Provided_offending_hash_sha2_descriptor = P.Nothing,
  no_Supported_Hash_Sha2_Descriptor_Provided_supported_hash_sha2_descriptor = P.Nothing,
  no_Supported_Hash_Sha2_Descriptor_Provided_explanation = P.Nothing}
data Descriptor_Does_Not_Match_Hash_Sha2 = Descriptor_Does_Not_Match_Hash_Sha2  { descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor :: (Set.HashSet I.Int8)
  , descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 :: LBS.ByteString
  , descriptor_Does_Not_Match_Hash_Sha2_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Descriptor_Does_Not_Match_Hash_Sha2
instance H.Hashable Descriptor_Does_Not_Match_Hash_Sha2 where
  hashWithSalt salt record = salt   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor record   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 record   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_Sha2_explanation record  
instance QC.Arbitrary Descriptor_Does_Not_Match_Hash_Sha2 where 
  arbitrary = M.liftM Descriptor_Does_Not_Match_Hash_Sha2 (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Descriptor_Does_Not_Match_Hash_Sha2 = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Descriptor_Does_Not_Match_Hash_Sha2{descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor = descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash_Sha2{descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor = descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor obj}
    , if obj == default_Descriptor_Does_Not_Match_Hash_Sha2{descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 = descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash_Sha2{descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 = descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 obj}
    , if obj == default_Descriptor_Does_Not_Match_Hash_Sha2{descriptor_Does_Not_Match_Hash_Sha2_explanation = descriptor_Does_Not_Match_Hash_Sha2_explanation obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash_Sha2{descriptor_Does_Not_Match_Hash_Sha2_explanation = descriptor_Does_Not_Match_Hash_Sha2_explanation obj}
    ]
from_Descriptor_Does_Not_Match_Hash_Sha2 :: Descriptor_Does_Not_Match_Hash_Sha2 -> T.ThriftVal
from_Descriptor_Does_Not_Match_Hash_Sha2 record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v18 -> P.Just (1, ("hash_sha2_descriptor",T.TSet T.T_BYTE $ P.map (\_v20 -> T.TByte _v20) $ Set.toList _v18))) $ descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor record
  , (\_v18 -> P.Just (2, ("hash_sha2",T.TBinary _v18))) $ descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 record
  , (\_v18 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v18))) <$> descriptor_Does_Not_Match_Hash_Sha2_explanation record
  ]
write_Descriptor_Does_Not_Match_Hash_Sha2 :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Hash_Sha2 -> P.IO ()
write_Descriptor_Does_Not_Match_Hash_Sha2 oprot record = T.writeVal oprot $ from_Descriptor_Does_Not_Match_Hash_Sha2 record
encode_Descriptor_Does_Not_Match_Hash_Sha2 :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Hash_Sha2 -> LBS.ByteString
encode_Descriptor_Does_Not_Match_Hash_Sha2 oprot record = T.serializeVal oprot $ from_Descriptor_Does_Not_Match_Hash_Sha2 record
to_Descriptor_Does_Not_Match_Hash_Sha2 :: T.ThriftVal -> Descriptor_Does_Not_Match_Hash_Sha2
to_Descriptor_Does_Not_Match_Hash_Sha2 (T.TStruct fields) = Descriptor_Does_Not_Match_Hash_Sha2{
  descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor = P.maybe (descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor default_Descriptor_Does_Not_Match_Hash_Sha2) (\(_,_val22) -> (case _val22 of {T.TSet _ _val23 -> (Set.fromList $ P.map (\_v24 -> (case _v24 of {T.TByte _val25 -> _val25; _ -> P.error "wrong type"})) _val23); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 = P.maybe (descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 default_Descriptor_Does_Not_Match_Hash_Sha2) (\(_,_val22) -> (case _val22 of {T.TBinary _val26 -> _val26; T.TString _val26 -> _val26; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  descriptor_Does_Not_Match_Hash_Sha2_explanation = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TString _val27 -> E.decodeUtf8 _val27; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Descriptor_Does_Not_Match_Hash_Sha2 _ = P.error "not a struct"
read_Descriptor_Does_Not_Match_Hash_Sha2 :: (T.Transport t, T.Protocol p) => p t -> P.IO Descriptor_Does_Not_Match_Hash_Sha2
read_Descriptor_Does_Not_Match_Hash_Sha2 iprot = to_Descriptor_Does_Not_Match_Hash_Sha2 <$> T.readVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha2)
decode_Descriptor_Does_Not_Match_Hash_Sha2 :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Descriptor_Does_Not_Match_Hash_Sha2
decode_Descriptor_Does_Not_Match_Hash_Sha2 iprot bs = to_Descriptor_Does_Not_Match_Hash_Sha2 $ T.deserializeVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha2) bs
typemap_Descriptor_Does_Not_Match_Hash_Sha2 :: T.TypeMap
typemap_Descriptor_Does_Not_Match_Hash_Sha2 = Map.fromList [(1,("hash_sha2_descriptor",(T.T_SET T.T_BYTE))),(2,("hash_sha2",T.T_BINARY)),(3,("explanation",T.T_STRING))]
default_Descriptor_Does_Not_Match_Hash_Sha2 :: Descriptor_Does_Not_Match_Hash_Sha2
default_Descriptor_Does_Not_Match_Hash_Sha2 = Descriptor_Does_Not_Match_Hash_Sha2{
  descriptor_Does_Not_Match_Hash_Sha2_hash_sha2_descriptor = Set.empty,
  descriptor_Does_Not_Match_Hash_Sha2_hash_sha2 = "",
  descriptor_Does_Not_Match_Hash_Sha2_explanation = P.Nothing}
data No_Supported_Hash_Sha3_Descriptor_Provided = No_Supported_Hash_Sha3_Descriptor_Provided  { no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor :: P.Maybe (Set.HashSet I.Int8)
  , no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor :: P.Maybe (Set.HashSet I.Int8)
  , no_Supported_Hash_Sha3_Descriptor_Provided_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception No_Supported_Hash_Sha3_Descriptor_Provided
instance H.Hashable No_Supported_Hash_Sha3_Descriptor_Provided where
  hashWithSalt salt record = salt   `H.hashWithSalt` no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor record   `H.hashWithSalt` no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor record   `H.hashWithSalt` no_Supported_Hash_Sha3_Descriptor_Provided_explanation record  
instance QC.Arbitrary No_Supported_Hash_Sha3_Descriptor_Provided where 
  arbitrary = M.liftM No_Supported_Hash_Sha3_Descriptor_Provided (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_No_Supported_Hash_Sha3_Descriptor_Provided = []
             | P.otherwise = M.catMaybes
    [ if obj == default_No_Supported_Hash_Sha3_Descriptor_Provided{no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor = no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Sha3_Descriptor_Provided{no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor = no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor obj}
    , if obj == default_No_Supported_Hash_Sha3_Descriptor_Provided{no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor = no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Sha3_Descriptor_Provided{no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor = no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor obj}
    , if obj == default_No_Supported_Hash_Sha3_Descriptor_Provided{no_Supported_Hash_Sha3_Descriptor_Provided_explanation = no_Supported_Hash_Sha3_Descriptor_Provided_explanation obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Sha3_Descriptor_Provided{no_Supported_Hash_Sha3_Descriptor_Provided_explanation = no_Supported_Hash_Sha3_Descriptor_Provided_explanation obj}
    ]
from_No_Supported_Hash_Sha3_Descriptor_Provided :: No_Supported_Hash_Sha3_Descriptor_Provided -> T.ThriftVal
from_No_Supported_Hash_Sha3_Descriptor_Provided record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v30 -> (1, ("offending_hash_sha3_descriptor",T.TSet T.T_BYTE $ P.map (\_v32 -> T.TByte _v32) $ Set.toList _v30))) <$> no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor record
  , (\_v30 -> (2, ("supported_hash_sha3_descriptor",T.TSet T.T_BYTE $ P.map (\_v34 -> T.TByte _v34) $ Set.toList _v30))) <$> no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor record
  , (\_v30 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v30))) <$> no_Supported_Hash_Sha3_Descriptor_Provided_explanation record
  ]
write_No_Supported_Hash_Sha3_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Hash_Sha3_Descriptor_Provided -> P.IO ()
write_No_Supported_Hash_Sha3_Descriptor_Provided oprot record = T.writeVal oprot $ from_No_Supported_Hash_Sha3_Descriptor_Provided record
encode_No_Supported_Hash_Sha3_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Hash_Sha3_Descriptor_Provided -> LBS.ByteString
encode_No_Supported_Hash_Sha3_Descriptor_Provided oprot record = T.serializeVal oprot $ from_No_Supported_Hash_Sha3_Descriptor_Provided record
to_No_Supported_Hash_Sha3_Descriptor_Provided :: T.ThriftVal -> No_Supported_Hash_Sha3_Descriptor_Provided
to_No_Supported_Hash_Sha3_Descriptor_Provided (T.TStruct fields) = No_Supported_Hash_Sha3_Descriptor_Provided{
  no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor = P.maybe (P.Nothing) (\(_,_val36) -> P.Just (case _val36 of {T.TSet _ _val37 -> (Set.fromList $ P.map (\_v38 -> (case _v38 of {T.TByte _val39 -> _val39; _ -> P.error "wrong type"})) _val37); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor = P.maybe (P.Nothing) (\(_,_val36) -> P.Just (case _val36 of {T.TSet _ _val40 -> (Set.fromList $ P.map (\_v41 -> (case _v41 of {T.TByte _val42 -> _val42; _ -> P.error "wrong type"})) _val40); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  no_Supported_Hash_Sha3_Descriptor_Provided_explanation = P.maybe (P.Nothing) (\(_,_val36) -> P.Just (case _val36 of {T.TString _val43 -> E.decodeUtf8 _val43; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_No_Supported_Hash_Sha3_Descriptor_Provided _ = P.error "not a struct"
read_No_Supported_Hash_Sha3_Descriptor_Provided :: (T.Transport t, T.Protocol p) => p t -> P.IO No_Supported_Hash_Sha3_Descriptor_Provided
read_No_Supported_Hash_Sha3_Descriptor_Provided iprot = to_No_Supported_Hash_Sha3_Descriptor_Provided <$> T.readVal iprot (T.T_STRUCT typemap_No_Supported_Hash_Sha3_Descriptor_Provided)
decode_No_Supported_Hash_Sha3_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> No_Supported_Hash_Sha3_Descriptor_Provided
decode_No_Supported_Hash_Sha3_Descriptor_Provided iprot bs = to_No_Supported_Hash_Sha3_Descriptor_Provided $ T.deserializeVal iprot (T.T_STRUCT typemap_No_Supported_Hash_Sha3_Descriptor_Provided) bs
typemap_No_Supported_Hash_Sha3_Descriptor_Provided :: T.TypeMap
typemap_No_Supported_Hash_Sha3_Descriptor_Provided = Map.fromList [(1,("offending_hash_sha3_descriptor",(T.T_SET T.T_BYTE))),(2,("supported_hash_sha3_descriptor",(T.T_SET T.T_BYTE))),(3,("explanation",T.T_STRING))]
default_No_Supported_Hash_Sha3_Descriptor_Provided :: No_Supported_Hash_Sha3_Descriptor_Provided
default_No_Supported_Hash_Sha3_Descriptor_Provided = No_Supported_Hash_Sha3_Descriptor_Provided{
  no_Supported_Hash_Sha3_Descriptor_Provided_offending_hash_sha3_descriptor = P.Nothing,
  no_Supported_Hash_Sha3_Descriptor_Provided_supported_hash_sha3_descriptor = P.Nothing,
  no_Supported_Hash_Sha3_Descriptor_Provided_explanation = P.Nothing}
data Descriptor_Does_Not_Match_Hash_Sha3 = Descriptor_Does_Not_Match_Hash_Sha3  { descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor :: (Set.HashSet I.Int8)
  , descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 :: LBS.ByteString
  , descriptor_Does_Not_Match_Hash_Sha3_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Descriptor_Does_Not_Match_Hash_Sha3
instance H.Hashable Descriptor_Does_Not_Match_Hash_Sha3 where
  hashWithSalt salt record = salt   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor record   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 record   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_Sha3_explanation record  
instance QC.Arbitrary Descriptor_Does_Not_Match_Hash_Sha3 where 
  arbitrary = M.liftM Descriptor_Does_Not_Match_Hash_Sha3 (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Descriptor_Does_Not_Match_Hash_Sha3 = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Descriptor_Does_Not_Match_Hash_Sha3{descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor = descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash_Sha3{descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor = descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor obj}
    , if obj == default_Descriptor_Does_Not_Match_Hash_Sha3{descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 = descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash_Sha3{descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 = descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 obj}
    , if obj == default_Descriptor_Does_Not_Match_Hash_Sha3{descriptor_Does_Not_Match_Hash_Sha3_explanation = descriptor_Does_Not_Match_Hash_Sha3_explanation obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash_Sha3{descriptor_Does_Not_Match_Hash_Sha3_explanation = descriptor_Does_Not_Match_Hash_Sha3_explanation obj}
    ]
from_Descriptor_Does_Not_Match_Hash_Sha3 :: Descriptor_Does_Not_Match_Hash_Sha3 -> T.ThriftVal
from_Descriptor_Does_Not_Match_Hash_Sha3 record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v46 -> P.Just (1, ("hash_sha3_descriptor",T.TSet T.T_BYTE $ P.map (\_v48 -> T.TByte _v48) $ Set.toList _v46))) $ descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor record
  , (\_v46 -> P.Just (2, ("hash_sha3",T.TBinary _v46))) $ descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 record
  , (\_v46 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v46))) <$> descriptor_Does_Not_Match_Hash_Sha3_explanation record
  ]
write_Descriptor_Does_Not_Match_Hash_Sha3 :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Hash_Sha3 -> P.IO ()
write_Descriptor_Does_Not_Match_Hash_Sha3 oprot record = T.writeVal oprot $ from_Descriptor_Does_Not_Match_Hash_Sha3 record
encode_Descriptor_Does_Not_Match_Hash_Sha3 :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Hash_Sha3 -> LBS.ByteString
encode_Descriptor_Does_Not_Match_Hash_Sha3 oprot record = T.serializeVal oprot $ from_Descriptor_Does_Not_Match_Hash_Sha3 record
to_Descriptor_Does_Not_Match_Hash_Sha3 :: T.ThriftVal -> Descriptor_Does_Not_Match_Hash_Sha3
to_Descriptor_Does_Not_Match_Hash_Sha3 (T.TStruct fields) = Descriptor_Does_Not_Match_Hash_Sha3{
  descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor = P.maybe (descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor default_Descriptor_Does_Not_Match_Hash_Sha3) (\(_,_val50) -> (case _val50 of {T.TSet _ _val51 -> (Set.fromList $ P.map (\_v52 -> (case _v52 of {T.TByte _val53 -> _val53; _ -> P.error "wrong type"})) _val51); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 = P.maybe (descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 default_Descriptor_Does_Not_Match_Hash_Sha3) (\(_,_val50) -> (case _val50 of {T.TBinary _val54 -> _val54; T.TString _val54 -> _val54; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  descriptor_Does_Not_Match_Hash_Sha3_explanation = P.maybe (P.Nothing) (\(_,_val50) -> P.Just (case _val50 of {T.TString _val55 -> E.decodeUtf8 _val55; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Descriptor_Does_Not_Match_Hash_Sha3 _ = P.error "not a struct"
read_Descriptor_Does_Not_Match_Hash_Sha3 :: (T.Transport t, T.Protocol p) => p t -> P.IO Descriptor_Does_Not_Match_Hash_Sha3
read_Descriptor_Does_Not_Match_Hash_Sha3 iprot = to_Descriptor_Does_Not_Match_Hash_Sha3 <$> T.readVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha3)
decode_Descriptor_Does_Not_Match_Hash_Sha3 :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Descriptor_Does_Not_Match_Hash_Sha3
decode_Descriptor_Does_Not_Match_Hash_Sha3 iprot bs = to_Descriptor_Does_Not_Match_Hash_Sha3 $ T.deserializeVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha3) bs
typemap_Descriptor_Does_Not_Match_Hash_Sha3 :: T.TypeMap
typemap_Descriptor_Does_Not_Match_Hash_Sha3 = Map.fromList [(1,("hash_sha3_descriptor",(T.T_SET T.T_BYTE))),(2,("hash_sha3",T.T_BINARY)),(3,("explanation",T.T_STRING))]
default_Descriptor_Does_Not_Match_Hash_Sha3 :: Descriptor_Does_Not_Match_Hash_Sha3
default_Descriptor_Does_Not_Match_Hash_Sha3 = Descriptor_Does_Not_Match_Hash_Sha3{
  descriptor_Does_Not_Match_Hash_Sha3_hash_sha3_descriptor = Set.empty,
  descriptor_Does_Not_Match_Hash_Sha3_hash_sha3 = "",
  descriptor_Does_Not_Match_Hash_Sha3_explanation = P.Nothing}
data Hash_Type_Descriptor = Hash_Type_Descriptor  { hash_Type_Descriptor_sha2 :: P.Maybe (Set.HashSet I.Int8)
  , hash_Type_Descriptor_sha3 :: P.Maybe (Set.HashSet I.Int8)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Hash_Type_Descriptor where
  hashWithSalt salt record = salt   `H.hashWithSalt` hash_Type_Descriptor_sha2 record   `H.hashWithSalt` hash_Type_Descriptor_sha3 record  
instance QC.Arbitrary Hash_Type_Descriptor where 
  arbitrary = M.liftM Hash_Type_Descriptor (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Hash_Type_Descriptor = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Hash_Type_Descriptor{hash_Type_Descriptor_sha2 = hash_Type_Descriptor_sha2 obj} then P.Nothing else P.Just $ default_Hash_Type_Descriptor{hash_Type_Descriptor_sha2 = hash_Type_Descriptor_sha2 obj}
    , if obj == default_Hash_Type_Descriptor{hash_Type_Descriptor_sha3 = hash_Type_Descriptor_sha3 obj} then P.Nothing else P.Just $ default_Hash_Type_Descriptor{hash_Type_Descriptor_sha3 = hash_Type_Descriptor_sha3 obj}
    ]
from_Hash_Type_Descriptor :: Hash_Type_Descriptor -> T.ThriftVal
from_Hash_Type_Descriptor record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v58 -> (2, ("sha2",T.TSet T.T_BYTE $ P.map (\_v60 -> T.TByte _v60) $ Set.toList _v58))) <$> hash_Type_Descriptor_sha2 record
  , (\_v58 -> (3, ("sha3",T.TSet T.T_BYTE $ P.map (\_v62 -> T.TByte _v62) $ Set.toList _v58))) <$> hash_Type_Descriptor_sha3 record
  ]
write_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Hash_Type_Descriptor -> P.IO ()
write_Hash_Type_Descriptor oprot record = T.writeVal oprot $ from_Hash_Type_Descriptor record
encode_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Hash_Type_Descriptor -> LBS.ByteString
encode_Hash_Type_Descriptor oprot record = T.serializeVal oprot $ from_Hash_Type_Descriptor record
to_Hash_Type_Descriptor :: T.ThriftVal -> Hash_Type_Descriptor
to_Hash_Type_Descriptor (T.TStruct fields) = Hash_Type_Descriptor{
  hash_Type_Descriptor_sha2 = P.maybe (P.Nothing) (\(_,_val64) -> P.Just (case _val64 of {T.TSet _ _val65 -> (Set.fromList $ P.map (\_v66 -> (case _v66 of {T.TByte _val67 -> _val67; _ -> P.error "wrong type"})) _val65); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  hash_Type_Descriptor_sha3 = P.maybe (P.Nothing) (\(_,_val64) -> P.Just (case _val64 of {T.TSet _ _val68 -> (Set.fromList $ P.map (\_v69 -> (case _v69 of {T.TByte _val70 -> _val70; _ -> P.error "wrong type"})) _val68); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Hash_Type_Descriptor _ = P.error "not a struct"
read_Hash_Type_Descriptor :: (T.Transport t, T.Protocol p) => p t -> P.IO Hash_Type_Descriptor
read_Hash_Type_Descriptor iprot = to_Hash_Type_Descriptor <$> T.readVal iprot (T.T_STRUCT typemap_Hash_Type_Descriptor)
decode_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Hash_Type_Descriptor
decode_Hash_Type_Descriptor iprot bs = to_Hash_Type_Descriptor $ T.deserializeVal iprot (T.T_STRUCT typemap_Hash_Type_Descriptor) bs
typemap_Hash_Type_Descriptor :: T.TypeMap
typemap_Hash_Type_Descriptor = Map.fromList [(2,("sha2",(T.T_SET T.T_BYTE))),(3,("sha3",(T.T_SET T.T_BYTE)))]
default_Hash_Type_Descriptor :: Hash_Type_Descriptor
default_Hash_Type_Descriptor = Hash_Type_Descriptor{
  hash_Type_Descriptor_sha2 = P.Nothing,
  hash_Type_Descriptor_sha3 = P.Nothing}
data No_Supported_Hash_Type_Descriptor_Provided = No_Supported_Hash_Type_Descriptor_Provided  { no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor :: P.Maybe Hash_Type_Descriptor
  , no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor :: P.Maybe Hash_Type_Descriptor
  , no_Supported_Hash_Type_Descriptor_Provided_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception No_Supported_Hash_Type_Descriptor_Provided
instance H.Hashable No_Supported_Hash_Type_Descriptor_Provided where
  hashWithSalt salt record = salt   `H.hashWithSalt` no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor record   `H.hashWithSalt` no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor record   `H.hashWithSalt` no_Supported_Hash_Type_Descriptor_Provided_explanation record  
instance QC.Arbitrary No_Supported_Hash_Type_Descriptor_Provided where 
  arbitrary = M.liftM No_Supported_Hash_Type_Descriptor_Provided (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_No_Supported_Hash_Type_Descriptor_Provided = []
             | P.otherwise = M.catMaybes
    [ if obj == default_No_Supported_Hash_Type_Descriptor_Provided{no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor = no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Type_Descriptor_Provided{no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor = no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor obj}
    , if obj == default_No_Supported_Hash_Type_Descriptor_Provided{no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor = no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Type_Descriptor_Provided{no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor = no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor obj}
    , if obj == default_No_Supported_Hash_Type_Descriptor_Provided{no_Supported_Hash_Type_Descriptor_Provided_explanation = no_Supported_Hash_Type_Descriptor_Provided_explanation obj} then P.Nothing else P.Just $ default_No_Supported_Hash_Type_Descriptor_Provided{no_Supported_Hash_Type_Descriptor_Provided_explanation = no_Supported_Hash_Type_Descriptor_Provided_explanation obj}
    ]
from_No_Supported_Hash_Type_Descriptor_Provided :: No_Supported_Hash_Type_Descriptor_Provided -> T.ThriftVal
from_No_Supported_Hash_Type_Descriptor_Provided record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v73 -> (1, ("offending_hash_type_descriptor",from_Hash_Type_Descriptor _v73))) <$> no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor record
  , (\_v73 -> (2, ("supported_hash_type_descriptor",from_Hash_Type_Descriptor _v73))) <$> no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor record
  , (\_v73 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v73))) <$> no_Supported_Hash_Type_Descriptor_Provided_explanation record
  ]
write_No_Supported_Hash_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Hash_Type_Descriptor_Provided -> P.IO ()
write_No_Supported_Hash_Type_Descriptor_Provided oprot record = T.writeVal oprot $ from_No_Supported_Hash_Type_Descriptor_Provided record
encode_No_Supported_Hash_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Hash_Type_Descriptor_Provided -> LBS.ByteString
encode_No_Supported_Hash_Type_Descriptor_Provided oprot record = T.serializeVal oprot $ from_No_Supported_Hash_Type_Descriptor_Provided record
to_No_Supported_Hash_Type_Descriptor_Provided :: T.ThriftVal -> No_Supported_Hash_Type_Descriptor_Provided
to_No_Supported_Hash_Type_Descriptor_Provided (T.TStruct fields) = No_Supported_Hash_Type_Descriptor_Provided{
  no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor = P.maybe (P.Nothing) (\(_,_val75) -> P.Just (case _val75 of {T.TStruct _val76 -> (to_Hash_Type_Descriptor (T.TStruct _val76)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor = P.maybe (P.Nothing) (\(_,_val75) -> P.Just (case _val75 of {T.TStruct _val77 -> (to_Hash_Type_Descriptor (T.TStruct _val77)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  no_Supported_Hash_Type_Descriptor_Provided_explanation = P.maybe (P.Nothing) (\(_,_val75) -> P.Just (case _val75 of {T.TString _val78 -> E.decodeUtf8 _val78; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_No_Supported_Hash_Type_Descriptor_Provided _ = P.error "not a struct"
read_No_Supported_Hash_Type_Descriptor_Provided :: (T.Transport t, T.Protocol p) => p t -> P.IO No_Supported_Hash_Type_Descriptor_Provided
read_No_Supported_Hash_Type_Descriptor_Provided iprot = to_No_Supported_Hash_Type_Descriptor_Provided <$> T.readVal iprot (T.T_STRUCT typemap_No_Supported_Hash_Type_Descriptor_Provided)
decode_No_Supported_Hash_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> No_Supported_Hash_Type_Descriptor_Provided
decode_No_Supported_Hash_Type_Descriptor_Provided iprot bs = to_No_Supported_Hash_Type_Descriptor_Provided $ T.deserializeVal iprot (T.T_STRUCT typemap_No_Supported_Hash_Type_Descriptor_Provided) bs
typemap_No_Supported_Hash_Type_Descriptor_Provided :: T.TypeMap
typemap_No_Supported_Hash_Type_Descriptor_Provided = Map.fromList [(1,("offending_hash_type_descriptor",(T.T_STRUCT typemap_Hash_Type_Descriptor))),(2,("supported_hash_type_descriptor",(T.T_STRUCT typemap_Hash_Type_Descriptor))),(3,("explanation",T.T_STRING))]
default_No_Supported_Hash_Type_Descriptor_Provided :: No_Supported_Hash_Type_Descriptor_Provided
default_No_Supported_Hash_Type_Descriptor_Provided = No_Supported_Hash_Type_Descriptor_Provided{
  no_Supported_Hash_Type_Descriptor_Provided_offending_hash_type_descriptor = P.Nothing,
  no_Supported_Hash_Type_Descriptor_Provided_supported_hash_type_descriptor = P.Nothing,
  no_Supported_Hash_Type_Descriptor_Provided_explanation = P.Nothing}
data Hash = Hash  { hash_sha2 :: P.Maybe LBS.ByteString
  , hash_sha3 :: P.Maybe LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Hash where
  hashWithSalt salt record = salt   `H.hashWithSalt` hash_sha2 record   `H.hashWithSalt` hash_sha3 record  
instance QC.Arbitrary Hash where 
  arbitrary = M.liftM Hash (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Hash = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Hash{hash_sha2 = hash_sha2 obj} then P.Nothing else P.Just $ default_Hash{hash_sha2 = hash_sha2 obj}
    , if obj == default_Hash{hash_sha3 = hash_sha3 obj} then P.Nothing else P.Just $ default_Hash{hash_sha3 = hash_sha3 obj}
    ]
from_Hash :: Hash -> T.ThriftVal
from_Hash record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v81 -> (2, ("sha2",T.TBinary _v81))) <$> hash_sha2 record
  , (\_v81 -> (3, ("sha3",T.TBinary _v81))) <$> hash_sha3 record
  ]
write_Hash :: (T.Protocol p, T.Transport t) => p t -> Hash -> P.IO ()
write_Hash oprot record = T.writeVal oprot $ from_Hash record
encode_Hash :: (T.Protocol p, T.Transport t) => p t -> Hash -> LBS.ByteString
encode_Hash oprot record = T.serializeVal oprot $ from_Hash record
to_Hash :: T.ThriftVal -> Hash
to_Hash (T.TStruct fields) = Hash{
  hash_sha2 = P.maybe (P.Nothing) (\(_,_val83) -> P.Just (case _val83 of {T.TBinary _val84 -> _val84; T.TString _val84 -> _val84; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  hash_sha3 = P.maybe (P.Nothing) (\(_,_val83) -> P.Just (case _val83 of {T.TBinary _val85 -> _val85; T.TString _val85 -> _val85; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Hash _ = P.error "not a struct"
read_Hash :: (T.Transport t, T.Protocol p) => p t -> P.IO Hash
read_Hash iprot = to_Hash <$> T.readVal iprot (T.T_STRUCT typemap_Hash)
decode_Hash :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Hash
decode_Hash iprot bs = to_Hash $ T.deserializeVal iprot (T.T_STRUCT typemap_Hash) bs
typemap_Hash :: T.TypeMap
typemap_Hash = Map.fromList [(2,("sha2",T.T_BINARY)),(3,("sha3",T.T_BINARY))]
default_Hash :: Hash
default_Hash = Hash{
  hash_sha2 = P.Nothing,
  hash_sha3 = P.Nothing}
data Descriptor_Does_Not_Match_Hash = Descriptor_Does_Not_Match_Hash  { descriptor_Does_Not_Match_Hash_hash_type_descriptor :: Hash_Type_Descriptor
  , descriptor_Does_Not_Match_Hash_hash :: Hash
  , descriptor_Does_Not_Match_Hash_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Descriptor_Does_Not_Match_Hash
instance H.Hashable Descriptor_Does_Not_Match_Hash where
  hashWithSalt salt record = salt   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_hash_type_descriptor record   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_hash record   `H.hashWithSalt` descriptor_Does_Not_Match_Hash_explanation record  
instance QC.Arbitrary Descriptor_Does_Not_Match_Hash where 
  arbitrary = M.liftM Descriptor_Does_Not_Match_Hash (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Descriptor_Does_Not_Match_Hash = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Descriptor_Does_Not_Match_Hash{descriptor_Does_Not_Match_Hash_hash_type_descriptor = descriptor_Does_Not_Match_Hash_hash_type_descriptor obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash{descriptor_Does_Not_Match_Hash_hash_type_descriptor = descriptor_Does_Not_Match_Hash_hash_type_descriptor obj}
    , if obj == default_Descriptor_Does_Not_Match_Hash{descriptor_Does_Not_Match_Hash_hash = descriptor_Does_Not_Match_Hash_hash obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash{descriptor_Does_Not_Match_Hash_hash = descriptor_Does_Not_Match_Hash_hash obj}
    , if obj == default_Descriptor_Does_Not_Match_Hash{descriptor_Does_Not_Match_Hash_explanation = descriptor_Does_Not_Match_Hash_explanation obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Hash{descriptor_Does_Not_Match_Hash_explanation = descriptor_Does_Not_Match_Hash_explanation obj}
    ]
from_Descriptor_Does_Not_Match_Hash :: Descriptor_Does_Not_Match_Hash -> T.ThriftVal
from_Descriptor_Does_Not_Match_Hash record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v88 -> P.Just (1, ("hash_type_descriptor",from_Hash_Type_Descriptor _v88))) $ descriptor_Does_Not_Match_Hash_hash_type_descriptor record
  , (\_v88 -> P.Just (2, ("hash",from_Hash _v88))) $ descriptor_Does_Not_Match_Hash_hash record
  , (\_v88 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v88))) <$> descriptor_Does_Not_Match_Hash_explanation record
  ]
write_Descriptor_Does_Not_Match_Hash :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Hash -> P.IO ()
write_Descriptor_Does_Not_Match_Hash oprot record = T.writeVal oprot $ from_Descriptor_Does_Not_Match_Hash record
encode_Descriptor_Does_Not_Match_Hash :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Hash -> LBS.ByteString
encode_Descriptor_Does_Not_Match_Hash oprot record = T.serializeVal oprot $ from_Descriptor_Does_Not_Match_Hash record
to_Descriptor_Does_Not_Match_Hash :: T.ThriftVal -> Descriptor_Does_Not_Match_Hash
to_Descriptor_Does_Not_Match_Hash (T.TStruct fields) = Descriptor_Does_Not_Match_Hash{
  descriptor_Does_Not_Match_Hash_hash_type_descriptor = P.maybe (descriptor_Does_Not_Match_Hash_hash_type_descriptor default_Descriptor_Does_Not_Match_Hash) (\(_,_val90) -> (case _val90 of {T.TStruct _val91 -> (to_Hash_Type_Descriptor (T.TStruct _val91)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  descriptor_Does_Not_Match_Hash_hash = P.maybe (descriptor_Does_Not_Match_Hash_hash default_Descriptor_Does_Not_Match_Hash) (\(_,_val90) -> (case _val90 of {T.TStruct _val92 -> (to_Hash (T.TStruct _val92)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  descriptor_Does_Not_Match_Hash_explanation = P.maybe (P.Nothing) (\(_,_val90) -> P.Just (case _val90 of {T.TString _val93 -> E.decodeUtf8 _val93; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Descriptor_Does_Not_Match_Hash _ = P.error "not a struct"
read_Descriptor_Does_Not_Match_Hash :: (T.Transport t, T.Protocol p) => p t -> P.IO Descriptor_Does_Not_Match_Hash
read_Descriptor_Does_Not_Match_Hash iprot = to_Descriptor_Does_Not_Match_Hash <$> T.readVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash)
decode_Descriptor_Does_Not_Match_Hash :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Descriptor_Does_Not_Match_Hash
decode_Descriptor_Does_Not_Match_Hash iprot bs = to_Descriptor_Does_Not_Match_Hash $ T.deserializeVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash) bs
typemap_Descriptor_Does_Not_Match_Hash :: T.TypeMap
typemap_Descriptor_Does_Not_Match_Hash = Map.fromList [(1,("hash_type_descriptor",(T.T_STRUCT typemap_Hash_Type_Descriptor))),(2,("hash",(T.T_STRUCT typemap_Hash))),(3,("explanation",T.T_STRING))]
default_Descriptor_Does_Not_Match_Hash :: Descriptor_Does_Not_Match_Hash
default_Descriptor_Does_Not_Match_Hash = Descriptor_Does_Not_Match_Hash{
  descriptor_Does_Not_Match_Hash_hash_type_descriptor = default_Hash_Type_Descriptor,
  descriptor_Does_Not_Match_Hash_hash = default_Hash,
  descriptor_Does_Not_Match_Hash_explanation = P.Nothing}
data Invalid_Public_Crypto_Key_X509 = Invalid_Public_Crypto_Key_X509  { invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 :: LBS.ByteString
  , invalid_Public_Crypto_Key_X509_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Public_Crypto_Key_X509
instance H.Hashable Invalid_Public_Crypto_Key_X509 where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 record   `H.hashWithSalt` invalid_Public_Crypto_Key_X509_explanation record  
instance QC.Arbitrary Invalid_Public_Crypto_Key_X509 where 
  arbitrary = M.liftM Invalid_Public_Crypto_Key_X509 (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Public_Crypto_Key_X509 = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Public_Crypto_Key_X509{invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 = invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 obj} then P.Nothing else P.Just $ default_Invalid_Public_Crypto_Key_X509{invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 = invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 obj}
    , if obj == default_Invalid_Public_Crypto_Key_X509{invalid_Public_Crypto_Key_X509_explanation = invalid_Public_Crypto_Key_X509_explanation obj} then P.Nothing else P.Just $ default_Invalid_Public_Crypto_Key_X509{invalid_Public_Crypto_Key_X509_explanation = invalid_Public_Crypto_Key_X509_explanation obj}
    ]
from_Invalid_Public_Crypto_Key_X509 :: Invalid_Public_Crypto_Key_X509 -> T.ThriftVal
from_Invalid_Public_Crypto_Key_X509 record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v96 -> P.Just (1, ("offending_public_crypto_key_x509",T.TBinary _v96))) $ invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 record
  , (\_v96 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v96))) <$> invalid_Public_Crypto_Key_X509_explanation record
  ]
write_Invalid_Public_Crypto_Key_X509 :: (T.Protocol p, T.Transport t) => p t -> Invalid_Public_Crypto_Key_X509 -> P.IO ()
write_Invalid_Public_Crypto_Key_X509 oprot record = T.writeVal oprot $ from_Invalid_Public_Crypto_Key_X509 record
encode_Invalid_Public_Crypto_Key_X509 :: (T.Protocol p, T.Transport t) => p t -> Invalid_Public_Crypto_Key_X509 -> LBS.ByteString
encode_Invalid_Public_Crypto_Key_X509 oprot record = T.serializeVal oprot $ from_Invalid_Public_Crypto_Key_X509 record
to_Invalid_Public_Crypto_Key_X509 :: T.ThriftVal -> Invalid_Public_Crypto_Key_X509
to_Invalid_Public_Crypto_Key_X509 (T.TStruct fields) = Invalid_Public_Crypto_Key_X509{
  invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 = P.maybe (invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 default_Invalid_Public_Crypto_Key_X509) (\(_,_val98) -> (case _val98 of {T.TBinary _val99 -> _val99; T.TString _val99 -> _val99; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Public_Crypto_Key_X509_explanation = P.maybe (P.Nothing) (\(_,_val98) -> P.Just (case _val98 of {T.TString _val100 -> E.decodeUtf8 _val100; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Invalid_Public_Crypto_Key_X509 _ = P.error "not a struct"
read_Invalid_Public_Crypto_Key_X509 :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Public_Crypto_Key_X509
read_Invalid_Public_Crypto_Key_X509 iprot = to_Invalid_Public_Crypto_Key_X509 <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Public_Crypto_Key_X509)
decode_Invalid_Public_Crypto_Key_X509 :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Public_Crypto_Key_X509
decode_Invalid_Public_Crypto_Key_X509 iprot bs = to_Invalid_Public_Crypto_Key_X509 $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Public_Crypto_Key_X509) bs
typemap_Invalid_Public_Crypto_Key_X509 :: T.TypeMap
typemap_Invalid_Public_Crypto_Key_X509 = Map.fromList [(1,("offending_public_crypto_key_x509",T.T_BINARY)),(3,("explanation",T.T_STRING))]
default_Invalid_Public_Crypto_Key_X509 :: Invalid_Public_Crypto_Key_X509
default_Invalid_Public_Crypto_Key_X509 = Invalid_Public_Crypto_Key_X509{
  invalid_Public_Crypto_Key_X509_offending_public_crypto_key_x509 = "",
  invalid_Public_Crypto_Key_X509_explanation = P.Nothing}
data Invalid_Public_Crypto_Key_PGP = Invalid_Public_Crypto_Key_PGP  { invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp :: LBS.ByteString
  , invalid_Public_Crypto_Key_PGP_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Public_Crypto_Key_PGP
instance H.Hashable Invalid_Public_Crypto_Key_PGP where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp record   `H.hashWithSalt` invalid_Public_Crypto_Key_PGP_explanation record  
instance QC.Arbitrary Invalid_Public_Crypto_Key_PGP where 
  arbitrary = M.liftM Invalid_Public_Crypto_Key_PGP (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Public_Crypto_Key_PGP = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Public_Crypto_Key_PGP{invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp = invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp obj} then P.Nothing else P.Just $ default_Invalid_Public_Crypto_Key_PGP{invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp = invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp obj}
    , if obj == default_Invalid_Public_Crypto_Key_PGP{invalid_Public_Crypto_Key_PGP_explanation = invalid_Public_Crypto_Key_PGP_explanation obj} then P.Nothing else P.Just $ default_Invalid_Public_Crypto_Key_PGP{invalid_Public_Crypto_Key_PGP_explanation = invalid_Public_Crypto_Key_PGP_explanation obj}
    ]
from_Invalid_Public_Crypto_Key_PGP :: Invalid_Public_Crypto_Key_PGP -> T.ThriftVal
from_Invalid_Public_Crypto_Key_PGP record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v103 -> P.Just (1, ("offending_public_crypto_key_pgp",T.TBinary _v103))) $ invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp record
  , (\_v103 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v103))) <$> invalid_Public_Crypto_Key_PGP_explanation record
  ]
write_Invalid_Public_Crypto_Key_PGP :: (T.Protocol p, T.Transport t) => p t -> Invalid_Public_Crypto_Key_PGP -> P.IO ()
write_Invalid_Public_Crypto_Key_PGP oprot record = T.writeVal oprot $ from_Invalid_Public_Crypto_Key_PGP record
encode_Invalid_Public_Crypto_Key_PGP :: (T.Protocol p, T.Transport t) => p t -> Invalid_Public_Crypto_Key_PGP -> LBS.ByteString
encode_Invalid_Public_Crypto_Key_PGP oprot record = T.serializeVal oprot $ from_Invalid_Public_Crypto_Key_PGP record
to_Invalid_Public_Crypto_Key_PGP :: T.ThriftVal -> Invalid_Public_Crypto_Key_PGP
to_Invalid_Public_Crypto_Key_PGP (T.TStruct fields) = Invalid_Public_Crypto_Key_PGP{
  invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp = P.maybe (invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp default_Invalid_Public_Crypto_Key_PGP) (\(_,_val105) -> (case _val105 of {T.TBinary _val106 -> _val106; T.TString _val106 -> _val106; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Public_Crypto_Key_PGP_explanation = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TString _val107 -> E.decodeUtf8 _val107; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Invalid_Public_Crypto_Key_PGP _ = P.error "not a struct"
read_Invalid_Public_Crypto_Key_PGP :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Public_Crypto_Key_PGP
read_Invalid_Public_Crypto_Key_PGP iprot = to_Invalid_Public_Crypto_Key_PGP <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Public_Crypto_Key_PGP)
decode_Invalid_Public_Crypto_Key_PGP :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Public_Crypto_Key_PGP
decode_Invalid_Public_Crypto_Key_PGP iprot bs = to_Invalid_Public_Crypto_Key_PGP $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Public_Crypto_Key_PGP) bs
typemap_Invalid_Public_Crypto_Key_PGP :: T.TypeMap
typemap_Invalid_Public_Crypto_Key_PGP = Map.fromList [(1,("offending_public_crypto_key_pgp",T.T_BINARY)),(3,("explanation",T.T_STRING))]
default_Invalid_Public_Crypto_Key_PGP :: Invalid_Public_Crypto_Key_PGP
default_Invalid_Public_Crypto_Key_PGP = Invalid_Public_Crypto_Key_PGP{
  invalid_Public_Crypto_Key_PGP_offending_public_crypto_key_pgp = "",
  invalid_Public_Crypto_Key_PGP_explanation = P.Nothing}
data Public_Crypto_Key_Type_Descriptor = Public_Crypto_Key_Type_Descriptor  { public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 :: P.Maybe P.Bool
  , public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Public_Crypto_Key_Type_Descriptor where
  hashWithSalt salt record = salt   `H.hashWithSalt` public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 record   `H.hashWithSalt` public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp record  
instance QC.Arbitrary Public_Crypto_Key_Type_Descriptor where 
  arbitrary = M.liftM Public_Crypto_Key_Type_Descriptor (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Public_Crypto_Key_Type_Descriptor = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Public_Crypto_Key_Type_Descriptor{public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 = public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 obj} then P.Nothing else P.Just $ default_Public_Crypto_Key_Type_Descriptor{public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 = public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 obj}
    , if obj == default_Public_Crypto_Key_Type_Descriptor{public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp = public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp obj} then P.Nothing else P.Just $ default_Public_Crypto_Key_Type_Descriptor{public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp = public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp obj}
    ]
from_Public_Crypto_Key_Type_Descriptor :: Public_Crypto_Key_Type_Descriptor -> T.ThriftVal
from_Public_Crypto_Key_Type_Descriptor record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v110 -> (1, ("public_crypto_key_x509",T.TBool _v110))) <$> public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 record
  , (\_v110 -> (2, ("public_crypto_key_pgp",T.TBool _v110))) <$> public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp record
  ]
write_Public_Crypto_Key_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Public_Crypto_Key_Type_Descriptor -> P.IO ()
write_Public_Crypto_Key_Type_Descriptor oprot record = T.writeVal oprot $ from_Public_Crypto_Key_Type_Descriptor record
encode_Public_Crypto_Key_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Public_Crypto_Key_Type_Descriptor -> LBS.ByteString
encode_Public_Crypto_Key_Type_Descriptor oprot record = T.serializeVal oprot $ from_Public_Crypto_Key_Type_Descriptor record
to_Public_Crypto_Key_Type_Descriptor :: T.ThriftVal -> Public_Crypto_Key_Type_Descriptor
to_Public_Crypto_Key_Type_Descriptor (T.TStruct fields) = Public_Crypto_Key_Type_Descriptor{
  public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 = P.maybe (P.Nothing) (\(_,_val112) -> P.Just (case _val112 of {T.TBool _val113 -> _val113; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp = P.maybe (P.Nothing) (\(_,_val112) -> P.Just (case _val112 of {T.TBool _val114 -> _val114; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Public_Crypto_Key_Type_Descriptor _ = P.error "not a struct"
read_Public_Crypto_Key_Type_Descriptor :: (T.Transport t, T.Protocol p) => p t -> P.IO Public_Crypto_Key_Type_Descriptor
read_Public_Crypto_Key_Type_Descriptor iprot = to_Public_Crypto_Key_Type_Descriptor <$> T.readVal iprot (T.T_STRUCT typemap_Public_Crypto_Key_Type_Descriptor)
decode_Public_Crypto_Key_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Public_Crypto_Key_Type_Descriptor
decode_Public_Crypto_Key_Type_Descriptor iprot bs = to_Public_Crypto_Key_Type_Descriptor $ T.deserializeVal iprot (T.T_STRUCT typemap_Public_Crypto_Key_Type_Descriptor) bs
typemap_Public_Crypto_Key_Type_Descriptor :: T.TypeMap
typemap_Public_Crypto_Key_Type_Descriptor = Map.fromList [(1,("public_crypto_key_x509",T.T_BOOL)),(2,("public_crypto_key_pgp",T.T_BOOL))]
default_Public_Crypto_Key_Type_Descriptor :: Public_Crypto_Key_Type_Descriptor
default_Public_Crypto_Key_Type_Descriptor = Public_Crypto_Key_Type_Descriptor{
  public_Crypto_Key_Type_Descriptor_public_crypto_key_x509 = P.Nothing,
  public_Crypto_Key_Type_Descriptor_public_crypto_key_pgp = P.Nothing}
data No_Supported_Public_Crypto_Key_Type_Descriptor_Provided = No_Supported_Public_Crypto_Key_Type_Descriptor_Provided  { no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor :: P.Maybe Public_Crypto_Key_Type_Descriptor
  , no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor :: P.Maybe Public_Crypto_Key_Type_Descriptor
  , no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception No_Supported_Public_Crypto_Key_Type_Descriptor_Provided
instance H.Hashable No_Supported_Public_Crypto_Key_Type_Descriptor_Provided where
  hashWithSalt salt record = salt   `H.hashWithSalt` no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor record   `H.hashWithSalt` no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor record   `H.hashWithSalt` no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation record  
instance QC.Arbitrary No_Supported_Public_Crypto_Key_Type_Descriptor_Provided where 
  arbitrary = M.liftM No_Supported_Public_Crypto_Key_Type_Descriptor_Provided (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided = []
             | P.otherwise = M.catMaybes
    [ if obj == default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided{no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor = no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided{no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor = no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor obj}
    , if obj == default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided{no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor = no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided{no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor = no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor obj}
    , if obj == default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided{no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation = no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation obj} then P.Nothing else P.Just $ default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided{no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation = no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation obj}
    ]
from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided :: No_Supported_Public_Crypto_Key_Type_Descriptor_Provided -> T.ThriftVal
from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v117 -> (1, ("offending_public_crypto_key_type_descriptor",from_Public_Crypto_Key_Type_Descriptor _v117))) <$> no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor record
  , (\_v117 -> (2, ("supported_public_crypto_key_type_descriptor",from_Public_Crypto_Key_Type_Descriptor _v117))) <$> no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor record
  , (\_v117 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v117))) <$> no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation record
  ]
write_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Public_Crypto_Key_Type_Descriptor_Provided -> P.IO ()
write_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided oprot record = T.writeVal oprot $ from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided record
encode_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Public_Crypto_Key_Type_Descriptor_Provided -> LBS.ByteString
encode_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided oprot record = T.serializeVal oprot $ from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided record
to_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided :: T.ThriftVal -> No_Supported_Public_Crypto_Key_Type_Descriptor_Provided
to_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided (T.TStruct fields) = No_Supported_Public_Crypto_Key_Type_Descriptor_Provided{
  no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor = P.maybe (P.Nothing) (\(_,_val119) -> P.Just (case _val119 of {T.TStruct _val120 -> (to_Public_Crypto_Key_Type_Descriptor (T.TStruct _val120)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor = P.maybe (P.Nothing) (\(_,_val119) -> P.Just (case _val119 of {T.TStruct _val121 -> (to_Public_Crypto_Key_Type_Descriptor (T.TStruct _val121)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation = P.maybe (P.Nothing) (\(_,_val119) -> P.Just (case _val119 of {T.TString _val122 -> E.decodeUtf8 _val122; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided _ = P.error "not a struct"
read_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided :: (T.Transport t, T.Protocol p) => p t -> P.IO No_Supported_Public_Crypto_Key_Type_Descriptor_Provided
read_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided iprot = to_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided <$> T.readVal iprot (T.T_STRUCT typemap_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided)
decode_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> No_Supported_Public_Crypto_Key_Type_Descriptor_Provided
decode_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided iprot bs = to_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided $ T.deserializeVal iprot (T.T_STRUCT typemap_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided) bs
typemap_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided :: T.TypeMap
typemap_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided = Map.fromList [(1,("offending_public_crypto_key_type_descriptor",(T.T_STRUCT typemap_Public_Crypto_Key_Type_Descriptor))),(2,("supported_public_crypto_key_type_descriptor",(T.T_STRUCT typemap_Public_Crypto_Key_Type_Descriptor))),(3,("explanation",T.T_STRING))]
default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided :: No_Supported_Public_Crypto_Key_Type_Descriptor_Provided
default_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided = No_Supported_Public_Crypto_Key_Type_Descriptor_Provided{
  no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_offending_public_crypto_key_type_descriptor = P.Nothing,
  no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_supported_public_crypto_key_type_descriptor = P.Nothing,
  no_Supported_Public_Crypto_Key_Type_Descriptor_Provided_explanation = P.Nothing}
data Public_Crypto_Key = Public_Crypto_Key  { public_Crypto_Key_public_crypto_key_x509 :: P.Maybe LBS.ByteString
  , public_Crypto_Key_public_crypto_key_pgp :: P.Maybe LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Public_Crypto_Key where
  hashWithSalt salt record = salt   `H.hashWithSalt` public_Crypto_Key_public_crypto_key_x509 record   `H.hashWithSalt` public_Crypto_Key_public_crypto_key_pgp record  
instance QC.Arbitrary Public_Crypto_Key where 
  arbitrary = M.liftM Public_Crypto_Key (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Public_Crypto_Key = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Public_Crypto_Key{public_Crypto_Key_public_crypto_key_x509 = public_Crypto_Key_public_crypto_key_x509 obj} then P.Nothing else P.Just $ default_Public_Crypto_Key{public_Crypto_Key_public_crypto_key_x509 = public_Crypto_Key_public_crypto_key_x509 obj}
    , if obj == default_Public_Crypto_Key{public_Crypto_Key_public_crypto_key_pgp = public_Crypto_Key_public_crypto_key_pgp obj} then P.Nothing else P.Just $ default_Public_Crypto_Key{public_Crypto_Key_public_crypto_key_pgp = public_Crypto_Key_public_crypto_key_pgp obj}
    ]
from_Public_Crypto_Key :: Public_Crypto_Key -> T.ThriftVal
from_Public_Crypto_Key record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v125 -> (1, ("public_crypto_key_x509",T.TBinary _v125))) <$> public_Crypto_Key_public_crypto_key_x509 record
  , (\_v125 -> (2, ("public_crypto_key_pgp",T.TBinary _v125))) <$> public_Crypto_Key_public_crypto_key_pgp record
  ]
write_Public_Crypto_Key :: (T.Protocol p, T.Transport t) => p t -> Public_Crypto_Key -> P.IO ()
write_Public_Crypto_Key oprot record = T.writeVal oprot $ from_Public_Crypto_Key record
encode_Public_Crypto_Key :: (T.Protocol p, T.Transport t) => p t -> Public_Crypto_Key -> LBS.ByteString
encode_Public_Crypto_Key oprot record = T.serializeVal oprot $ from_Public_Crypto_Key record
to_Public_Crypto_Key :: T.ThriftVal -> Public_Crypto_Key
to_Public_Crypto_Key (T.TStruct fields) = Public_Crypto_Key{
  public_Crypto_Key_public_crypto_key_x509 = P.maybe (P.Nothing) (\(_,_val127) -> P.Just (case _val127 of {T.TBinary _val128 -> _val128; T.TString _val128 -> _val128; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  public_Crypto_Key_public_crypto_key_pgp = P.maybe (P.Nothing) (\(_,_val127) -> P.Just (case _val127 of {T.TBinary _val129 -> _val129; T.TString _val129 -> _val129; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Public_Crypto_Key _ = P.error "not a struct"
read_Public_Crypto_Key :: (T.Transport t, T.Protocol p) => p t -> P.IO Public_Crypto_Key
read_Public_Crypto_Key iprot = to_Public_Crypto_Key <$> T.readVal iprot (T.T_STRUCT typemap_Public_Crypto_Key)
decode_Public_Crypto_Key :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Public_Crypto_Key
decode_Public_Crypto_Key iprot bs = to_Public_Crypto_Key $ T.deserializeVal iprot (T.T_STRUCT typemap_Public_Crypto_Key) bs
typemap_Public_Crypto_Key :: T.TypeMap
typemap_Public_Crypto_Key = Map.fromList [(1,("public_crypto_key_x509",T.T_BINARY)),(2,("public_crypto_key_pgp",T.T_BINARY))]
default_Public_Crypto_Key :: Public_Crypto_Key
default_Public_Crypto_Key = Public_Crypto_Key{
  public_Crypto_Key_public_crypto_key_x509 = P.Nothing,
  public_Crypto_Key_public_crypto_key_pgp = P.Nothing}
data Descriptor_Does_Not_Match_Public_Crypto_Key = Descriptor_Does_Not_Match_Public_Crypto_Key  { descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor :: Public_Crypto_Key_Type_Descriptor
  , descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key :: Public_Crypto_Key
  , descriptor_Does_Not_Match_Public_Crypto_Key_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Descriptor_Does_Not_Match_Public_Crypto_Key
instance H.Hashable Descriptor_Does_Not_Match_Public_Crypto_Key where
  hashWithSalt salt record = salt   `H.hashWithSalt` descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor record   `H.hashWithSalt` descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key record   `H.hashWithSalt` descriptor_Does_Not_Match_Public_Crypto_Key_explanation record  
instance QC.Arbitrary Descriptor_Does_Not_Match_Public_Crypto_Key where 
  arbitrary = M.liftM Descriptor_Does_Not_Match_Public_Crypto_Key (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Descriptor_Does_Not_Match_Public_Crypto_Key = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Descriptor_Does_Not_Match_Public_Crypto_Key{descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor = descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Public_Crypto_Key{descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor = descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor obj}
    , if obj == default_Descriptor_Does_Not_Match_Public_Crypto_Key{descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key = descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Public_Crypto_Key{descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key = descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key obj}
    , if obj == default_Descriptor_Does_Not_Match_Public_Crypto_Key{descriptor_Does_Not_Match_Public_Crypto_Key_explanation = descriptor_Does_Not_Match_Public_Crypto_Key_explanation obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Public_Crypto_Key{descriptor_Does_Not_Match_Public_Crypto_Key_explanation = descriptor_Does_Not_Match_Public_Crypto_Key_explanation obj}
    ]
from_Descriptor_Does_Not_Match_Public_Crypto_Key :: Descriptor_Does_Not_Match_Public_Crypto_Key -> T.ThriftVal
from_Descriptor_Does_Not_Match_Public_Crypto_Key record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v132 -> P.Just (1, ("public_crypto_key_type_descriptor",from_Public_Crypto_Key_Type_Descriptor _v132))) $ descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor record
  , (\_v132 -> P.Just (2, ("public_crypto_key",from_Public_Crypto_Key _v132))) $ descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key record
  , (\_v132 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v132))) <$> descriptor_Does_Not_Match_Public_Crypto_Key_explanation record
  ]
write_Descriptor_Does_Not_Match_Public_Crypto_Key :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Public_Crypto_Key -> P.IO ()
write_Descriptor_Does_Not_Match_Public_Crypto_Key oprot record = T.writeVal oprot $ from_Descriptor_Does_Not_Match_Public_Crypto_Key record
encode_Descriptor_Does_Not_Match_Public_Crypto_Key :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Public_Crypto_Key -> LBS.ByteString
encode_Descriptor_Does_Not_Match_Public_Crypto_Key oprot record = T.serializeVal oprot $ from_Descriptor_Does_Not_Match_Public_Crypto_Key record
to_Descriptor_Does_Not_Match_Public_Crypto_Key :: T.ThriftVal -> Descriptor_Does_Not_Match_Public_Crypto_Key
to_Descriptor_Does_Not_Match_Public_Crypto_Key (T.TStruct fields) = Descriptor_Does_Not_Match_Public_Crypto_Key{
  descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor = P.maybe (descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor default_Descriptor_Does_Not_Match_Public_Crypto_Key) (\(_,_val134) -> (case _val134 of {T.TStruct _val135 -> (to_Public_Crypto_Key_Type_Descriptor (T.TStruct _val135)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key = P.maybe (descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key default_Descriptor_Does_Not_Match_Public_Crypto_Key) (\(_,_val134) -> (case _val134 of {T.TStruct _val136 -> (to_Public_Crypto_Key (T.TStruct _val136)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  descriptor_Does_Not_Match_Public_Crypto_Key_explanation = P.maybe (P.Nothing) (\(_,_val134) -> P.Just (case _val134 of {T.TString _val137 -> E.decodeUtf8 _val137; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Descriptor_Does_Not_Match_Public_Crypto_Key _ = P.error "not a struct"
read_Descriptor_Does_Not_Match_Public_Crypto_Key :: (T.Transport t, T.Protocol p) => p t -> P.IO Descriptor_Does_Not_Match_Public_Crypto_Key
read_Descriptor_Does_Not_Match_Public_Crypto_Key iprot = to_Descriptor_Does_Not_Match_Public_Crypto_Key <$> T.readVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Public_Crypto_Key)
decode_Descriptor_Does_Not_Match_Public_Crypto_Key :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Descriptor_Does_Not_Match_Public_Crypto_Key
decode_Descriptor_Does_Not_Match_Public_Crypto_Key iprot bs = to_Descriptor_Does_Not_Match_Public_Crypto_Key $ T.deserializeVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Public_Crypto_Key) bs
typemap_Descriptor_Does_Not_Match_Public_Crypto_Key :: T.TypeMap
typemap_Descriptor_Does_Not_Match_Public_Crypto_Key = Map.fromList [(1,("public_crypto_key_type_descriptor",(T.T_STRUCT typemap_Public_Crypto_Key_Type_Descriptor))),(2,("public_crypto_key",(T.T_STRUCT typemap_Public_Crypto_Key))),(3,("explanation",T.T_STRING))]
default_Descriptor_Does_Not_Match_Public_Crypto_Key :: Descriptor_Does_Not_Match_Public_Crypto_Key
default_Descriptor_Does_Not_Match_Public_Crypto_Key = Descriptor_Does_Not_Match_Public_Crypto_Key{
  descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key_type_descriptor = default_Public_Crypto_Key_Type_Descriptor,
  descriptor_Does_Not_Match_Public_Crypto_Key_public_crypto_key = default_Public_Crypto_Key,
  descriptor_Does_Not_Match_Public_Crypto_Key_explanation = P.Nothing}
data Crypto_ID_Hash_Type_Descriptor = Crypto_ID_Hash_Type_Descriptor  { crypto_ID_Hash_Type_Descriptor_hash :: Hash_Type_Descriptor
  , crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor :: P.Maybe Public_Crypto_Key_Type_Descriptor
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Crypto_ID_Hash_Type_Descriptor where
  hashWithSalt salt record = salt   `H.hashWithSalt` crypto_ID_Hash_Type_Descriptor_hash record   `H.hashWithSalt` crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor record  
instance QC.Arbitrary Crypto_ID_Hash_Type_Descriptor where 
  arbitrary = M.liftM Crypto_ID_Hash_Type_Descriptor (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Crypto_ID_Hash_Type_Descriptor = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Crypto_ID_Hash_Type_Descriptor{crypto_ID_Hash_Type_Descriptor_hash = crypto_ID_Hash_Type_Descriptor_hash obj} then P.Nothing else P.Just $ default_Crypto_ID_Hash_Type_Descriptor{crypto_ID_Hash_Type_Descriptor_hash = crypto_ID_Hash_Type_Descriptor_hash obj}
    , if obj == default_Crypto_ID_Hash_Type_Descriptor{crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor = crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor obj} then P.Nothing else P.Just $ default_Crypto_ID_Hash_Type_Descriptor{crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor = crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor obj}
    ]
from_Crypto_ID_Hash_Type_Descriptor :: Crypto_ID_Hash_Type_Descriptor -> T.ThriftVal
from_Crypto_ID_Hash_Type_Descriptor record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v140 -> P.Just (1, ("hash",from_Hash_Type_Descriptor _v140))) $ crypto_ID_Hash_Type_Descriptor_hash record
  , (\_v140 -> (2, ("public_crypto_key_type_descriptor",from_Public_Crypto_Key_Type_Descriptor _v140))) <$> crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor record
  ]
write_Crypto_ID_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Crypto_ID_Hash_Type_Descriptor -> P.IO ()
write_Crypto_ID_Hash_Type_Descriptor oprot record = T.writeVal oprot $ from_Crypto_ID_Hash_Type_Descriptor record
encode_Crypto_ID_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Crypto_ID_Hash_Type_Descriptor -> LBS.ByteString
encode_Crypto_ID_Hash_Type_Descriptor oprot record = T.serializeVal oprot $ from_Crypto_ID_Hash_Type_Descriptor record
to_Crypto_ID_Hash_Type_Descriptor :: T.ThriftVal -> Crypto_ID_Hash_Type_Descriptor
to_Crypto_ID_Hash_Type_Descriptor (T.TStruct fields) = Crypto_ID_Hash_Type_Descriptor{
  crypto_ID_Hash_Type_Descriptor_hash = P.maybe (crypto_ID_Hash_Type_Descriptor_hash default_Crypto_ID_Hash_Type_Descriptor) (\(_,_val142) -> (case _val142 of {T.TStruct _val143 -> (to_Hash_Type_Descriptor (T.TStruct _val143)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor = P.maybe (P.Nothing) (\(_,_val142) -> P.Just (case _val142 of {T.TStruct _val144 -> (to_Public_Crypto_Key_Type_Descriptor (T.TStruct _val144)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Crypto_ID_Hash_Type_Descriptor _ = P.error "not a struct"
read_Crypto_ID_Hash_Type_Descriptor :: (T.Transport t, T.Protocol p) => p t -> P.IO Crypto_ID_Hash_Type_Descriptor
read_Crypto_ID_Hash_Type_Descriptor iprot = to_Crypto_ID_Hash_Type_Descriptor <$> T.readVal iprot (T.T_STRUCT typemap_Crypto_ID_Hash_Type_Descriptor)
decode_Crypto_ID_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Crypto_ID_Hash_Type_Descriptor
decode_Crypto_ID_Hash_Type_Descriptor iprot bs = to_Crypto_ID_Hash_Type_Descriptor $ T.deserializeVal iprot (T.T_STRUCT typemap_Crypto_ID_Hash_Type_Descriptor) bs
typemap_Crypto_ID_Hash_Type_Descriptor :: T.TypeMap
typemap_Crypto_ID_Hash_Type_Descriptor = Map.fromList [(1,("hash",(T.T_STRUCT typemap_Hash_Type_Descriptor))),(2,("public_crypto_key_type_descriptor",(T.T_STRUCT typemap_Public_Crypto_Key_Type_Descriptor)))]
default_Crypto_ID_Hash_Type_Descriptor :: Crypto_ID_Hash_Type_Descriptor
default_Crypto_ID_Hash_Type_Descriptor = Crypto_ID_Hash_Type_Descriptor{
  crypto_ID_Hash_Type_Descriptor_hash = default_Hash_Type_Descriptor,
  crypto_ID_Hash_Type_Descriptor_public_crypto_key_type_descriptor = P.Nothing}
data Crypto_ID_Hash = Crypto_ID_Hash  { crypto_ID_Hash_hash :: Hash
  , crypto_ID_Hash_public_crypto_key_type_descriptor :: P.Maybe Public_Crypto_Key_Type_Descriptor
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Crypto_ID_Hash where
  hashWithSalt salt record = salt   `H.hashWithSalt` crypto_ID_Hash_hash record   `H.hashWithSalt` crypto_ID_Hash_public_crypto_key_type_descriptor record  
instance QC.Arbitrary Crypto_ID_Hash where 
  arbitrary = M.liftM Crypto_ID_Hash (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Crypto_ID_Hash = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Crypto_ID_Hash{crypto_ID_Hash_hash = crypto_ID_Hash_hash obj} then P.Nothing else P.Just $ default_Crypto_ID_Hash{crypto_ID_Hash_hash = crypto_ID_Hash_hash obj}
    , if obj == default_Crypto_ID_Hash{crypto_ID_Hash_public_crypto_key_type_descriptor = crypto_ID_Hash_public_crypto_key_type_descriptor obj} then P.Nothing else P.Just $ default_Crypto_ID_Hash{crypto_ID_Hash_public_crypto_key_type_descriptor = crypto_ID_Hash_public_crypto_key_type_descriptor obj}
    ]
from_Crypto_ID_Hash :: Crypto_ID_Hash -> T.ThriftVal
from_Crypto_ID_Hash record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v147 -> P.Just (1, ("hash",from_Hash _v147))) $ crypto_ID_Hash_hash record
  , (\_v147 -> (2, ("public_crypto_key_type_descriptor",from_Public_Crypto_Key_Type_Descriptor _v147))) <$> crypto_ID_Hash_public_crypto_key_type_descriptor record
  ]
write_Crypto_ID_Hash :: (T.Protocol p, T.Transport t) => p t -> Crypto_ID_Hash -> P.IO ()
write_Crypto_ID_Hash oprot record = T.writeVal oprot $ from_Crypto_ID_Hash record
encode_Crypto_ID_Hash :: (T.Protocol p, T.Transport t) => p t -> Crypto_ID_Hash -> LBS.ByteString
encode_Crypto_ID_Hash oprot record = T.serializeVal oprot $ from_Crypto_ID_Hash record
to_Crypto_ID_Hash :: T.ThriftVal -> Crypto_ID_Hash
to_Crypto_ID_Hash (T.TStruct fields) = Crypto_ID_Hash{
  crypto_ID_Hash_hash = P.maybe (crypto_ID_Hash_hash default_Crypto_ID_Hash) (\(_,_val149) -> (case _val149 of {T.TStruct _val150 -> (to_Hash (T.TStruct _val150)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  crypto_ID_Hash_public_crypto_key_type_descriptor = P.maybe (P.Nothing) (\(_,_val149) -> P.Just (case _val149 of {T.TStruct _val151 -> (to_Public_Crypto_Key_Type_Descriptor (T.TStruct _val151)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Crypto_ID_Hash _ = P.error "not a struct"
read_Crypto_ID_Hash :: (T.Transport t, T.Protocol p) => p t -> P.IO Crypto_ID_Hash
read_Crypto_ID_Hash iprot = to_Crypto_ID_Hash <$> T.readVal iprot (T.T_STRUCT typemap_Crypto_ID_Hash)
decode_Crypto_ID_Hash :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Crypto_ID_Hash
decode_Crypto_ID_Hash iprot bs = to_Crypto_ID_Hash $ T.deserializeVal iprot (T.T_STRUCT typemap_Crypto_ID_Hash) bs
typemap_Crypto_ID_Hash :: T.TypeMap
typemap_Crypto_ID_Hash = Map.fromList [(1,("hash",(T.T_STRUCT typemap_Hash))),(2,("public_crypto_key_type_descriptor",(T.T_STRUCT typemap_Public_Crypto_Key_Type_Descriptor)))]
default_Crypto_ID_Hash :: Crypto_ID_Hash
default_Crypto_ID_Hash = Crypto_ID_Hash{
  crypto_ID_Hash_hash = default_Hash,
  crypto_ID_Hash_public_crypto_key_type_descriptor = P.Nothing}
data Descriptor_Does_Not_Match_Crypto_ID_Hash = Descriptor_Does_Not_Match_Crypto_ID_Hash  { descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor :: Crypto_ID_Hash_Type_Descriptor
  , descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash :: Crypto_ID_Hash
  , descriptor_Does_Not_Match_Crypto_ID_Hash_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Descriptor_Does_Not_Match_Crypto_ID_Hash
instance H.Hashable Descriptor_Does_Not_Match_Crypto_ID_Hash where
  hashWithSalt salt record = salt   `H.hashWithSalt` descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor record   `H.hashWithSalt` descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash record   `H.hashWithSalt` descriptor_Does_Not_Match_Crypto_ID_Hash_explanation record  
instance QC.Arbitrary Descriptor_Does_Not_Match_Crypto_ID_Hash where 
  arbitrary = M.liftM Descriptor_Does_Not_Match_Crypto_ID_Hash (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Descriptor_Does_Not_Match_Crypto_ID_Hash = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Descriptor_Does_Not_Match_Crypto_ID_Hash{descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor = descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Crypto_ID_Hash{descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor = descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor obj}
    , if obj == default_Descriptor_Does_Not_Match_Crypto_ID_Hash{descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash = descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Crypto_ID_Hash{descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash = descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash obj}
    , if obj == default_Descriptor_Does_Not_Match_Crypto_ID_Hash{descriptor_Does_Not_Match_Crypto_ID_Hash_explanation = descriptor_Does_Not_Match_Crypto_ID_Hash_explanation obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Crypto_ID_Hash{descriptor_Does_Not_Match_Crypto_ID_Hash_explanation = descriptor_Does_Not_Match_Crypto_ID_Hash_explanation obj}
    ]
from_Descriptor_Does_Not_Match_Crypto_ID_Hash :: Descriptor_Does_Not_Match_Crypto_ID_Hash -> T.ThriftVal
from_Descriptor_Does_Not_Match_Crypto_ID_Hash record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v154 -> P.Just (1, ("crypto_id_hash_type_descriptor",from_Crypto_ID_Hash_Type_Descriptor _v154))) $ descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor record
  , (\_v154 -> P.Just (2, ("crypto_id_hash",from_Crypto_ID_Hash _v154))) $ descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash record
  , (\_v154 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v154))) <$> descriptor_Does_Not_Match_Crypto_ID_Hash_explanation record
  ]
write_Descriptor_Does_Not_Match_Crypto_ID_Hash :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Crypto_ID_Hash -> P.IO ()
write_Descriptor_Does_Not_Match_Crypto_ID_Hash oprot record = T.writeVal oprot $ from_Descriptor_Does_Not_Match_Crypto_ID_Hash record
encode_Descriptor_Does_Not_Match_Crypto_ID_Hash :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Crypto_ID_Hash -> LBS.ByteString
encode_Descriptor_Does_Not_Match_Crypto_ID_Hash oprot record = T.serializeVal oprot $ from_Descriptor_Does_Not_Match_Crypto_ID_Hash record
to_Descriptor_Does_Not_Match_Crypto_ID_Hash :: T.ThriftVal -> Descriptor_Does_Not_Match_Crypto_ID_Hash
to_Descriptor_Does_Not_Match_Crypto_ID_Hash (T.TStruct fields) = Descriptor_Does_Not_Match_Crypto_ID_Hash{
  descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor = P.maybe (descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor default_Descriptor_Does_Not_Match_Crypto_ID_Hash) (\(_,_val156) -> (case _val156 of {T.TStruct _val157 -> (to_Crypto_ID_Hash_Type_Descriptor (T.TStruct _val157)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash = P.maybe (descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash default_Descriptor_Does_Not_Match_Crypto_ID_Hash) (\(_,_val156) -> (case _val156 of {T.TStruct _val158 -> (to_Crypto_ID_Hash (T.TStruct _val158)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  descriptor_Does_Not_Match_Crypto_ID_Hash_explanation = P.maybe (P.Nothing) (\(_,_val156) -> P.Just (case _val156 of {T.TString _val159 -> E.decodeUtf8 _val159; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Descriptor_Does_Not_Match_Crypto_ID_Hash _ = P.error "not a struct"
read_Descriptor_Does_Not_Match_Crypto_ID_Hash :: (T.Transport t, T.Protocol p) => p t -> P.IO Descriptor_Does_Not_Match_Crypto_ID_Hash
read_Descriptor_Does_Not_Match_Crypto_ID_Hash iprot = to_Descriptor_Does_Not_Match_Crypto_ID_Hash <$> T.readVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID_Hash)
decode_Descriptor_Does_Not_Match_Crypto_ID_Hash :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Descriptor_Does_Not_Match_Crypto_ID_Hash
decode_Descriptor_Does_Not_Match_Crypto_ID_Hash iprot bs = to_Descriptor_Does_Not_Match_Crypto_ID_Hash $ T.deserializeVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID_Hash) bs
typemap_Descriptor_Does_Not_Match_Crypto_ID_Hash :: T.TypeMap
typemap_Descriptor_Does_Not_Match_Crypto_ID_Hash = Map.fromList [(1,("crypto_id_hash_type_descriptor",(T.T_STRUCT typemap_Crypto_ID_Hash_Type_Descriptor))),(2,("crypto_id_hash",(T.T_STRUCT typemap_Crypto_ID_Hash))),(3,("explanation",T.T_STRING))]
default_Descriptor_Does_Not_Match_Crypto_ID_Hash :: Descriptor_Does_Not_Match_Crypto_ID_Hash
default_Descriptor_Does_Not_Match_Crypto_ID_Hash = Descriptor_Does_Not_Match_Crypto_ID_Hash{
  descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash_type_descriptor = default_Crypto_ID_Hash_Type_Descriptor,
  descriptor_Does_Not_Match_Crypto_ID_Hash_crypto_id_hash = default_Crypto_ID_Hash,
  descriptor_Does_Not_Match_Crypto_ID_Hash_explanation = P.Nothing}
data Crypto_ID_Type_Descriptor = Crypto_ID_Type_Descriptor  { crypto_ID_Type_Descriptor_public_crypto_key :: P.Maybe Public_Crypto_Key_Type_Descriptor
  , crypto_ID_Type_Descriptor_crypto_id_hash :: P.Maybe Crypto_ID_Hash_Type_Descriptor
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Crypto_ID_Type_Descriptor where
  hashWithSalt salt record = salt   `H.hashWithSalt` crypto_ID_Type_Descriptor_public_crypto_key record   `H.hashWithSalt` crypto_ID_Type_Descriptor_crypto_id_hash record  
instance QC.Arbitrary Crypto_ID_Type_Descriptor where 
  arbitrary = M.liftM Crypto_ID_Type_Descriptor (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Crypto_ID_Type_Descriptor = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Crypto_ID_Type_Descriptor{crypto_ID_Type_Descriptor_public_crypto_key = crypto_ID_Type_Descriptor_public_crypto_key obj} then P.Nothing else P.Just $ default_Crypto_ID_Type_Descriptor{crypto_ID_Type_Descriptor_public_crypto_key = crypto_ID_Type_Descriptor_public_crypto_key obj}
    , if obj == default_Crypto_ID_Type_Descriptor{crypto_ID_Type_Descriptor_crypto_id_hash = crypto_ID_Type_Descriptor_crypto_id_hash obj} then P.Nothing else P.Just $ default_Crypto_ID_Type_Descriptor{crypto_ID_Type_Descriptor_crypto_id_hash = crypto_ID_Type_Descriptor_crypto_id_hash obj}
    ]
from_Crypto_ID_Type_Descriptor :: Crypto_ID_Type_Descriptor -> T.ThriftVal
from_Crypto_ID_Type_Descriptor record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v162 -> (1, ("public_crypto_key",from_Public_Crypto_Key_Type_Descriptor _v162))) <$> crypto_ID_Type_Descriptor_public_crypto_key record
  , (\_v162 -> (2, ("crypto_id_hash",from_Crypto_ID_Hash_Type_Descriptor _v162))) <$> crypto_ID_Type_Descriptor_crypto_id_hash record
  ]
write_Crypto_ID_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Crypto_ID_Type_Descriptor -> P.IO ()
write_Crypto_ID_Type_Descriptor oprot record = T.writeVal oprot $ from_Crypto_ID_Type_Descriptor record
encode_Crypto_ID_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Crypto_ID_Type_Descriptor -> LBS.ByteString
encode_Crypto_ID_Type_Descriptor oprot record = T.serializeVal oprot $ from_Crypto_ID_Type_Descriptor record
to_Crypto_ID_Type_Descriptor :: T.ThriftVal -> Crypto_ID_Type_Descriptor
to_Crypto_ID_Type_Descriptor (T.TStruct fields) = Crypto_ID_Type_Descriptor{
  crypto_ID_Type_Descriptor_public_crypto_key = P.maybe (P.Nothing) (\(_,_val164) -> P.Just (case _val164 of {T.TStruct _val165 -> (to_Public_Crypto_Key_Type_Descriptor (T.TStruct _val165)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  crypto_ID_Type_Descriptor_crypto_id_hash = P.maybe (P.Nothing) (\(_,_val164) -> P.Just (case _val164 of {T.TStruct _val166 -> (to_Crypto_ID_Hash_Type_Descriptor (T.TStruct _val166)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Crypto_ID_Type_Descriptor _ = P.error "not a struct"
read_Crypto_ID_Type_Descriptor :: (T.Transport t, T.Protocol p) => p t -> P.IO Crypto_ID_Type_Descriptor
read_Crypto_ID_Type_Descriptor iprot = to_Crypto_ID_Type_Descriptor <$> T.readVal iprot (T.T_STRUCT typemap_Crypto_ID_Type_Descriptor)
decode_Crypto_ID_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Crypto_ID_Type_Descriptor
decode_Crypto_ID_Type_Descriptor iprot bs = to_Crypto_ID_Type_Descriptor $ T.deserializeVal iprot (T.T_STRUCT typemap_Crypto_ID_Type_Descriptor) bs
typemap_Crypto_ID_Type_Descriptor :: T.TypeMap
typemap_Crypto_ID_Type_Descriptor = Map.fromList [(1,("public_crypto_key",(T.T_STRUCT typemap_Public_Crypto_Key_Type_Descriptor))),(2,("crypto_id_hash",(T.T_STRUCT typemap_Crypto_ID_Hash_Type_Descriptor)))]
default_Crypto_ID_Type_Descriptor :: Crypto_ID_Type_Descriptor
default_Crypto_ID_Type_Descriptor = Crypto_ID_Type_Descriptor{
  crypto_ID_Type_Descriptor_public_crypto_key = P.Nothing,
  crypto_ID_Type_Descriptor_crypto_id_hash = P.Nothing}
data No_Supported_Crypto_ID_Type_Descriptor_Provided = No_Supported_Crypto_ID_Type_Descriptor_Provided  { no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor :: P.Maybe Crypto_ID_Type_Descriptor
  , no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor :: P.Maybe Crypto_ID_Type_Descriptor
  , no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception No_Supported_Crypto_ID_Type_Descriptor_Provided
instance H.Hashable No_Supported_Crypto_ID_Type_Descriptor_Provided where
  hashWithSalt salt record = salt   `H.hashWithSalt` no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor record   `H.hashWithSalt` no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor record   `H.hashWithSalt` no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation record  
instance QC.Arbitrary No_Supported_Crypto_ID_Type_Descriptor_Provided where 
  arbitrary = M.liftM No_Supported_Crypto_ID_Type_Descriptor_Provided (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_No_Supported_Crypto_ID_Type_Descriptor_Provided = []
             | P.otherwise = M.catMaybes
    [ if obj == default_No_Supported_Crypto_ID_Type_Descriptor_Provided{no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor = no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Crypto_ID_Type_Descriptor_Provided{no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor = no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor obj}
    , if obj == default_No_Supported_Crypto_ID_Type_Descriptor_Provided{no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor = no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor obj} then P.Nothing else P.Just $ default_No_Supported_Crypto_ID_Type_Descriptor_Provided{no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor = no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor obj}
    , if obj == default_No_Supported_Crypto_ID_Type_Descriptor_Provided{no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation = no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation obj} then P.Nothing else P.Just $ default_No_Supported_Crypto_ID_Type_Descriptor_Provided{no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation = no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation obj}
    ]
from_No_Supported_Crypto_ID_Type_Descriptor_Provided :: No_Supported_Crypto_ID_Type_Descriptor_Provided -> T.ThriftVal
from_No_Supported_Crypto_ID_Type_Descriptor_Provided record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v169 -> (1, ("offending_crypto_id_type_descriptor",from_Crypto_ID_Type_Descriptor _v169))) <$> no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor record
  , (\_v169 -> (2, ("supported_crypto_id_type_descriptor",from_Crypto_ID_Type_Descriptor _v169))) <$> no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor record
  , (\_v169 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v169))) <$> no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation record
  ]
write_No_Supported_Crypto_ID_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Crypto_ID_Type_Descriptor_Provided -> P.IO ()
write_No_Supported_Crypto_ID_Type_Descriptor_Provided oprot record = T.writeVal oprot $ from_No_Supported_Crypto_ID_Type_Descriptor_Provided record
encode_No_Supported_Crypto_ID_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> No_Supported_Crypto_ID_Type_Descriptor_Provided -> LBS.ByteString
encode_No_Supported_Crypto_ID_Type_Descriptor_Provided oprot record = T.serializeVal oprot $ from_No_Supported_Crypto_ID_Type_Descriptor_Provided record
to_No_Supported_Crypto_ID_Type_Descriptor_Provided :: T.ThriftVal -> No_Supported_Crypto_ID_Type_Descriptor_Provided
to_No_Supported_Crypto_ID_Type_Descriptor_Provided (T.TStruct fields) = No_Supported_Crypto_ID_Type_Descriptor_Provided{
  no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor = P.maybe (P.Nothing) (\(_,_val171) -> P.Just (case _val171 of {T.TStruct _val172 -> (to_Crypto_ID_Type_Descriptor (T.TStruct _val172)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor = P.maybe (P.Nothing) (\(_,_val171) -> P.Just (case _val171 of {T.TStruct _val173 -> (to_Crypto_ID_Type_Descriptor (T.TStruct _val173)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation = P.maybe (P.Nothing) (\(_,_val171) -> P.Just (case _val171 of {T.TString _val174 -> E.decodeUtf8 _val174; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_No_Supported_Crypto_ID_Type_Descriptor_Provided _ = P.error "not a struct"
read_No_Supported_Crypto_ID_Type_Descriptor_Provided :: (T.Transport t, T.Protocol p) => p t -> P.IO No_Supported_Crypto_ID_Type_Descriptor_Provided
read_No_Supported_Crypto_ID_Type_Descriptor_Provided iprot = to_No_Supported_Crypto_ID_Type_Descriptor_Provided <$> T.readVal iprot (T.T_STRUCT typemap_No_Supported_Crypto_ID_Type_Descriptor_Provided)
decode_No_Supported_Crypto_ID_Type_Descriptor_Provided :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> No_Supported_Crypto_ID_Type_Descriptor_Provided
decode_No_Supported_Crypto_ID_Type_Descriptor_Provided iprot bs = to_No_Supported_Crypto_ID_Type_Descriptor_Provided $ T.deserializeVal iprot (T.T_STRUCT typemap_No_Supported_Crypto_ID_Type_Descriptor_Provided) bs
typemap_No_Supported_Crypto_ID_Type_Descriptor_Provided :: T.TypeMap
typemap_No_Supported_Crypto_ID_Type_Descriptor_Provided = Map.fromList [(1,("offending_crypto_id_type_descriptor",(T.T_STRUCT typemap_Crypto_ID_Type_Descriptor))),(2,("supported_crypto_id_type_descriptor",(T.T_STRUCT typemap_Crypto_ID_Type_Descriptor))),(3,("explanation",T.T_STRING))]
default_No_Supported_Crypto_ID_Type_Descriptor_Provided :: No_Supported_Crypto_ID_Type_Descriptor_Provided
default_No_Supported_Crypto_ID_Type_Descriptor_Provided = No_Supported_Crypto_ID_Type_Descriptor_Provided{
  no_Supported_Crypto_ID_Type_Descriptor_Provided_offending_crypto_id_type_descriptor = P.Nothing,
  no_Supported_Crypto_ID_Type_Descriptor_Provided_supported_crypto_id_type_descriptor = P.Nothing,
  no_Supported_Crypto_ID_Type_Descriptor_Provided_explanation = P.Nothing}
data Crypto_ID = Crypto_ID  { crypto_ID_public_crypto_key :: P.Maybe Public_Crypto_Key
  , crypto_ID_crypto_id_hash :: P.Maybe Crypto_ID_Hash
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Crypto_ID where
  hashWithSalt salt record = salt   `H.hashWithSalt` crypto_ID_public_crypto_key record   `H.hashWithSalt` crypto_ID_crypto_id_hash record  
instance QC.Arbitrary Crypto_ID where 
  arbitrary = M.liftM Crypto_ID (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Crypto_ID = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Crypto_ID{crypto_ID_public_crypto_key = crypto_ID_public_crypto_key obj} then P.Nothing else P.Just $ default_Crypto_ID{crypto_ID_public_crypto_key = crypto_ID_public_crypto_key obj}
    , if obj == default_Crypto_ID{crypto_ID_crypto_id_hash = crypto_ID_crypto_id_hash obj} then P.Nothing else P.Just $ default_Crypto_ID{crypto_ID_crypto_id_hash = crypto_ID_crypto_id_hash obj}
    ]
from_Crypto_ID :: Crypto_ID -> T.ThriftVal
from_Crypto_ID record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v177 -> (1, ("public_crypto_key",from_Public_Crypto_Key _v177))) <$> crypto_ID_public_crypto_key record
  , (\_v177 -> (2, ("crypto_id_hash",from_Crypto_ID_Hash _v177))) <$> crypto_ID_crypto_id_hash record
  ]
write_Crypto_ID :: (T.Protocol p, T.Transport t) => p t -> Crypto_ID -> P.IO ()
write_Crypto_ID oprot record = T.writeVal oprot $ from_Crypto_ID record
encode_Crypto_ID :: (T.Protocol p, T.Transport t) => p t -> Crypto_ID -> LBS.ByteString
encode_Crypto_ID oprot record = T.serializeVal oprot $ from_Crypto_ID record
to_Crypto_ID :: T.ThriftVal -> Crypto_ID
to_Crypto_ID (T.TStruct fields) = Crypto_ID{
  crypto_ID_public_crypto_key = P.maybe (P.Nothing) (\(_,_val179) -> P.Just (case _val179 of {T.TStruct _val180 -> (to_Public_Crypto_Key (T.TStruct _val180)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  crypto_ID_crypto_id_hash = P.maybe (P.Nothing) (\(_,_val179) -> P.Just (case _val179 of {T.TStruct _val181 -> (to_Crypto_ID_Hash (T.TStruct _val181)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Crypto_ID _ = P.error "not a struct"
read_Crypto_ID :: (T.Transport t, T.Protocol p) => p t -> P.IO Crypto_ID
read_Crypto_ID iprot = to_Crypto_ID <$> T.readVal iprot (T.T_STRUCT typemap_Crypto_ID)
decode_Crypto_ID :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Crypto_ID
decode_Crypto_ID iprot bs = to_Crypto_ID $ T.deserializeVal iprot (T.T_STRUCT typemap_Crypto_ID) bs
typemap_Crypto_ID :: T.TypeMap
typemap_Crypto_ID = Map.fromList [(1,("public_crypto_key",(T.T_STRUCT typemap_Public_Crypto_Key))),(2,("crypto_id_hash",(T.T_STRUCT typemap_Crypto_ID_Hash)))]
default_Crypto_ID :: Crypto_ID
default_Crypto_ID = Crypto_ID{
  crypto_ID_public_crypto_key = P.Nothing,
  crypto_ID_crypto_id_hash = P.Nothing}
data Descriptor_Does_Not_Match_Crypto_ID = Descriptor_Does_Not_Match_Crypto_ID  { descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor :: Crypto_ID_Type_Descriptor
  , descriptor_Does_Not_Match_Crypto_ID_crypto_id :: Crypto_ID
  , descriptor_Does_Not_Match_Crypto_ID_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Descriptor_Does_Not_Match_Crypto_ID
instance H.Hashable Descriptor_Does_Not_Match_Crypto_ID where
  hashWithSalt salt record = salt   `H.hashWithSalt` descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor record   `H.hashWithSalt` descriptor_Does_Not_Match_Crypto_ID_crypto_id record   `H.hashWithSalt` descriptor_Does_Not_Match_Crypto_ID_explanation record  
instance QC.Arbitrary Descriptor_Does_Not_Match_Crypto_ID where 
  arbitrary = M.liftM Descriptor_Does_Not_Match_Crypto_ID (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Descriptor_Does_Not_Match_Crypto_ID = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Descriptor_Does_Not_Match_Crypto_ID{descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor = descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Crypto_ID{descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor = descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor obj}
    , if obj == default_Descriptor_Does_Not_Match_Crypto_ID{descriptor_Does_Not_Match_Crypto_ID_crypto_id = descriptor_Does_Not_Match_Crypto_ID_crypto_id obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Crypto_ID{descriptor_Does_Not_Match_Crypto_ID_crypto_id = descriptor_Does_Not_Match_Crypto_ID_crypto_id obj}
    , if obj == default_Descriptor_Does_Not_Match_Crypto_ID{descriptor_Does_Not_Match_Crypto_ID_explanation = descriptor_Does_Not_Match_Crypto_ID_explanation obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Crypto_ID{descriptor_Does_Not_Match_Crypto_ID_explanation = descriptor_Does_Not_Match_Crypto_ID_explanation obj}
    ]
from_Descriptor_Does_Not_Match_Crypto_ID :: Descriptor_Does_Not_Match_Crypto_ID -> T.ThriftVal
from_Descriptor_Does_Not_Match_Crypto_ID record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v184 -> P.Just (1, ("crypto_id_type_descriptor",from_Crypto_ID_Type_Descriptor _v184))) $ descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor record
  , (\_v184 -> P.Just (2, ("crypto_id",from_Crypto_ID _v184))) $ descriptor_Does_Not_Match_Crypto_ID_crypto_id record
  , (\_v184 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v184))) <$> descriptor_Does_Not_Match_Crypto_ID_explanation record
  ]
write_Descriptor_Does_Not_Match_Crypto_ID :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Crypto_ID -> P.IO ()
write_Descriptor_Does_Not_Match_Crypto_ID oprot record = T.writeVal oprot $ from_Descriptor_Does_Not_Match_Crypto_ID record
encode_Descriptor_Does_Not_Match_Crypto_ID :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Crypto_ID -> LBS.ByteString
encode_Descriptor_Does_Not_Match_Crypto_ID oprot record = T.serializeVal oprot $ from_Descriptor_Does_Not_Match_Crypto_ID record
to_Descriptor_Does_Not_Match_Crypto_ID :: T.ThriftVal -> Descriptor_Does_Not_Match_Crypto_ID
to_Descriptor_Does_Not_Match_Crypto_ID (T.TStruct fields) = Descriptor_Does_Not_Match_Crypto_ID{
  descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor = P.maybe (descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor default_Descriptor_Does_Not_Match_Crypto_ID) (\(_,_val186) -> (case _val186 of {T.TStruct _val187 -> (to_Crypto_ID_Type_Descriptor (T.TStruct _val187)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  descriptor_Does_Not_Match_Crypto_ID_crypto_id = P.maybe (descriptor_Does_Not_Match_Crypto_ID_crypto_id default_Descriptor_Does_Not_Match_Crypto_ID) (\(_,_val186) -> (case _val186 of {T.TStruct _val188 -> (to_Crypto_ID (T.TStruct _val188)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  descriptor_Does_Not_Match_Crypto_ID_explanation = P.maybe (P.Nothing) (\(_,_val186) -> P.Just (case _val186 of {T.TString _val189 -> E.decodeUtf8 _val189; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Descriptor_Does_Not_Match_Crypto_ID _ = P.error "not a struct"
read_Descriptor_Does_Not_Match_Crypto_ID :: (T.Transport t, T.Protocol p) => p t -> P.IO Descriptor_Does_Not_Match_Crypto_ID
read_Descriptor_Does_Not_Match_Crypto_ID iprot = to_Descriptor_Does_Not_Match_Crypto_ID <$> T.readVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID)
decode_Descriptor_Does_Not_Match_Crypto_ID :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Descriptor_Does_Not_Match_Crypto_ID
decode_Descriptor_Does_Not_Match_Crypto_ID iprot bs = to_Descriptor_Does_Not_Match_Crypto_ID $ T.deserializeVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID) bs
typemap_Descriptor_Does_Not_Match_Crypto_ID :: T.TypeMap
typemap_Descriptor_Does_Not_Match_Crypto_ID = Map.fromList [(1,("crypto_id_type_descriptor",(T.T_STRUCT typemap_Crypto_ID_Type_Descriptor))),(2,("crypto_id",(T.T_STRUCT typemap_Crypto_ID))),(3,("explanation",T.T_STRING))]
default_Descriptor_Does_Not_Match_Crypto_ID :: Descriptor_Does_Not_Match_Crypto_ID
default_Descriptor_Does_Not_Match_Crypto_ID = Descriptor_Does_Not_Match_Crypto_ID{
  descriptor_Does_Not_Match_Crypto_ID_crypto_id_type_descriptor = default_Crypto_ID_Type_Descriptor,
  descriptor_Does_Not_Match_Crypto_ID_crypto_id = default_Crypto_ID,
  descriptor_Does_Not_Match_Crypto_ID_explanation = P.Nothing}
data Signed_Hash_Type_Descriptor = Signed_Hash_Type_Descriptor  { signed_Hash_Type_Descriptor_hash_type_descriptor :: P.Maybe Hash_Type_Descriptor
  , signed_Hash_Type_Descriptor_crypto_id :: P.Maybe Crypto_ID_Type_Descriptor
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Signed_Hash_Type_Descriptor where
  hashWithSalt salt record = salt   `H.hashWithSalt` signed_Hash_Type_Descriptor_hash_type_descriptor record   `H.hashWithSalt` signed_Hash_Type_Descriptor_crypto_id record  
instance QC.Arbitrary Signed_Hash_Type_Descriptor where 
  arbitrary = M.liftM Signed_Hash_Type_Descriptor (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Signed_Hash_Type_Descriptor = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Signed_Hash_Type_Descriptor{signed_Hash_Type_Descriptor_hash_type_descriptor = signed_Hash_Type_Descriptor_hash_type_descriptor obj} then P.Nothing else P.Just $ default_Signed_Hash_Type_Descriptor{signed_Hash_Type_Descriptor_hash_type_descriptor = signed_Hash_Type_Descriptor_hash_type_descriptor obj}
    , if obj == default_Signed_Hash_Type_Descriptor{signed_Hash_Type_Descriptor_crypto_id = signed_Hash_Type_Descriptor_crypto_id obj} then P.Nothing else P.Just $ default_Signed_Hash_Type_Descriptor{signed_Hash_Type_Descriptor_crypto_id = signed_Hash_Type_Descriptor_crypto_id obj}
    ]
from_Signed_Hash_Type_Descriptor :: Signed_Hash_Type_Descriptor -> T.ThriftVal
from_Signed_Hash_Type_Descriptor record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v192 -> (2, ("hash_type_descriptor",from_Hash_Type_Descriptor _v192))) <$> signed_Hash_Type_Descriptor_hash_type_descriptor record
  , (\_v192 -> (3, ("crypto_id",from_Crypto_ID_Type_Descriptor _v192))) <$> signed_Hash_Type_Descriptor_crypto_id record
  ]
write_Signed_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Signed_Hash_Type_Descriptor -> P.IO ()
write_Signed_Hash_Type_Descriptor oprot record = T.writeVal oprot $ from_Signed_Hash_Type_Descriptor record
encode_Signed_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> Signed_Hash_Type_Descriptor -> LBS.ByteString
encode_Signed_Hash_Type_Descriptor oprot record = T.serializeVal oprot $ from_Signed_Hash_Type_Descriptor record
to_Signed_Hash_Type_Descriptor :: T.ThriftVal -> Signed_Hash_Type_Descriptor
to_Signed_Hash_Type_Descriptor (T.TStruct fields) = Signed_Hash_Type_Descriptor{
  signed_Hash_Type_Descriptor_hash_type_descriptor = P.maybe (P.Nothing) (\(_,_val194) -> P.Just (case _val194 of {T.TStruct _val195 -> (to_Hash_Type_Descriptor (T.TStruct _val195)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  signed_Hash_Type_Descriptor_crypto_id = P.maybe (P.Nothing) (\(_,_val194) -> P.Just (case _val194 of {T.TStruct _val196 -> (to_Crypto_ID_Type_Descriptor (T.TStruct _val196)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Signed_Hash_Type_Descriptor _ = P.error "not a struct"
read_Signed_Hash_Type_Descriptor :: (T.Transport t, T.Protocol p) => p t -> P.IO Signed_Hash_Type_Descriptor
read_Signed_Hash_Type_Descriptor iprot = to_Signed_Hash_Type_Descriptor <$> T.readVal iprot (T.T_STRUCT typemap_Signed_Hash_Type_Descriptor)
decode_Signed_Hash_Type_Descriptor :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Signed_Hash_Type_Descriptor
decode_Signed_Hash_Type_Descriptor iprot bs = to_Signed_Hash_Type_Descriptor $ T.deserializeVal iprot (T.T_STRUCT typemap_Signed_Hash_Type_Descriptor) bs
typemap_Signed_Hash_Type_Descriptor :: T.TypeMap
typemap_Signed_Hash_Type_Descriptor = Map.fromList [(2,("hash_type_descriptor",(T.T_STRUCT typemap_Hash_Type_Descriptor))),(3,("crypto_id",(T.T_STRUCT typemap_Crypto_ID_Type_Descriptor)))]
default_Signed_Hash_Type_Descriptor :: Signed_Hash_Type_Descriptor
default_Signed_Hash_Type_Descriptor = Signed_Hash_Type_Descriptor{
  signed_Hash_Type_Descriptor_hash_type_descriptor = P.Nothing,
  signed_Hash_Type_Descriptor_crypto_id = P.Nothing}
data Signed_Hash = Signed_Hash  { signed_Hash_signature :: LBS.ByteString
  , signed_Hash_hash_type_descriptor :: P.Maybe Hash_Type_Descriptor
  , signed_Hash_crypto_id :: P.Maybe Crypto_ID
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Signed_Hash where
  hashWithSalt salt record = salt   `H.hashWithSalt` signed_Hash_signature record   `H.hashWithSalt` signed_Hash_hash_type_descriptor record   `H.hashWithSalt` signed_Hash_crypto_id record  
instance QC.Arbitrary Signed_Hash where 
  arbitrary = M.liftM Signed_Hash (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Signed_Hash = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Signed_Hash{signed_Hash_signature = signed_Hash_signature obj} then P.Nothing else P.Just $ default_Signed_Hash{signed_Hash_signature = signed_Hash_signature obj}
    , if obj == default_Signed_Hash{signed_Hash_hash_type_descriptor = signed_Hash_hash_type_descriptor obj} then P.Nothing else P.Just $ default_Signed_Hash{signed_Hash_hash_type_descriptor = signed_Hash_hash_type_descriptor obj}
    , if obj == default_Signed_Hash{signed_Hash_crypto_id = signed_Hash_crypto_id obj} then P.Nothing else P.Just $ default_Signed_Hash{signed_Hash_crypto_id = signed_Hash_crypto_id obj}
    ]
from_Signed_Hash :: Signed_Hash -> T.ThriftVal
from_Signed_Hash record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v199 -> P.Just (1, ("signature",T.TBinary _v199))) $ signed_Hash_signature record
  , (\_v199 -> (2, ("hash_type_descriptor",from_Hash_Type_Descriptor _v199))) <$> signed_Hash_hash_type_descriptor record
  , (\_v199 -> (3, ("crypto_id",from_Crypto_ID _v199))) <$> signed_Hash_crypto_id record
  ]
write_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> Signed_Hash -> P.IO ()
write_Signed_Hash oprot record = T.writeVal oprot $ from_Signed_Hash record
encode_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> Signed_Hash -> LBS.ByteString
encode_Signed_Hash oprot record = T.serializeVal oprot $ from_Signed_Hash record
to_Signed_Hash :: T.ThriftVal -> Signed_Hash
to_Signed_Hash (T.TStruct fields) = Signed_Hash{
  signed_Hash_signature = P.maybe (signed_Hash_signature default_Signed_Hash) (\(_,_val201) -> (case _val201 of {T.TBinary _val202 -> _val202; T.TString _val202 -> _val202; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  signed_Hash_hash_type_descriptor = P.maybe (P.Nothing) (\(_,_val201) -> P.Just (case _val201 of {T.TStruct _val203 -> (to_Hash_Type_Descriptor (T.TStruct _val203)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  signed_Hash_crypto_id = P.maybe (P.Nothing) (\(_,_val201) -> P.Just (case _val201 of {T.TStruct _val204 -> (to_Crypto_ID (T.TStruct _val204)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Signed_Hash _ = P.error "not a struct"
read_Signed_Hash :: (T.Transport t, T.Protocol p) => p t -> P.IO Signed_Hash
read_Signed_Hash iprot = to_Signed_Hash <$> T.readVal iprot (T.T_STRUCT typemap_Signed_Hash)
decode_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Signed_Hash
decode_Signed_Hash iprot bs = to_Signed_Hash $ T.deserializeVal iprot (T.T_STRUCT typemap_Signed_Hash) bs
typemap_Signed_Hash :: T.TypeMap
typemap_Signed_Hash = Map.fromList [(1,("signature",T.T_BINARY)),(2,("hash_type_descriptor",(T.T_STRUCT typemap_Hash_Type_Descriptor))),(3,("crypto_id",(T.T_STRUCT typemap_Crypto_ID)))]
default_Signed_Hash :: Signed_Hash
default_Signed_Hash = Signed_Hash{
  signed_Hash_signature = "",
  signed_Hash_hash_type_descriptor = P.Nothing,
  signed_Hash_crypto_id = P.Nothing}
data Invalid_Signed_Hash = Invalid_Signed_Hash  { invalid_Signed_Hash_signed_hash :: Signed_Hash
  , invalid_Signed_Hash_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Signed_Hash
instance H.Hashable Invalid_Signed_Hash where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Signed_Hash_signed_hash record   `H.hashWithSalt` invalid_Signed_Hash_explanation record  
instance QC.Arbitrary Invalid_Signed_Hash where 
  arbitrary = M.liftM Invalid_Signed_Hash (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Signed_Hash = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Signed_Hash{invalid_Signed_Hash_signed_hash = invalid_Signed_Hash_signed_hash obj} then P.Nothing else P.Just $ default_Invalid_Signed_Hash{invalid_Signed_Hash_signed_hash = invalid_Signed_Hash_signed_hash obj}
    , if obj == default_Invalid_Signed_Hash{invalid_Signed_Hash_explanation = invalid_Signed_Hash_explanation obj} then P.Nothing else P.Just $ default_Invalid_Signed_Hash{invalid_Signed_Hash_explanation = invalid_Signed_Hash_explanation obj}
    ]
from_Invalid_Signed_Hash :: Invalid_Signed_Hash -> T.ThriftVal
from_Invalid_Signed_Hash record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v207 -> P.Just (1, ("signed_hash",from_Signed_Hash _v207))) $ invalid_Signed_Hash_signed_hash record
  , (\_v207 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v207))) <$> invalid_Signed_Hash_explanation record
  ]
write_Invalid_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> Invalid_Signed_Hash -> P.IO ()
write_Invalid_Signed_Hash oprot record = T.writeVal oprot $ from_Invalid_Signed_Hash record
encode_Invalid_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> Invalid_Signed_Hash -> LBS.ByteString
encode_Invalid_Signed_Hash oprot record = T.serializeVal oprot $ from_Invalid_Signed_Hash record
to_Invalid_Signed_Hash :: T.ThriftVal -> Invalid_Signed_Hash
to_Invalid_Signed_Hash (T.TStruct fields) = Invalid_Signed_Hash{
  invalid_Signed_Hash_signed_hash = P.maybe (invalid_Signed_Hash_signed_hash default_Invalid_Signed_Hash) (\(_,_val209) -> (case _val209 of {T.TStruct _val210 -> (to_Signed_Hash (T.TStruct _val210)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Signed_Hash_explanation = P.maybe (P.Nothing) (\(_,_val209) -> P.Just (case _val209 of {T.TString _val211 -> E.decodeUtf8 _val211; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Invalid_Signed_Hash _ = P.error "not a struct"
read_Invalid_Signed_Hash :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Signed_Hash
read_Invalid_Signed_Hash iprot = to_Invalid_Signed_Hash <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Signed_Hash)
decode_Invalid_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Signed_Hash
decode_Invalid_Signed_Hash iprot bs = to_Invalid_Signed_Hash $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Signed_Hash) bs
typemap_Invalid_Signed_Hash :: T.TypeMap
typemap_Invalid_Signed_Hash = Map.fromList [(1,("signed_hash",(T.T_STRUCT typemap_Signed_Hash))),(3,("explanation",T.T_STRING))]
default_Invalid_Signed_Hash :: Invalid_Signed_Hash
default_Invalid_Signed_Hash = Invalid_Signed_Hash{
  invalid_Signed_Hash_signed_hash = default_Signed_Hash,
  invalid_Signed_Hash_explanation = P.Nothing}
data Descriptor_Does_Not_Match_Signed_Hash = Descriptor_Does_Not_Match_Signed_Hash  { descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor :: Signed_Hash_Type_Descriptor
  , descriptor_Does_Not_Match_Signed_Hash_signed_hash :: Signed_Hash
  , descriptor_Does_Not_Match_Signed_Hash_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Descriptor_Does_Not_Match_Signed_Hash
instance H.Hashable Descriptor_Does_Not_Match_Signed_Hash where
  hashWithSalt salt record = salt   `H.hashWithSalt` descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor record   `H.hashWithSalt` descriptor_Does_Not_Match_Signed_Hash_signed_hash record   `H.hashWithSalt` descriptor_Does_Not_Match_Signed_Hash_explanation record  
instance QC.Arbitrary Descriptor_Does_Not_Match_Signed_Hash where 
  arbitrary = M.liftM Descriptor_Does_Not_Match_Signed_Hash (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Descriptor_Does_Not_Match_Signed_Hash = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Descriptor_Does_Not_Match_Signed_Hash{descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor = descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Signed_Hash{descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor = descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor obj}
    , if obj == default_Descriptor_Does_Not_Match_Signed_Hash{descriptor_Does_Not_Match_Signed_Hash_signed_hash = descriptor_Does_Not_Match_Signed_Hash_signed_hash obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Signed_Hash{descriptor_Does_Not_Match_Signed_Hash_signed_hash = descriptor_Does_Not_Match_Signed_Hash_signed_hash obj}
    , if obj == default_Descriptor_Does_Not_Match_Signed_Hash{descriptor_Does_Not_Match_Signed_Hash_explanation = descriptor_Does_Not_Match_Signed_Hash_explanation obj} then P.Nothing else P.Just $ default_Descriptor_Does_Not_Match_Signed_Hash{descriptor_Does_Not_Match_Signed_Hash_explanation = descriptor_Does_Not_Match_Signed_Hash_explanation obj}
    ]
from_Descriptor_Does_Not_Match_Signed_Hash :: Descriptor_Does_Not_Match_Signed_Hash -> T.ThriftVal
from_Descriptor_Does_Not_Match_Signed_Hash record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v214 -> P.Just (1, ("signed_hash_type_descriptor",from_Signed_Hash_Type_Descriptor _v214))) $ descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor record
  , (\_v214 -> P.Just (2, ("signed_hash",from_Signed_Hash _v214))) $ descriptor_Does_Not_Match_Signed_Hash_signed_hash record
  , (\_v214 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v214))) <$> descriptor_Does_Not_Match_Signed_Hash_explanation record
  ]
write_Descriptor_Does_Not_Match_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Signed_Hash -> P.IO ()
write_Descriptor_Does_Not_Match_Signed_Hash oprot record = T.writeVal oprot $ from_Descriptor_Does_Not_Match_Signed_Hash record
encode_Descriptor_Does_Not_Match_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> Descriptor_Does_Not_Match_Signed_Hash -> LBS.ByteString
encode_Descriptor_Does_Not_Match_Signed_Hash oprot record = T.serializeVal oprot $ from_Descriptor_Does_Not_Match_Signed_Hash record
to_Descriptor_Does_Not_Match_Signed_Hash :: T.ThriftVal -> Descriptor_Does_Not_Match_Signed_Hash
to_Descriptor_Does_Not_Match_Signed_Hash (T.TStruct fields) = Descriptor_Does_Not_Match_Signed_Hash{
  descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor = P.maybe (descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor default_Descriptor_Does_Not_Match_Signed_Hash) (\(_,_val216) -> (case _val216 of {T.TStruct _val217 -> (to_Signed_Hash_Type_Descriptor (T.TStruct _val217)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  descriptor_Does_Not_Match_Signed_Hash_signed_hash = P.maybe (descriptor_Does_Not_Match_Signed_Hash_signed_hash default_Descriptor_Does_Not_Match_Signed_Hash) (\(_,_val216) -> (case _val216 of {T.TStruct _val218 -> (to_Signed_Hash (T.TStruct _val218)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  descriptor_Does_Not_Match_Signed_Hash_explanation = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TString _val219 -> E.decodeUtf8 _val219; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Descriptor_Does_Not_Match_Signed_Hash _ = P.error "not a struct"
read_Descriptor_Does_Not_Match_Signed_Hash :: (T.Transport t, T.Protocol p) => p t -> P.IO Descriptor_Does_Not_Match_Signed_Hash
read_Descriptor_Does_Not_Match_Signed_Hash iprot = to_Descriptor_Does_Not_Match_Signed_Hash <$> T.readVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Signed_Hash)
decode_Descriptor_Does_Not_Match_Signed_Hash :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Descriptor_Does_Not_Match_Signed_Hash
decode_Descriptor_Does_Not_Match_Signed_Hash iprot bs = to_Descriptor_Does_Not_Match_Signed_Hash $ T.deserializeVal iprot (T.T_STRUCT typemap_Descriptor_Does_Not_Match_Signed_Hash) bs
typemap_Descriptor_Does_Not_Match_Signed_Hash :: T.TypeMap
typemap_Descriptor_Does_Not_Match_Signed_Hash = Map.fromList [(1,("signed_hash_type_descriptor",(T.T_STRUCT typemap_Signed_Hash_Type_Descriptor))),(2,("signed_hash",(T.T_STRUCT typemap_Signed_Hash))),(3,("explanation",T.T_STRING))]
default_Descriptor_Does_Not_Match_Signed_Hash :: Descriptor_Does_Not_Match_Signed_Hash
default_Descriptor_Does_Not_Match_Signed_Hash = Descriptor_Does_Not_Match_Signed_Hash{
  descriptor_Does_Not_Match_Signed_Hash_signed_hash_type_descriptor = default_Signed_Hash_Type_Descriptor,
  descriptor_Does_Not_Match_Signed_Hash_signed_hash = default_Signed_Hash,
  descriptor_Does_Not_Match_Signed_Hash_explanation = P.Nothing}
data Unparsable_Hashable_Message = Unparsable_Hashable_Message  { unparsable_Hashable_Message_message :: LBS.ByteString
  , unparsable_Hashable_Message_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Unparsable_Hashable_Message
instance H.Hashable Unparsable_Hashable_Message where
  hashWithSalt salt record = salt   `H.hashWithSalt` unparsable_Hashable_Message_message record   `H.hashWithSalt` unparsable_Hashable_Message_explanation record  
instance QC.Arbitrary Unparsable_Hashable_Message where 
  arbitrary = M.liftM Unparsable_Hashable_Message (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Unparsable_Hashable_Message = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Unparsable_Hashable_Message{unparsable_Hashable_Message_message = unparsable_Hashable_Message_message obj} then P.Nothing else P.Just $ default_Unparsable_Hashable_Message{unparsable_Hashable_Message_message = unparsable_Hashable_Message_message obj}
    , if obj == default_Unparsable_Hashable_Message{unparsable_Hashable_Message_explanation = unparsable_Hashable_Message_explanation obj} then P.Nothing else P.Just $ default_Unparsable_Hashable_Message{unparsable_Hashable_Message_explanation = unparsable_Hashable_Message_explanation obj}
    ]
from_Unparsable_Hashable_Message :: Unparsable_Hashable_Message -> T.ThriftVal
from_Unparsable_Hashable_Message record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v222 -> P.Just (1, ("message",T.TBinary _v222))) $ unparsable_Hashable_Message_message record
  , (\_v222 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v222))) <$> unparsable_Hashable_Message_explanation record
  ]
write_Unparsable_Hashable_Message :: (T.Protocol p, T.Transport t) => p t -> Unparsable_Hashable_Message -> P.IO ()
write_Unparsable_Hashable_Message oprot record = T.writeVal oprot $ from_Unparsable_Hashable_Message record
encode_Unparsable_Hashable_Message :: (T.Protocol p, T.Transport t) => p t -> Unparsable_Hashable_Message -> LBS.ByteString
encode_Unparsable_Hashable_Message oprot record = T.serializeVal oprot $ from_Unparsable_Hashable_Message record
to_Unparsable_Hashable_Message :: T.ThriftVal -> Unparsable_Hashable_Message
to_Unparsable_Hashable_Message (T.TStruct fields) = Unparsable_Hashable_Message{
  unparsable_Hashable_Message_message = P.maybe (unparsable_Hashable_Message_message default_Unparsable_Hashable_Message) (\(_,_val224) -> (case _val224 of {T.TBinary _val225 -> _val225; T.TString _val225 -> _val225; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unparsable_Hashable_Message_explanation = P.maybe (P.Nothing) (\(_,_val224) -> P.Just (case _val224 of {T.TString _val226 -> E.decodeUtf8 _val226; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Unparsable_Hashable_Message _ = P.error "not a struct"
read_Unparsable_Hashable_Message :: (T.Transport t, T.Protocol p) => p t -> P.IO Unparsable_Hashable_Message
read_Unparsable_Hashable_Message iprot = to_Unparsable_Hashable_Message <$> T.readVal iprot (T.T_STRUCT typemap_Unparsable_Hashable_Message)
decode_Unparsable_Hashable_Message :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Unparsable_Hashable_Message
decode_Unparsable_Hashable_Message iprot bs = to_Unparsable_Hashable_Message $ T.deserializeVal iprot (T.T_STRUCT typemap_Unparsable_Hashable_Message) bs
typemap_Unparsable_Hashable_Message :: T.TypeMap
typemap_Unparsable_Hashable_Message = Map.fromList [(1,("message",T.T_BINARY)),(3,("explanation",T.T_STRING))]
default_Unparsable_Hashable_Message :: Unparsable_Hashable_Message
default_Unparsable_Hashable_Message = Unparsable_Hashable_Message{
  unparsable_Hashable_Message_message = "",
  unparsable_Hashable_Message_explanation = P.Nothing}
data Signed_Message = Signed_Message  { signed_Message_payload :: LBS.ByteString
  , signed_Message_signature :: Signed_Hash
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Signed_Message where
  hashWithSalt salt record = salt   `H.hashWithSalt` signed_Message_payload record   `H.hashWithSalt` signed_Message_signature record  
instance QC.Arbitrary Signed_Message where 
  arbitrary = M.liftM Signed_Message (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Signed_Message = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Signed_Message{signed_Message_payload = signed_Message_payload obj} then P.Nothing else P.Just $ default_Signed_Message{signed_Message_payload = signed_Message_payload obj}
    , if obj == default_Signed_Message{signed_Message_signature = signed_Message_signature obj} then P.Nothing else P.Just $ default_Signed_Message{signed_Message_signature = signed_Message_signature obj}
    ]
from_Signed_Message :: Signed_Message -> T.ThriftVal
from_Signed_Message record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v229 -> P.Just (1, ("payload",T.TBinary _v229))) $ signed_Message_payload record
  , (\_v229 -> P.Just (2, ("signature",from_Signed_Hash _v229))) $ signed_Message_signature record
  ]
write_Signed_Message :: (T.Protocol p, T.Transport t) => p t -> Signed_Message -> P.IO ()
write_Signed_Message oprot record = T.writeVal oprot $ from_Signed_Message record
encode_Signed_Message :: (T.Protocol p, T.Transport t) => p t -> Signed_Message -> LBS.ByteString
encode_Signed_Message oprot record = T.serializeVal oprot $ from_Signed_Message record
to_Signed_Message :: T.ThriftVal -> Signed_Message
to_Signed_Message (T.TStruct fields) = Signed_Message{
  signed_Message_payload = P.maybe (signed_Message_payload default_Signed_Message) (\(_,_val231) -> (case _val231 of {T.TBinary _val232 -> _val232; T.TString _val232 -> _val232; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  signed_Message_signature = P.maybe (signed_Message_signature default_Signed_Message) (\(_,_val231) -> (case _val231 of {T.TStruct _val233 -> (to_Signed_Hash (T.TStruct _val233)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Signed_Message _ = P.error "not a struct"
read_Signed_Message :: (T.Transport t, T.Protocol p) => p t -> P.IO Signed_Message
read_Signed_Message iprot = to_Signed_Message <$> T.readVal iprot (T.T_STRUCT typemap_Signed_Message)
decode_Signed_Message :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Signed_Message
decode_Signed_Message iprot bs = to_Signed_Message $ T.deserializeVal iprot (T.T_STRUCT typemap_Signed_Message) bs
typemap_Signed_Message :: T.TypeMap
typemap_Signed_Message = Map.fromList [(1,("payload",T.T_BINARY)),(2,("signature",(T.T_STRUCT typemap_Signed_Hash)))]
default_Signed_Message :: Signed_Message
default_Signed_Message = Signed_Message{
  signed_Message_payload = "",
  signed_Message_signature = default_Signed_Hash}
data IPv4_Address = IPv4_Address  { iPv4_Address_byte_0 :: I.Int8
  , iPv4_Address_byte_1 :: I.Int8
  , iPv4_Address_byte_2 :: I.Int8
  , iPv4_Address_byte_3 :: I.Int8
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IPv4_Address where
  hashWithSalt salt record = salt   `H.hashWithSalt` iPv4_Address_byte_0 record   `H.hashWithSalt` iPv4_Address_byte_1 record   `H.hashWithSalt` iPv4_Address_byte_2 record   `H.hashWithSalt` iPv4_Address_byte_3 record  
instance QC.Arbitrary IPv4_Address where 
  arbitrary = M.liftM IPv4_Address (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IPv4_Address = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IPv4_Address{iPv4_Address_byte_0 = iPv4_Address_byte_0 obj} then P.Nothing else P.Just $ default_IPv4_Address{iPv4_Address_byte_0 = iPv4_Address_byte_0 obj}
    , if obj == default_IPv4_Address{iPv4_Address_byte_1 = iPv4_Address_byte_1 obj} then P.Nothing else P.Just $ default_IPv4_Address{iPv4_Address_byte_1 = iPv4_Address_byte_1 obj}
    , if obj == default_IPv4_Address{iPv4_Address_byte_2 = iPv4_Address_byte_2 obj} then P.Nothing else P.Just $ default_IPv4_Address{iPv4_Address_byte_2 = iPv4_Address_byte_2 obj}
    , if obj == default_IPv4_Address{iPv4_Address_byte_3 = iPv4_Address_byte_3 obj} then P.Nothing else P.Just $ default_IPv4_Address{iPv4_Address_byte_3 = iPv4_Address_byte_3 obj}
    ]
from_IPv4_Address :: IPv4_Address -> T.ThriftVal
from_IPv4_Address record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v236 -> P.Just (1, ("byte_0",T.TByte _v236))) $ iPv4_Address_byte_0 record
  , (\_v236 -> P.Just (2, ("byte_1",T.TByte _v236))) $ iPv4_Address_byte_1 record
  , (\_v236 -> P.Just (3, ("byte_2",T.TByte _v236))) $ iPv4_Address_byte_2 record
  , (\_v236 -> P.Just (4, ("byte_3",T.TByte _v236))) $ iPv4_Address_byte_3 record
  ]
write_IPv4_Address :: (T.Protocol p, T.Transport t) => p t -> IPv4_Address -> P.IO ()
write_IPv4_Address oprot record = T.writeVal oprot $ from_IPv4_Address record
encode_IPv4_Address :: (T.Protocol p, T.Transport t) => p t -> IPv4_Address -> LBS.ByteString
encode_IPv4_Address oprot record = T.serializeVal oprot $ from_IPv4_Address record
to_IPv4_Address :: T.ThriftVal -> IPv4_Address
to_IPv4_Address (T.TStruct fields) = IPv4_Address{
  iPv4_Address_byte_0 = P.maybe (iPv4_Address_byte_0 default_IPv4_Address) (\(_,_val238) -> (case _val238 of {T.TByte _val239 -> _val239; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  iPv4_Address_byte_1 = P.maybe (iPv4_Address_byte_1 default_IPv4_Address) (\(_,_val238) -> (case _val238 of {T.TByte _val240 -> _val240; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  iPv4_Address_byte_2 = P.maybe (iPv4_Address_byte_2 default_IPv4_Address) (\(_,_val238) -> (case _val238 of {T.TByte _val241 -> _val241; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  iPv4_Address_byte_3 = P.maybe (iPv4_Address_byte_3 default_IPv4_Address) (\(_,_val238) -> (case _val238 of {T.TByte _val242 -> _val242; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_IPv4_Address _ = P.error "not a struct"
read_IPv4_Address :: (T.Transport t, T.Protocol p) => p t -> P.IO IPv4_Address
read_IPv4_Address iprot = to_IPv4_Address <$> T.readVal iprot (T.T_STRUCT typemap_IPv4_Address)
decode_IPv4_Address :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> IPv4_Address
decode_IPv4_Address iprot bs = to_IPv4_Address $ T.deserializeVal iprot (T.T_STRUCT typemap_IPv4_Address) bs
typemap_IPv4_Address :: T.TypeMap
typemap_IPv4_Address = Map.fromList [(1,("byte_0",T.T_BYTE)),(2,("byte_1",T.T_BYTE)),(3,("byte_2",T.T_BYTE)),(4,("byte_3",T.T_BYTE))]
default_IPv4_Address :: IPv4_Address
default_IPv4_Address = IPv4_Address{
  iPv4_Address_byte_0 = 0,
  iPv4_Address_byte_1 = 0,
  iPv4_Address_byte_2 = 0,
  iPv4_Address_byte_3 = 0}
data IPv6_Address = IPv6_Address  { iPv6_Address_byte_0 :: I.Int8
  , iPv6_Address_byte_1 :: I.Int8
  , iPv6_Address_byte_2 :: I.Int8
  , iPv6_Address_byte_3 :: I.Int8
  , iPv6_Address_byte_4 :: I.Int8
  , iPv6_Address_byte_5 :: I.Int8
  , iPv6_Address_byte_6 :: I.Int8
  , iPv6_Address_byte_7 :: I.Int8
  , iPv6_Address_byte_8 :: I.Int8
  , iPv6_Address_byte_9 :: I.Int8
  , iPv6_Address_byte_10 :: I.Int8
  , iPv6_Address_byte_11 :: I.Int8
  , iPv6_Address_byte_12 :: I.Int8
  , iPv6_Address_byte_13 :: I.Int8
  , iPv6_Address_byte_14 :: I.Int8
  , iPv6_Address_byte_15 :: I.Int8
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IPv6_Address where
  hashWithSalt salt record = salt   `H.hashWithSalt` iPv6_Address_byte_0 record   `H.hashWithSalt` iPv6_Address_byte_1 record   `H.hashWithSalt` iPv6_Address_byte_2 record   `H.hashWithSalt` iPv6_Address_byte_3 record   `H.hashWithSalt` iPv6_Address_byte_4 record   `H.hashWithSalt` iPv6_Address_byte_5 record   `H.hashWithSalt` iPv6_Address_byte_6 record   `H.hashWithSalt` iPv6_Address_byte_7 record   `H.hashWithSalt` iPv6_Address_byte_8 record   `H.hashWithSalt` iPv6_Address_byte_9 record   `H.hashWithSalt` iPv6_Address_byte_10 record   `H.hashWithSalt` iPv6_Address_byte_11 record   `H.hashWithSalt` iPv6_Address_byte_12 record   `H.hashWithSalt` iPv6_Address_byte_13 record   `H.hashWithSalt` iPv6_Address_byte_14 record   `H.hashWithSalt` iPv6_Address_byte_15 record  
instance QC.Arbitrary IPv6_Address where 
  arbitrary = M.liftM IPv6_Address (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IPv6_Address = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IPv6_Address{iPv6_Address_byte_0 = iPv6_Address_byte_0 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_0 = iPv6_Address_byte_0 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_1 = iPv6_Address_byte_1 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_1 = iPv6_Address_byte_1 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_2 = iPv6_Address_byte_2 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_2 = iPv6_Address_byte_2 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_3 = iPv6_Address_byte_3 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_3 = iPv6_Address_byte_3 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_4 = iPv6_Address_byte_4 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_4 = iPv6_Address_byte_4 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_5 = iPv6_Address_byte_5 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_5 = iPv6_Address_byte_5 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_6 = iPv6_Address_byte_6 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_6 = iPv6_Address_byte_6 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_7 = iPv6_Address_byte_7 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_7 = iPv6_Address_byte_7 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_8 = iPv6_Address_byte_8 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_8 = iPv6_Address_byte_8 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_9 = iPv6_Address_byte_9 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_9 = iPv6_Address_byte_9 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_10 = iPv6_Address_byte_10 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_10 = iPv6_Address_byte_10 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_11 = iPv6_Address_byte_11 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_11 = iPv6_Address_byte_11 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_12 = iPv6_Address_byte_12 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_12 = iPv6_Address_byte_12 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_13 = iPv6_Address_byte_13 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_13 = iPv6_Address_byte_13 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_14 = iPv6_Address_byte_14 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_14 = iPv6_Address_byte_14 obj}
    , if obj == default_IPv6_Address{iPv6_Address_byte_15 = iPv6_Address_byte_15 obj} then P.Nothing else P.Just $ default_IPv6_Address{iPv6_Address_byte_15 = iPv6_Address_byte_15 obj}
    ]
from_IPv6_Address :: IPv6_Address -> T.ThriftVal
from_IPv6_Address record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v245 -> P.Just (1, ("byte_0",T.TByte _v245))) $ iPv6_Address_byte_0 record
  , (\_v245 -> P.Just (2, ("byte_1",T.TByte _v245))) $ iPv6_Address_byte_1 record
  , (\_v245 -> P.Just (3, ("byte_2",T.TByte _v245))) $ iPv6_Address_byte_2 record
  , (\_v245 -> P.Just (4, ("byte_3",T.TByte _v245))) $ iPv6_Address_byte_3 record
  , (\_v245 -> P.Just (5, ("byte_4",T.TByte _v245))) $ iPv6_Address_byte_4 record
  , (\_v245 -> P.Just (6, ("byte_5",T.TByte _v245))) $ iPv6_Address_byte_5 record
  , (\_v245 -> P.Just (7, ("byte_6",T.TByte _v245))) $ iPv6_Address_byte_6 record
  , (\_v245 -> P.Just (8, ("byte_7",T.TByte _v245))) $ iPv6_Address_byte_7 record
  , (\_v245 -> P.Just (9, ("byte_8",T.TByte _v245))) $ iPv6_Address_byte_8 record
  , (\_v245 -> P.Just (10, ("byte_9",T.TByte _v245))) $ iPv6_Address_byte_9 record
  , (\_v245 -> P.Just (11, ("byte_10",T.TByte _v245))) $ iPv6_Address_byte_10 record
  , (\_v245 -> P.Just (12, ("byte_11",T.TByte _v245))) $ iPv6_Address_byte_11 record
  , (\_v245 -> P.Just (13, ("byte_12",T.TByte _v245))) $ iPv6_Address_byte_12 record
  , (\_v245 -> P.Just (14, ("byte_13",T.TByte _v245))) $ iPv6_Address_byte_13 record
  , (\_v245 -> P.Just (15, ("byte_14",T.TByte _v245))) $ iPv6_Address_byte_14 record
  , (\_v245 -> P.Just (16, ("byte_15",T.TByte _v245))) $ iPv6_Address_byte_15 record
  ]
write_IPv6_Address :: (T.Protocol p, T.Transport t) => p t -> IPv6_Address -> P.IO ()
write_IPv6_Address oprot record = T.writeVal oprot $ from_IPv6_Address record
encode_IPv6_Address :: (T.Protocol p, T.Transport t) => p t -> IPv6_Address -> LBS.ByteString
encode_IPv6_Address oprot record = T.serializeVal oprot $ from_IPv6_Address record
to_IPv6_Address :: T.ThriftVal -> IPv6_Address
to_IPv6_Address (T.TStruct fields) = IPv6_Address{
  iPv6_Address_byte_0 = P.maybe (iPv6_Address_byte_0 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val248 -> _val248; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  iPv6_Address_byte_1 = P.maybe (iPv6_Address_byte_1 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val249 -> _val249; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  iPv6_Address_byte_2 = P.maybe (iPv6_Address_byte_2 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val250 -> _val250; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  iPv6_Address_byte_3 = P.maybe (iPv6_Address_byte_3 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val251 -> _val251; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  iPv6_Address_byte_4 = P.maybe (iPv6_Address_byte_4 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val252 -> _val252; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  iPv6_Address_byte_5 = P.maybe (iPv6_Address_byte_5 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val253 -> _val253; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  iPv6_Address_byte_6 = P.maybe (iPv6_Address_byte_6 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val254 -> _val254; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  iPv6_Address_byte_7 = P.maybe (iPv6_Address_byte_7 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val255 -> _val255; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  iPv6_Address_byte_8 = P.maybe (iPv6_Address_byte_8 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val256 -> _val256; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  iPv6_Address_byte_9 = P.maybe (iPv6_Address_byte_9 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val257 -> _val257; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  iPv6_Address_byte_10 = P.maybe (iPv6_Address_byte_10 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val258 -> _val258; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  iPv6_Address_byte_11 = P.maybe (iPv6_Address_byte_11 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val259 -> _val259; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  iPv6_Address_byte_12 = P.maybe (iPv6_Address_byte_12 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val260 -> _val260; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  iPv6_Address_byte_13 = P.maybe (iPv6_Address_byte_13 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val261 -> _val261; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  iPv6_Address_byte_14 = P.maybe (iPv6_Address_byte_14 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val262 -> _val262; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  iPv6_Address_byte_15 = P.maybe (iPv6_Address_byte_15 default_IPv6_Address) (\(_,_val247) -> (case _val247 of {T.TByte _val263 -> _val263; _ -> P.error "wrong type"})) (Map.lookup (16) fields)
  }
to_IPv6_Address _ = P.error "not a struct"
read_IPv6_Address :: (T.Transport t, T.Protocol p) => p t -> P.IO IPv6_Address
read_IPv6_Address iprot = to_IPv6_Address <$> T.readVal iprot (T.T_STRUCT typemap_IPv6_Address)
decode_IPv6_Address :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> IPv6_Address
decode_IPv6_Address iprot bs = to_IPv6_Address $ T.deserializeVal iprot (T.T_STRUCT typemap_IPv6_Address) bs
typemap_IPv6_Address :: T.TypeMap
typemap_IPv6_Address = Map.fromList [(1,("byte_0",T.T_BYTE)),(2,("byte_1",T.T_BYTE)),(3,("byte_2",T.T_BYTE)),(4,("byte_3",T.T_BYTE)),(5,("byte_4",T.T_BYTE)),(6,("byte_5",T.T_BYTE)),(7,("byte_6",T.T_BYTE)),(8,("byte_7",T.T_BYTE)),(9,("byte_8",T.T_BYTE)),(10,("byte_9",T.T_BYTE)),(11,("byte_10",T.T_BYTE)),(12,("byte_11",T.T_BYTE)),(13,("byte_12",T.T_BYTE)),(14,("byte_13",T.T_BYTE)),(15,("byte_14",T.T_BYTE)),(16,("byte_15",T.T_BYTE))]
default_IPv6_Address :: IPv6_Address
default_IPv6_Address = IPv6_Address{
  iPv6_Address_byte_0 = 0,
  iPv6_Address_byte_1 = 0,
  iPv6_Address_byte_2 = 0,
  iPv6_Address_byte_3 = 0,
  iPv6_Address_byte_4 = 0,
  iPv6_Address_byte_5 = 0,
  iPv6_Address_byte_6 = 0,
  iPv6_Address_byte_7 = 0,
  iPv6_Address_byte_8 = 0,
  iPv6_Address_byte_9 = 0,
  iPv6_Address_byte_10 = 0,
  iPv6_Address_byte_11 = 0,
  iPv6_Address_byte_12 = 0,
  iPv6_Address_byte_13 = 0,
  iPv6_Address_byte_14 = 0,
  iPv6_Address_byte_15 = 0}
data Host_Address = Host_Address  { host_Address_ipv4_address :: P.Maybe IPv4_Address
  , host_Address_ipv6_address :: P.Maybe IPv6_Address
  , host_Address_dns_name :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Host_Address where
  hashWithSalt salt record = salt   `H.hashWithSalt` host_Address_ipv4_address record   `H.hashWithSalt` host_Address_ipv6_address record   `H.hashWithSalt` host_Address_dns_name record  
instance QC.Arbitrary Host_Address where 
  arbitrary = M.liftM Host_Address (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Host_Address = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Host_Address{host_Address_ipv4_address = host_Address_ipv4_address obj} then P.Nothing else P.Just $ default_Host_Address{host_Address_ipv4_address = host_Address_ipv4_address obj}
    , if obj == default_Host_Address{host_Address_ipv6_address = host_Address_ipv6_address obj} then P.Nothing else P.Just $ default_Host_Address{host_Address_ipv6_address = host_Address_ipv6_address obj}
    , if obj == default_Host_Address{host_Address_dns_name = host_Address_dns_name obj} then P.Nothing else P.Just $ default_Host_Address{host_Address_dns_name = host_Address_dns_name obj}
    ]
from_Host_Address :: Host_Address -> T.ThriftVal
from_Host_Address record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v266 -> (1, ("ipv4_address",from_IPv4_Address _v266))) <$> host_Address_ipv4_address record
  , (\_v266 -> (2, ("ipv6_address",from_IPv6_Address _v266))) <$> host_Address_ipv6_address record
  , (\_v266 -> (3, ("dns_name",T.TString $ E.encodeUtf8 _v266))) <$> host_Address_dns_name record
  ]
write_Host_Address :: (T.Protocol p, T.Transport t) => p t -> Host_Address -> P.IO ()
write_Host_Address oprot record = T.writeVal oprot $ from_Host_Address record
encode_Host_Address :: (T.Protocol p, T.Transport t) => p t -> Host_Address -> LBS.ByteString
encode_Host_Address oprot record = T.serializeVal oprot $ from_Host_Address record
to_Host_Address :: T.ThriftVal -> Host_Address
to_Host_Address (T.TStruct fields) = Host_Address{
  host_Address_ipv4_address = P.maybe (P.Nothing) (\(_,_val268) -> P.Just (case _val268 of {T.TStruct _val269 -> (to_IPv4_Address (T.TStruct _val269)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  host_Address_ipv6_address = P.maybe (P.Nothing) (\(_,_val268) -> P.Just (case _val268 of {T.TStruct _val270 -> (to_IPv6_Address (T.TStruct _val270)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  host_Address_dns_name = P.maybe (P.Nothing) (\(_,_val268) -> P.Just (case _val268 of {T.TString _val271 -> E.decodeUtf8 _val271; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Host_Address _ = P.error "not a struct"
read_Host_Address :: (T.Transport t, T.Protocol p) => p t -> P.IO Host_Address
read_Host_Address iprot = to_Host_Address <$> T.readVal iprot (T.T_STRUCT typemap_Host_Address)
decode_Host_Address :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Host_Address
decode_Host_Address iprot bs = to_Host_Address $ T.deserializeVal iprot (T.T_STRUCT typemap_Host_Address) bs
typemap_Host_Address :: T.TypeMap
typemap_Host_Address = Map.fromList [(1,("ipv4_address",(T.T_STRUCT typemap_IPv4_Address))),(2,("ipv6_address",(T.T_STRUCT typemap_IPv6_Address))),(3,("dns_name",T.T_STRING))]
default_Host_Address :: Host_Address
default_Host_Address = Host_Address{
  host_Address_ipv4_address = P.Nothing,
  host_Address_ipv6_address = P.Nothing,
  host_Address_dns_name = P.Nothing}
data Address = Address  { address_host_address :: Host_Address
  , address_port_number :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Address where
  hashWithSalt salt record = salt   `H.hashWithSalt` address_host_address record   `H.hashWithSalt` address_port_number record  
instance QC.Arbitrary Address where 
  arbitrary = M.liftM Address (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Address = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Address{address_host_address = address_host_address obj} then P.Nothing else P.Just $ default_Address{address_host_address = address_host_address obj}
    , if obj == default_Address{address_port_number = address_port_number obj} then P.Nothing else P.Just $ default_Address{address_port_number = address_port_number obj}
    ]
from_Address :: Address -> T.ThriftVal
from_Address record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v274 -> P.Just (1, ("host_address",from_Host_Address _v274))) $ address_host_address record
  , (\_v274 -> P.Just (2, ("port_number",T.TI32 _v274))) $ address_port_number record
  ]
write_Address :: (T.Protocol p, T.Transport t) => p t -> Address -> P.IO ()
write_Address oprot record = T.writeVal oprot $ from_Address record
encode_Address :: (T.Protocol p, T.Transport t) => p t -> Address -> LBS.ByteString
encode_Address oprot record = T.serializeVal oprot $ from_Address record
to_Address :: T.ThriftVal -> Address
to_Address (T.TStruct fields) = Address{
  address_host_address = P.maybe (address_host_address default_Address) (\(_,_val276) -> (case _val276 of {T.TStruct _val277 -> (to_Host_Address (T.TStruct _val277)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  address_port_number = P.maybe (address_port_number default_Address) (\(_,_val276) -> (case _val276 of {T.TI32 _val278 -> _val278; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Address _ = P.error "not a struct"
read_Address :: (T.Transport t, T.Protocol p) => p t -> P.IO Address
read_Address iprot = to_Address <$> T.readVal iprot (T.T_STRUCT typemap_Address)
decode_Address :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Address
decode_Address iprot bs = to_Address $ T.deserializeVal iprot (T.T_STRUCT typemap_Address) bs
typemap_Address :: T.TypeMap
typemap_Address = Map.fromList [(1,("host_address",(T.T_STRUCT typemap_Host_Address))),(2,("port_number",T.T_I32))]
default_Address :: Address
default_Address = Address{
  address_host_address = default_Host_Address,
  address_port_number = 0}
data Invalid_Address = Invalid_Address  { invalid_Address_offending_address :: Address
  , invalid_Address_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Address
instance H.Hashable Invalid_Address where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Address_offending_address record   `H.hashWithSalt` invalid_Address_explanation record  
instance QC.Arbitrary Invalid_Address where 
  arbitrary = M.liftM Invalid_Address (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Address = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Address{invalid_Address_offending_address = invalid_Address_offending_address obj} then P.Nothing else P.Just $ default_Invalid_Address{invalid_Address_offending_address = invalid_Address_offending_address obj}
    , if obj == default_Invalid_Address{invalid_Address_explanation = invalid_Address_explanation obj} then P.Nothing else P.Just $ default_Invalid_Address{invalid_Address_explanation = invalid_Address_explanation obj}
    ]
from_Invalid_Address :: Invalid_Address -> T.ThriftVal
from_Invalid_Address record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v281 -> P.Just (1, ("offending_address",from_Address _v281))) $ invalid_Address_offending_address record
  , (\_v281 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v281))) <$> invalid_Address_explanation record
  ]
write_Invalid_Address :: (T.Protocol p, T.Transport t) => p t -> Invalid_Address -> P.IO ()
write_Invalid_Address oprot record = T.writeVal oprot $ from_Invalid_Address record
encode_Invalid_Address :: (T.Protocol p, T.Transport t) => p t -> Invalid_Address -> LBS.ByteString
encode_Invalid_Address oprot record = T.serializeVal oprot $ from_Invalid_Address record
to_Invalid_Address :: T.ThriftVal -> Invalid_Address
to_Invalid_Address (T.TStruct fields) = Invalid_Address{
  invalid_Address_offending_address = P.maybe (invalid_Address_offending_address default_Invalid_Address) (\(_,_val283) -> (case _val283 of {T.TStruct _val284 -> (to_Address (T.TStruct _val284)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Address_explanation = P.maybe (P.Nothing) (\(_,_val283) -> P.Just (case _val283 of {T.TString _val285 -> E.decodeUtf8 _val285; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Invalid_Address _ = P.error "not a struct"
read_Invalid_Address :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Address
read_Invalid_Address iprot = to_Invalid_Address <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Address)
decode_Invalid_Address :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Address
decode_Invalid_Address iprot bs = to_Invalid_Address $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Address) bs
typemap_Invalid_Address :: T.TypeMap
typemap_Invalid_Address = Map.fromList [(1,("offending_address",(T.T_STRUCT typemap_Address))),(3,("explanation",T.T_STRING))]
default_Invalid_Address :: Invalid_Address
default_Invalid_Address = Invalid_Address{
  invalid_Address_offending_address = default_Address,
  invalid_Address_explanation = P.Nothing}
data Participant_ID = Participant_ID  { participant_ID_address :: Address
  , participant_ID_crypto_id :: Crypto_ID
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Participant_ID where
  hashWithSalt salt record = salt   `H.hashWithSalt` participant_ID_address record   `H.hashWithSalt` participant_ID_crypto_id record  
instance QC.Arbitrary Participant_ID where 
  arbitrary = M.liftM Participant_ID (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Participant_ID = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Participant_ID{participant_ID_address = participant_ID_address obj} then P.Nothing else P.Just $ default_Participant_ID{participant_ID_address = participant_ID_address obj}
    , if obj == default_Participant_ID{participant_ID_crypto_id = participant_ID_crypto_id obj} then P.Nothing else P.Just $ default_Participant_ID{participant_ID_crypto_id = participant_ID_crypto_id obj}
    ]
from_Participant_ID :: Participant_ID -> T.ThriftVal
from_Participant_ID record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v288 -> P.Just (1, ("address",from_Address _v288))) $ participant_ID_address record
  , (\_v288 -> P.Just (2, ("crypto_id",from_Crypto_ID _v288))) $ participant_ID_crypto_id record
  ]
write_Participant_ID :: (T.Protocol p, T.Transport t) => p t -> Participant_ID -> P.IO ()
write_Participant_ID oprot record = T.writeVal oprot $ from_Participant_ID record
encode_Participant_ID :: (T.Protocol p, T.Transport t) => p t -> Participant_ID -> LBS.ByteString
encode_Participant_ID oprot record = T.serializeVal oprot $ from_Participant_ID record
to_Participant_ID :: T.ThriftVal -> Participant_ID
to_Participant_ID (T.TStruct fields) = Participant_ID{
  participant_ID_address = P.maybe (participant_ID_address default_Participant_ID) (\(_,_val290) -> (case _val290 of {T.TStruct _val291 -> (to_Address (T.TStruct _val291)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  participant_ID_crypto_id = P.maybe (participant_ID_crypto_id default_Participant_ID) (\(_,_val290) -> (case _val290 of {T.TStruct _val292 -> (to_Crypto_ID (T.TStruct _val292)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Participant_ID _ = P.error "not a struct"
read_Participant_ID :: (T.Transport t, T.Protocol p) => p t -> P.IO Participant_ID
read_Participant_ID iprot = to_Participant_ID <$> T.readVal iprot (T.T_STRUCT typemap_Participant_ID)
decode_Participant_ID :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Participant_ID
decode_Participant_ID iprot bs = to_Participant_ID $ T.deserializeVal iprot (T.T_STRUCT typemap_Participant_ID) bs
typemap_Participant_ID :: T.TypeMap
typemap_Participant_ID = Map.fromList [(1,("address",(T.T_STRUCT typemap_Address))),(2,("crypto_id",(T.T_STRUCT typemap_Crypto_ID)))]
default_Participant_ID :: Participant_ID
default_Participant_ID = Participant_ID{
  participant_ID_address = default_Address,
  participant_ID_crypto_id = default_Crypto_ID}
data Observer_Trust_Constraint = Observer_Trust_Constraint  { observer_Trust_Constraint_observer_1 :: Participant_ID
  , observer_Trust_Constraint_observer_2 :: Participant_ID
  , observer_Trust_Constraint_safe :: (Set.HashSet Participant_ID)
  , observer_Trust_Constraint_live :: (Set.HashSet Participant_ID)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Observer_Trust_Constraint where
  hashWithSalt salt record = salt   `H.hashWithSalt` observer_Trust_Constraint_observer_1 record   `H.hashWithSalt` observer_Trust_Constraint_observer_2 record   `H.hashWithSalt` observer_Trust_Constraint_safe record   `H.hashWithSalt` observer_Trust_Constraint_live record  
instance QC.Arbitrary Observer_Trust_Constraint where 
  arbitrary = M.liftM Observer_Trust_Constraint (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Observer_Trust_Constraint = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Observer_Trust_Constraint{observer_Trust_Constraint_observer_1 = observer_Trust_Constraint_observer_1 obj} then P.Nothing else P.Just $ default_Observer_Trust_Constraint{observer_Trust_Constraint_observer_1 = observer_Trust_Constraint_observer_1 obj}
    , if obj == default_Observer_Trust_Constraint{observer_Trust_Constraint_observer_2 = observer_Trust_Constraint_observer_2 obj} then P.Nothing else P.Just $ default_Observer_Trust_Constraint{observer_Trust_Constraint_observer_2 = observer_Trust_Constraint_observer_2 obj}
    , if obj == default_Observer_Trust_Constraint{observer_Trust_Constraint_safe = observer_Trust_Constraint_safe obj} then P.Nothing else P.Just $ default_Observer_Trust_Constraint{observer_Trust_Constraint_safe = observer_Trust_Constraint_safe obj}
    , if obj == default_Observer_Trust_Constraint{observer_Trust_Constraint_live = observer_Trust_Constraint_live obj} then P.Nothing else P.Just $ default_Observer_Trust_Constraint{observer_Trust_Constraint_live = observer_Trust_Constraint_live obj}
    ]
from_Observer_Trust_Constraint :: Observer_Trust_Constraint -> T.ThriftVal
from_Observer_Trust_Constraint record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v295 -> P.Just (1, ("observer_1",from_Participant_ID _v295))) $ observer_Trust_Constraint_observer_1 record
  , (\_v295 -> P.Just (2, ("observer_2",from_Participant_ID _v295))) $ observer_Trust_Constraint_observer_2 record
  , (\_v295 -> P.Just (3, ("safe",T.TSet (T.T_STRUCT typemap_Participant_ID) $ P.map (\_v297 -> from_Participant_ID _v297) $ Set.toList _v295))) $ observer_Trust_Constraint_safe record
  , (\_v295 -> P.Just (4, ("live",T.TSet (T.T_STRUCT typemap_Participant_ID) $ P.map (\_v299 -> from_Participant_ID _v299) $ Set.toList _v295))) $ observer_Trust_Constraint_live record
  ]
write_Observer_Trust_Constraint :: (T.Protocol p, T.Transport t) => p t -> Observer_Trust_Constraint -> P.IO ()
write_Observer_Trust_Constraint oprot record = T.writeVal oprot $ from_Observer_Trust_Constraint record
encode_Observer_Trust_Constraint :: (T.Protocol p, T.Transport t) => p t -> Observer_Trust_Constraint -> LBS.ByteString
encode_Observer_Trust_Constraint oprot record = T.serializeVal oprot $ from_Observer_Trust_Constraint record
to_Observer_Trust_Constraint :: T.ThriftVal -> Observer_Trust_Constraint
to_Observer_Trust_Constraint (T.TStruct fields) = Observer_Trust_Constraint{
  observer_Trust_Constraint_observer_1 = P.maybe (observer_Trust_Constraint_observer_1 default_Observer_Trust_Constraint) (\(_,_val301) -> (case _val301 of {T.TStruct _val302 -> (to_Participant_ID (T.TStruct _val302)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  observer_Trust_Constraint_observer_2 = P.maybe (observer_Trust_Constraint_observer_2 default_Observer_Trust_Constraint) (\(_,_val301) -> (case _val301 of {T.TStruct _val303 -> (to_Participant_ID (T.TStruct _val303)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  observer_Trust_Constraint_safe = P.maybe (observer_Trust_Constraint_safe default_Observer_Trust_Constraint) (\(_,_val301) -> (case _val301 of {T.TSet _ _val304 -> (Set.fromList $ P.map (\_v305 -> (case _v305 of {T.TStruct _val306 -> (to_Participant_ID (T.TStruct _val306)); _ -> P.error "wrong type"})) _val304); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  observer_Trust_Constraint_live = P.maybe (observer_Trust_Constraint_live default_Observer_Trust_Constraint) (\(_,_val301) -> (case _val301 of {T.TSet _ _val307 -> (Set.fromList $ P.map (\_v308 -> (case _v308 of {T.TStruct _val309 -> (to_Participant_ID (T.TStruct _val309)); _ -> P.error "wrong type"})) _val307); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Observer_Trust_Constraint _ = P.error "not a struct"
read_Observer_Trust_Constraint :: (T.Transport t, T.Protocol p) => p t -> P.IO Observer_Trust_Constraint
read_Observer_Trust_Constraint iprot = to_Observer_Trust_Constraint <$> T.readVal iprot (T.T_STRUCT typemap_Observer_Trust_Constraint)
decode_Observer_Trust_Constraint :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Observer_Trust_Constraint
decode_Observer_Trust_Constraint iprot bs = to_Observer_Trust_Constraint $ T.deserializeVal iprot (T.T_STRUCT typemap_Observer_Trust_Constraint) bs
typemap_Observer_Trust_Constraint :: T.TypeMap
typemap_Observer_Trust_Constraint = Map.fromList [(1,("observer_1",(T.T_STRUCT typemap_Participant_ID))),(2,("observer_2",(T.T_STRUCT typemap_Participant_ID))),(3,("safe",(T.T_SET (T.T_STRUCT typemap_Participant_ID)))),(4,("live",(T.T_SET (T.T_STRUCT typemap_Participant_ID))))]
default_Observer_Trust_Constraint :: Observer_Trust_Constraint
default_Observer_Trust_Constraint = Observer_Trust_Constraint{
  observer_Trust_Constraint_observer_1 = default_Participant_ID,
  observer_Trust_Constraint_observer_2 = default_Participant_ID,
  observer_Trust_Constraint_safe = Set.empty,
  observer_Trust_Constraint_live = Set.empty}
data Impossible_Observer_Graph = Impossible_Observer_Graph  { impossible_Observer_Graph_offending_observer_graph :: (Set.HashSet Observer_Trust_Constraint)
  , impossible_Observer_Graph_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Impossible_Observer_Graph
instance H.Hashable Impossible_Observer_Graph where
  hashWithSalt salt record = salt   `H.hashWithSalt` impossible_Observer_Graph_offending_observer_graph record   `H.hashWithSalt` impossible_Observer_Graph_explanation record  
instance QC.Arbitrary Impossible_Observer_Graph where 
  arbitrary = M.liftM Impossible_Observer_Graph (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Impossible_Observer_Graph = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Impossible_Observer_Graph{impossible_Observer_Graph_offending_observer_graph = impossible_Observer_Graph_offending_observer_graph obj} then P.Nothing else P.Just $ default_Impossible_Observer_Graph{impossible_Observer_Graph_offending_observer_graph = impossible_Observer_Graph_offending_observer_graph obj}
    , if obj == default_Impossible_Observer_Graph{impossible_Observer_Graph_explanation = impossible_Observer_Graph_explanation obj} then P.Nothing else P.Just $ default_Impossible_Observer_Graph{impossible_Observer_Graph_explanation = impossible_Observer_Graph_explanation obj}
    ]
from_Impossible_Observer_Graph :: Impossible_Observer_Graph -> T.ThriftVal
from_Impossible_Observer_Graph record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v312 -> P.Just (1, ("offending_observer_graph",T.TSet (T.T_STRUCT typemap_Observer_Trust_Constraint) $ P.map (\_v314 -> from_Observer_Trust_Constraint _v314) $ Set.toList _v312))) $ impossible_Observer_Graph_offending_observer_graph record
  , (\_v312 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v312))) <$> impossible_Observer_Graph_explanation record
  ]
write_Impossible_Observer_Graph :: (T.Protocol p, T.Transport t) => p t -> Impossible_Observer_Graph -> P.IO ()
write_Impossible_Observer_Graph oprot record = T.writeVal oprot $ from_Impossible_Observer_Graph record
encode_Impossible_Observer_Graph :: (T.Protocol p, T.Transport t) => p t -> Impossible_Observer_Graph -> LBS.ByteString
encode_Impossible_Observer_Graph oprot record = T.serializeVal oprot $ from_Impossible_Observer_Graph record
to_Impossible_Observer_Graph :: T.ThriftVal -> Impossible_Observer_Graph
to_Impossible_Observer_Graph (T.TStruct fields) = Impossible_Observer_Graph{
  impossible_Observer_Graph_offending_observer_graph = P.maybe (impossible_Observer_Graph_offending_observer_graph default_Impossible_Observer_Graph) (\(_,_val316) -> (case _val316 of {T.TSet _ _val317 -> (Set.fromList $ P.map (\_v318 -> (case _v318 of {T.TStruct _val319 -> (to_Observer_Trust_Constraint (T.TStruct _val319)); _ -> P.error "wrong type"})) _val317); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  impossible_Observer_Graph_explanation = P.maybe (P.Nothing) (\(_,_val316) -> P.Just (case _val316 of {T.TString _val320 -> E.decodeUtf8 _val320; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Impossible_Observer_Graph _ = P.error "not a struct"
read_Impossible_Observer_Graph :: (T.Transport t, T.Protocol p) => p t -> P.IO Impossible_Observer_Graph
read_Impossible_Observer_Graph iprot = to_Impossible_Observer_Graph <$> T.readVal iprot (T.T_STRUCT typemap_Impossible_Observer_Graph)
decode_Impossible_Observer_Graph :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Impossible_Observer_Graph
decode_Impossible_Observer_Graph iprot bs = to_Impossible_Observer_Graph $ T.deserializeVal iprot (T.T_STRUCT typemap_Impossible_Observer_Graph) bs
typemap_Impossible_Observer_Graph :: T.TypeMap
typemap_Impossible_Observer_Graph = Map.fromList [(1,("offending_observer_graph",(T.T_SET (T.T_STRUCT typemap_Observer_Trust_Constraint)))),(3,("explanation",T.T_STRING))]
default_Impossible_Observer_Graph :: Impossible_Observer_Graph
default_Impossible_Observer_Graph = Impossible_Observer_Graph{
  impossible_Observer_Graph_offending_observer_graph = Set.empty,
  impossible_Observer_Graph_explanation = P.Nothing}
data Observers = Observers  { observers_observer_graph :: P.Maybe (Set.HashSet Observer_Trust_Constraint)
  , observers_observer_quorums :: P.Maybe (Map.HashMap Participant_ID (Set.HashSet (Set.HashSet Participant_ID)))
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Observers where
  hashWithSalt salt record = salt   `H.hashWithSalt` observers_observer_graph record   `H.hashWithSalt` observers_observer_quorums record  
instance QC.Arbitrary Observers where 
  arbitrary = M.liftM Observers (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Observers = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Observers{observers_observer_graph = observers_observer_graph obj} then P.Nothing else P.Just $ default_Observers{observers_observer_graph = observers_observer_graph obj}
    , if obj == default_Observers{observers_observer_quorums = observers_observer_quorums obj} then P.Nothing else P.Just $ default_Observers{observers_observer_quorums = observers_observer_quorums obj}
    ]
from_Observers :: Observers -> T.ThriftVal
from_Observers record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v323 -> (1, ("observer_graph",T.TSet (T.T_STRUCT typemap_Observer_Trust_Constraint) $ P.map (\_v325 -> from_Observer_Trust_Constraint _v325) $ Set.toList _v323))) <$> observers_observer_graph record
  , (\_v323 -> (2, ("observer_quorums",T.TMap (T.T_STRUCT typemap_Participant_ID) (T.T_SET (T.T_SET (T.T_STRUCT typemap_Participant_ID))) $ P.map (\(_k326,_v327) -> (from_Participant_ID _k326, T.TSet (T.T_SET (T.T_STRUCT typemap_Participant_ID)) $ P.map (\_v329 -> T.TSet (T.T_STRUCT typemap_Participant_ID) $ P.map (\_v331 -> from_Participant_ID _v331) $ Set.toList _v329) $ Set.toList _v327)) $ Map.toList _v323))) <$> observers_observer_quorums record
  ]
write_Observers :: (T.Protocol p, T.Transport t) => p t -> Observers -> P.IO ()
write_Observers oprot record = T.writeVal oprot $ from_Observers record
encode_Observers :: (T.Protocol p, T.Transport t) => p t -> Observers -> LBS.ByteString
encode_Observers oprot record = T.serializeVal oprot $ from_Observers record
to_Observers :: T.ThriftVal -> Observers
to_Observers (T.TStruct fields) = Observers{
  observers_observer_graph = P.maybe (P.Nothing) (\(_,_val333) -> P.Just (case _val333 of {T.TSet _ _val334 -> (Set.fromList $ P.map (\_v335 -> (case _v335 of {T.TStruct _val336 -> (to_Observer_Trust_Constraint (T.TStruct _val336)); _ -> P.error "wrong type"})) _val334); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  observers_observer_quorums = P.maybe (P.Nothing) (\(_,_val333) -> P.Just (case _val333 of {T.TMap _ _ _val337 -> (Map.fromList $ P.map (\(_k339,_v338) -> ((case _k339 of {T.TStruct _val340 -> (to_Participant_ID (T.TStruct _val340)); _ -> P.error "wrong type"}),(case _v338 of {T.TSet _ _val341 -> (Set.fromList $ P.map (\_v342 -> (case _v342 of {T.TSet _ _val343 -> (Set.fromList $ P.map (\_v344 -> (case _v344 of {T.TStruct _val345 -> (to_Participant_ID (T.TStruct _val345)); _ -> P.error "wrong type"})) _val343); _ -> P.error "wrong type"})) _val341); _ -> P.error "wrong type"}))) _val337); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Observers _ = P.error "not a struct"
read_Observers :: (T.Transport t, T.Protocol p) => p t -> P.IO Observers
read_Observers iprot = to_Observers <$> T.readVal iprot (T.T_STRUCT typemap_Observers)
decode_Observers :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Observers
decode_Observers iprot bs = to_Observers $ T.deserializeVal iprot (T.T_STRUCT typemap_Observers) bs
typemap_Observers :: T.TypeMap
typemap_Observers = Map.fromList [(1,("observer_graph",(T.T_SET (T.T_STRUCT typemap_Observer_Trust_Constraint)))),(2,("observer_quorums",(T.T_MAP (T.T_STRUCT typemap_Participant_ID) (T.T_SET (T.T_SET (T.T_STRUCT typemap_Participant_ID))))))]
default_Observers :: Observers
default_Observers = Observers{
  observers_observer_graph = P.Nothing,
  observers_observer_quorums = P.Nothing}
data Slot_Value = Slot_Value  { slot_Value_value_payload :: LBS.ByteString
  , slot_Value_slot :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Slot_Value where
  hashWithSalt salt record = salt   `H.hashWithSalt` slot_Value_value_payload record   `H.hashWithSalt` slot_Value_slot record  
instance QC.Arbitrary Slot_Value where 
  arbitrary = M.liftM Slot_Value (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Slot_Value = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Slot_Value{slot_Value_value_payload = slot_Value_value_payload obj} then P.Nothing else P.Just $ default_Slot_Value{slot_Value_value_payload = slot_Value_value_payload obj}
    , if obj == default_Slot_Value{slot_Value_slot = slot_Value_slot obj} then P.Nothing else P.Just $ default_Slot_Value{slot_Value_slot = slot_Value_slot obj}
    ]
from_Slot_Value :: Slot_Value -> T.ThriftVal
from_Slot_Value record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v348 -> P.Just (1, ("value_payload",T.TBinary _v348))) $ slot_Value_value_payload record
  , (\_v348 -> P.Just (2, ("slot",T.TI64 _v348))) $ slot_Value_slot record
  ]
write_Slot_Value :: (T.Protocol p, T.Transport t) => p t -> Slot_Value -> P.IO ()
write_Slot_Value oprot record = T.writeVal oprot $ from_Slot_Value record
encode_Slot_Value :: (T.Protocol p, T.Transport t) => p t -> Slot_Value -> LBS.ByteString
encode_Slot_Value oprot record = T.serializeVal oprot $ from_Slot_Value record
to_Slot_Value :: T.ThriftVal -> Slot_Value
to_Slot_Value (T.TStruct fields) = Slot_Value{
  slot_Value_value_payload = P.maybe (slot_Value_value_payload default_Slot_Value) (\(_,_val350) -> (case _val350 of {T.TBinary _val351 -> _val351; T.TString _val351 -> _val351; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  slot_Value_slot = P.maybe (slot_Value_slot default_Slot_Value) (\(_,_val350) -> (case _val350 of {T.TI64 _val352 -> _val352; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Slot_Value _ = P.error "not a struct"
read_Slot_Value :: (T.Transport t, T.Protocol p) => p t -> P.IO Slot_Value
read_Slot_Value iprot = to_Slot_Value <$> T.readVal iprot (T.T_STRUCT typemap_Slot_Value)
decode_Slot_Value :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Slot_Value
decode_Slot_Value iprot bs = to_Slot_Value $ T.deserializeVal iprot (T.T_STRUCT typemap_Slot_Value) bs
typemap_Slot_Value :: T.TypeMap
typemap_Slot_Value = Map.fromList [(1,("value_payload",T.T_BINARY)),(2,("slot",T.T_I64))]
default_Slot_Value :: Slot_Value
default_Slot_Value = Slot_Value{
  slot_Value_value_payload = "",
  slot_Value_slot = 0}
data Proposal_1a = Proposal_1a  { proposal_1a_value :: LBS.ByteString
  , proposal_1a_timestamp :: I.Int64
  , proposal_1a_observers :: P.Maybe Observers
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Proposal_1a where
  hashWithSalt salt record = salt   `H.hashWithSalt` proposal_1a_value record   `H.hashWithSalt` proposal_1a_timestamp record   `H.hashWithSalt` proposal_1a_observers record  
instance QC.Arbitrary Proposal_1a where 
  arbitrary = M.liftM Proposal_1a (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Proposal_1a = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Proposal_1a{proposal_1a_value = proposal_1a_value obj} then P.Nothing else P.Just $ default_Proposal_1a{proposal_1a_value = proposal_1a_value obj}
    , if obj == default_Proposal_1a{proposal_1a_timestamp = proposal_1a_timestamp obj} then P.Nothing else P.Just $ default_Proposal_1a{proposal_1a_timestamp = proposal_1a_timestamp obj}
    , if obj == default_Proposal_1a{proposal_1a_observers = proposal_1a_observers obj} then P.Nothing else P.Just $ default_Proposal_1a{proposal_1a_observers = proposal_1a_observers obj}
    ]
from_Proposal_1a :: Proposal_1a -> T.ThriftVal
from_Proposal_1a record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v355 -> P.Just (1, ("value",T.TBinary _v355))) $ proposal_1a_value record
  , (\_v355 -> P.Just (2, ("timestamp",T.TI64 _v355))) $ proposal_1a_timestamp record
  , (\_v355 -> (3, ("observers",from_Observers _v355))) <$> proposal_1a_observers record
  ]
write_Proposal_1a :: (T.Protocol p, T.Transport t) => p t -> Proposal_1a -> P.IO ()
write_Proposal_1a oprot record = T.writeVal oprot $ from_Proposal_1a record
encode_Proposal_1a :: (T.Protocol p, T.Transport t) => p t -> Proposal_1a -> LBS.ByteString
encode_Proposal_1a oprot record = T.serializeVal oprot $ from_Proposal_1a record
to_Proposal_1a :: T.ThriftVal -> Proposal_1a
to_Proposal_1a (T.TStruct fields) = Proposal_1a{
  proposal_1a_value = P.maybe (proposal_1a_value default_Proposal_1a) (\(_,_val357) -> (case _val357 of {T.TBinary _val358 -> _val358; T.TString _val358 -> _val358; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  proposal_1a_timestamp = P.maybe (proposal_1a_timestamp default_Proposal_1a) (\(_,_val357) -> (case _val357 of {T.TI64 _val359 -> _val359; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  proposal_1a_observers = P.maybe (P.Nothing) (\(_,_val357) -> P.Just (case _val357 of {T.TStruct _val360 -> (to_Observers (T.TStruct _val360)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Proposal_1a _ = P.error "not a struct"
read_Proposal_1a :: (T.Transport t, T.Protocol p) => p t -> P.IO Proposal_1a
read_Proposal_1a iprot = to_Proposal_1a <$> T.readVal iprot (T.T_STRUCT typemap_Proposal_1a)
decode_Proposal_1a :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Proposal_1a
decode_Proposal_1a iprot bs = to_Proposal_1a $ T.deserializeVal iprot (T.T_STRUCT typemap_Proposal_1a) bs
typemap_Proposal_1a :: T.TypeMap
typemap_Proposal_1a = Map.fromList [(1,("value",T.T_BINARY)),(2,("timestamp",T.T_I64)),(3,("observers",(T.T_STRUCT typemap_Observers)))]
default_Proposal_1a :: Proposal_1a
default_Proposal_1a = Proposal_1a{
  proposal_1a_value = "",
  proposal_1a_timestamp = 0,
  proposal_1a_observers = P.Nothing}
data Invalid_Proposal_1a = Invalid_Proposal_1a  { invalid_Proposal_1a_offending_proposal :: Proposal_1a
  , invalid_Proposal_1a_explanation :: P.Maybe LT.Text
  , invalid_Proposal_1a_offending_witness :: P.Maybe LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Proposal_1a
instance H.Hashable Invalid_Proposal_1a where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Proposal_1a_offending_proposal record   `H.hashWithSalt` invalid_Proposal_1a_explanation record   `H.hashWithSalt` invalid_Proposal_1a_offending_witness record  
instance QC.Arbitrary Invalid_Proposal_1a where 
  arbitrary = M.liftM Invalid_Proposal_1a (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Proposal_1a = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Proposal_1a{invalid_Proposal_1a_offending_proposal = invalid_Proposal_1a_offending_proposal obj} then P.Nothing else P.Just $ default_Invalid_Proposal_1a{invalid_Proposal_1a_offending_proposal = invalid_Proposal_1a_offending_proposal obj}
    , if obj == default_Invalid_Proposal_1a{invalid_Proposal_1a_explanation = invalid_Proposal_1a_explanation obj} then P.Nothing else P.Just $ default_Invalid_Proposal_1a{invalid_Proposal_1a_explanation = invalid_Proposal_1a_explanation obj}
    , if obj == default_Invalid_Proposal_1a{invalid_Proposal_1a_offending_witness = invalid_Proposal_1a_offending_witness obj} then P.Nothing else P.Just $ default_Invalid_Proposal_1a{invalid_Proposal_1a_offending_witness = invalid_Proposal_1a_offending_witness obj}
    ]
from_Invalid_Proposal_1a :: Invalid_Proposal_1a -> T.ThriftVal
from_Invalid_Proposal_1a record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v363 -> P.Just (1, ("offending_proposal",from_Proposal_1a _v363))) $ invalid_Proposal_1a_offending_proposal record
  , (\_v363 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v363))) <$> invalid_Proposal_1a_explanation record
  , (\_v363 -> (4, ("offending_witness",T.TBinary _v363))) <$> invalid_Proposal_1a_offending_witness record
  ]
write_Invalid_Proposal_1a :: (T.Protocol p, T.Transport t) => p t -> Invalid_Proposal_1a -> P.IO ()
write_Invalid_Proposal_1a oprot record = T.writeVal oprot $ from_Invalid_Proposal_1a record
encode_Invalid_Proposal_1a :: (T.Protocol p, T.Transport t) => p t -> Invalid_Proposal_1a -> LBS.ByteString
encode_Invalid_Proposal_1a oprot record = T.serializeVal oprot $ from_Invalid_Proposal_1a record
to_Invalid_Proposal_1a :: T.ThriftVal -> Invalid_Proposal_1a
to_Invalid_Proposal_1a (T.TStruct fields) = Invalid_Proposal_1a{
  invalid_Proposal_1a_offending_proposal = P.maybe (invalid_Proposal_1a_offending_proposal default_Invalid_Proposal_1a) (\(_,_val365) -> (case _val365 of {T.TStruct _val366 -> (to_Proposal_1a (T.TStruct _val366)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Proposal_1a_explanation = P.maybe (P.Nothing) (\(_,_val365) -> P.Just (case _val365 of {T.TString _val367 -> E.decodeUtf8 _val367; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  invalid_Proposal_1a_offending_witness = P.maybe (P.Nothing) (\(_,_val365) -> P.Just (case _val365 of {T.TBinary _val368 -> _val368; T.TString _val368 -> _val368; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Invalid_Proposal_1a _ = P.error "not a struct"
read_Invalid_Proposal_1a :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Proposal_1a
read_Invalid_Proposal_1a iprot = to_Invalid_Proposal_1a <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Proposal_1a)
decode_Invalid_Proposal_1a :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Proposal_1a
decode_Invalid_Proposal_1a iprot bs = to_Invalid_Proposal_1a $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Proposal_1a) bs
typemap_Invalid_Proposal_1a :: T.TypeMap
typemap_Invalid_Proposal_1a = Map.fromList [(1,("offending_proposal",(T.T_STRUCT typemap_Proposal_1a))),(3,("explanation",T.T_STRING)),(4,("offending_witness",T.T_BINARY))]
default_Invalid_Proposal_1a :: Invalid_Proposal_1a
default_Invalid_Proposal_1a = Invalid_Proposal_1a{
  invalid_Proposal_1a_offending_proposal = default_Proposal_1a,
  invalid_Proposal_1a_explanation = P.Nothing,
  invalid_Proposal_1a_offending_witness = P.Nothing}
data Phase_2a = Phase_2a  { phase_2a_phase_1bs :: (Set.HashSet Signed_Message)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Phase_2a where
  hashWithSalt salt record = salt   `H.hashWithSalt` phase_2a_phase_1bs record  
instance QC.Arbitrary Phase_2a where 
  arbitrary = M.liftM Phase_2a (QC.arbitrary)
  shrink obj | obj == default_Phase_2a = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Phase_2a{phase_2a_phase_1bs = phase_2a_phase_1bs obj} then P.Nothing else P.Just $ default_Phase_2a{phase_2a_phase_1bs = phase_2a_phase_1bs obj}
    ]
from_Phase_2a :: Phase_2a -> T.ThriftVal
from_Phase_2a record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v371 -> P.Just (1, ("phase_1bs",T.TSet (T.T_STRUCT typemap_Signed_Message) $ P.map (\_v373 -> from_Signed_Message _v373) $ Set.toList _v371))) $ phase_2a_phase_1bs record
  ]
write_Phase_2a :: (T.Protocol p, T.Transport t) => p t -> Phase_2a -> P.IO ()
write_Phase_2a oprot record = T.writeVal oprot $ from_Phase_2a record
encode_Phase_2a :: (T.Protocol p, T.Transport t) => p t -> Phase_2a -> LBS.ByteString
encode_Phase_2a oprot record = T.serializeVal oprot $ from_Phase_2a record
to_Phase_2a :: T.ThriftVal -> Phase_2a
to_Phase_2a (T.TStruct fields) = Phase_2a{
  phase_2a_phase_1bs = P.maybe (phase_2a_phase_1bs default_Phase_2a) (\(_,_val375) -> (case _val375 of {T.TSet _ _val376 -> (Set.fromList $ P.map (\_v377 -> (case _v377 of {T.TStruct _val378 -> (to_Signed_Message (T.TStruct _val378)); _ -> P.error "wrong type"})) _val376); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Phase_2a _ = P.error "not a struct"
read_Phase_2a :: (T.Transport t, T.Protocol p) => p t -> P.IO Phase_2a
read_Phase_2a iprot = to_Phase_2a <$> T.readVal iprot (T.T_STRUCT typemap_Phase_2a)
decode_Phase_2a :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Phase_2a
decode_Phase_2a iprot bs = to_Phase_2a $ T.deserializeVal iprot (T.T_STRUCT typemap_Phase_2a) bs
typemap_Phase_2a :: T.TypeMap
typemap_Phase_2a = Map.fromList [(1,("phase_1bs",(T.T_SET (T.T_STRUCT typemap_Signed_Message))))]
default_Phase_2a :: Phase_2a
default_Phase_2a = Phase_2a{
  phase_2a_phase_1bs = Set.empty}
data Invalid_Phase_2a = Invalid_Phase_2a  { invalid_Phase_2a_offending_phase_2a :: Phase_2a
  , invalid_Phase_2a_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Phase_2a
instance H.Hashable Invalid_Phase_2a where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Phase_2a_offending_phase_2a record   `H.hashWithSalt` invalid_Phase_2a_explanation record  
instance QC.Arbitrary Invalid_Phase_2a where 
  arbitrary = M.liftM Invalid_Phase_2a (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Phase_2a = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Phase_2a{invalid_Phase_2a_offending_phase_2a = invalid_Phase_2a_offending_phase_2a obj} then P.Nothing else P.Just $ default_Invalid_Phase_2a{invalid_Phase_2a_offending_phase_2a = invalid_Phase_2a_offending_phase_2a obj}
    , if obj == default_Invalid_Phase_2a{invalid_Phase_2a_explanation = invalid_Phase_2a_explanation obj} then P.Nothing else P.Just $ default_Invalid_Phase_2a{invalid_Phase_2a_explanation = invalid_Phase_2a_explanation obj}
    ]
from_Invalid_Phase_2a :: Invalid_Phase_2a -> T.ThriftVal
from_Invalid_Phase_2a record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v381 -> P.Just (1, ("offending_phase_2a",from_Phase_2a _v381))) $ invalid_Phase_2a_offending_phase_2a record
  , (\_v381 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v381))) <$> invalid_Phase_2a_explanation record
  ]
write_Invalid_Phase_2a :: (T.Protocol p, T.Transport t) => p t -> Invalid_Phase_2a -> P.IO ()
write_Invalid_Phase_2a oprot record = T.writeVal oprot $ from_Invalid_Phase_2a record
encode_Invalid_Phase_2a :: (T.Protocol p, T.Transport t) => p t -> Invalid_Phase_2a -> LBS.ByteString
encode_Invalid_Phase_2a oprot record = T.serializeVal oprot $ from_Invalid_Phase_2a record
to_Invalid_Phase_2a :: T.ThriftVal -> Invalid_Phase_2a
to_Invalid_Phase_2a (T.TStruct fields) = Invalid_Phase_2a{
  invalid_Phase_2a_offending_phase_2a = P.maybe (invalid_Phase_2a_offending_phase_2a default_Invalid_Phase_2a) (\(_,_val383) -> (case _val383 of {T.TStruct _val384 -> (to_Phase_2a (T.TStruct _val384)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Phase_2a_explanation = P.maybe (P.Nothing) (\(_,_val383) -> P.Just (case _val383 of {T.TString _val385 -> E.decodeUtf8 _val385; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Invalid_Phase_2a _ = P.error "not a struct"
read_Invalid_Phase_2a :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Phase_2a
read_Invalid_Phase_2a iprot = to_Invalid_Phase_2a <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Phase_2a)
decode_Invalid_Phase_2a :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Phase_2a
decode_Invalid_Phase_2a iprot bs = to_Invalid_Phase_2a $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Phase_2a) bs
typemap_Invalid_Phase_2a :: T.TypeMap
typemap_Invalid_Phase_2a = Map.fromList [(1,("offending_phase_2a",(T.T_STRUCT typemap_Phase_2a))),(3,("explanation",T.T_STRING))]
default_Invalid_Phase_2a :: Invalid_Phase_2a
default_Invalid_Phase_2a = Invalid_Phase_2a{
  invalid_Phase_2a_offending_phase_2a = default_Phase_2a,
  invalid_Phase_2a_explanation = P.Nothing}
data Phase_1b = Phase_1b  { phase_1b_proposal :: Signed_Message
  , phase_1b_conflicting_phase2as :: (Set.HashSet Signed_Message)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Phase_1b where
  hashWithSalt salt record = salt   `H.hashWithSalt` phase_1b_proposal record   `H.hashWithSalt` phase_1b_conflicting_phase2as record  
instance QC.Arbitrary Phase_1b where 
  arbitrary = M.liftM Phase_1b (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Phase_1b = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Phase_1b{phase_1b_proposal = phase_1b_proposal obj} then P.Nothing else P.Just $ default_Phase_1b{phase_1b_proposal = phase_1b_proposal obj}
    , if obj == default_Phase_1b{phase_1b_conflicting_phase2as = phase_1b_conflicting_phase2as obj} then P.Nothing else P.Just $ default_Phase_1b{phase_1b_conflicting_phase2as = phase_1b_conflicting_phase2as obj}
    ]
from_Phase_1b :: Phase_1b -> T.ThriftVal
from_Phase_1b record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v388 -> P.Just (1, ("proposal",from_Signed_Message _v388))) $ phase_1b_proposal record
  , (\_v388 -> P.Just (2, ("conflicting_phase2as",T.TSet (T.T_STRUCT typemap_Signed_Message) $ P.map (\_v390 -> from_Signed_Message _v390) $ Set.toList _v388))) $ phase_1b_conflicting_phase2as record
  ]
write_Phase_1b :: (T.Protocol p, T.Transport t) => p t -> Phase_1b -> P.IO ()
write_Phase_1b oprot record = T.writeVal oprot $ from_Phase_1b record
encode_Phase_1b :: (T.Protocol p, T.Transport t) => p t -> Phase_1b -> LBS.ByteString
encode_Phase_1b oprot record = T.serializeVal oprot $ from_Phase_1b record
to_Phase_1b :: T.ThriftVal -> Phase_1b
to_Phase_1b (T.TStruct fields) = Phase_1b{
  phase_1b_proposal = P.maybe (phase_1b_proposal default_Phase_1b) (\(_,_val392) -> (case _val392 of {T.TStruct _val393 -> (to_Signed_Message (T.TStruct _val393)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  phase_1b_conflicting_phase2as = P.maybe (phase_1b_conflicting_phase2as default_Phase_1b) (\(_,_val392) -> (case _val392 of {T.TSet _ _val394 -> (Set.fromList $ P.map (\_v395 -> (case _v395 of {T.TStruct _val396 -> (to_Signed_Message (T.TStruct _val396)); _ -> P.error "wrong type"})) _val394); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Phase_1b _ = P.error "not a struct"
read_Phase_1b :: (T.Transport t, T.Protocol p) => p t -> P.IO Phase_1b
read_Phase_1b iprot = to_Phase_1b <$> T.readVal iprot (T.T_STRUCT typemap_Phase_1b)
decode_Phase_1b :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Phase_1b
decode_Phase_1b iprot bs = to_Phase_1b $ T.deserializeVal iprot (T.T_STRUCT typemap_Phase_1b) bs
typemap_Phase_1b :: T.TypeMap
typemap_Phase_1b = Map.fromList [(1,("proposal",(T.T_STRUCT typemap_Signed_Message))),(2,("conflicting_phase2as",(T.T_SET (T.T_STRUCT typemap_Signed_Message))))]
default_Phase_1b :: Phase_1b
default_Phase_1b = Phase_1b{
  phase_1b_proposal = default_Signed_Message,
  phase_1b_conflicting_phase2as = Set.empty}
data Invalid_Phase_1b = Invalid_Phase_1b  { invalid_Phase_1b_offending_phase_1b :: Phase_1b
  , invalid_Phase_1b_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Phase_1b
instance H.Hashable Invalid_Phase_1b where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Phase_1b_offending_phase_1b record   `H.hashWithSalt` invalid_Phase_1b_explanation record  
instance QC.Arbitrary Invalid_Phase_1b where 
  arbitrary = M.liftM Invalid_Phase_1b (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Phase_1b = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Phase_1b{invalid_Phase_1b_offending_phase_1b = invalid_Phase_1b_offending_phase_1b obj} then P.Nothing else P.Just $ default_Invalid_Phase_1b{invalid_Phase_1b_offending_phase_1b = invalid_Phase_1b_offending_phase_1b obj}
    , if obj == default_Invalid_Phase_1b{invalid_Phase_1b_explanation = invalid_Phase_1b_explanation obj} then P.Nothing else P.Just $ default_Invalid_Phase_1b{invalid_Phase_1b_explanation = invalid_Phase_1b_explanation obj}
    ]
from_Invalid_Phase_1b :: Invalid_Phase_1b -> T.ThriftVal
from_Invalid_Phase_1b record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v399 -> P.Just (1, ("offending_phase_1b",from_Phase_1b _v399))) $ invalid_Phase_1b_offending_phase_1b record
  , (\_v399 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v399))) <$> invalid_Phase_1b_explanation record
  ]
write_Invalid_Phase_1b :: (T.Protocol p, T.Transport t) => p t -> Invalid_Phase_1b -> P.IO ()
write_Invalid_Phase_1b oprot record = T.writeVal oprot $ from_Invalid_Phase_1b record
encode_Invalid_Phase_1b :: (T.Protocol p, T.Transport t) => p t -> Invalid_Phase_1b -> LBS.ByteString
encode_Invalid_Phase_1b oprot record = T.serializeVal oprot $ from_Invalid_Phase_1b record
to_Invalid_Phase_1b :: T.ThriftVal -> Invalid_Phase_1b
to_Invalid_Phase_1b (T.TStruct fields) = Invalid_Phase_1b{
  invalid_Phase_1b_offending_phase_1b = P.maybe (invalid_Phase_1b_offending_phase_1b default_Invalid_Phase_1b) (\(_,_val401) -> (case _val401 of {T.TStruct _val402 -> (to_Phase_1b (T.TStruct _val402)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Phase_1b_explanation = P.maybe (P.Nothing) (\(_,_val401) -> P.Just (case _val401 of {T.TString _val403 -> E.decodeUtf8 _val403; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Invalid_Phase_1b _ = P.error "not a struct"
read_Invalid_Phase_1b :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Phase_1b
read_Invalid_Phase_1b iprot = to_Invalid_Phase_1b <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Phase_1b)
decode_Invalid_Phase_1b :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Phase_1b
decode_Invalid_Phase_1b iprot bs = to_Invalid_Phase_1b $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Phase_1b) bs
typemap_Invalid_Phase_1b :: T.TypeMap
typemap_Invalid_Phase_1b = Map.fromList [(1,("offending_phase_1b",(T.T_STRUCT typemap_Phase_1b))),(3,("explanation",T.T_STRING))]
default_Invalid_Phase_1b :: Invalid_Phase_1b
default_Invalid_Phase_1b = Invalid_Phase_1b{
  invalid_Phase_1b_offending_phase_1b = default_Phase_1b,
  invalid_Phase_1b_explanation = P.Nothing}
data Phase_2b = Phase_2b  { phase_2b_phase_1bs :: (Set.HashSet Signed_Message)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Phase_2b where
  hashWithSalt salt record = salt   `H.hashWithSalt` phase_2b_phase_1bs record  
instance QC.Arbitrary Phase_2b where 
  arbitrary = M.liftM Phase_2b (QC.arbitrary)
  shrink obj | obj == default_Phase_2b = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Phase_2b{phase_2b_phase_1bs = phase_2b_phase_1bs obj} then P.Nothing else P.Just $ default_Phase_2b{phase_2b_phase_1bs = phase_2b_phase_1bs obj}
    ]
from_Phase_2b :: Phase_2b -> T.ThriftVal
from_Phase_2b record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v406 -> P.Just (1, ("phase_1bs",T.TSet (T.T_STRUCT typemap_Signed_Message) $ P.map (\_v408 -> from_Signed_Message _v408) $ Set.toList _v406))) $ phase_2b_phase_1bs record
  ]
write_Phase_2b :: (T.Protocol p, T.Transport t) => p t -> Phase_2b -> P.IO ()
write_Phase_2b oprot record = T.writeVal oprot $ from_Phase_2b record
encode_Phase_2b :: (T.Protocol p, T.Transport t) => p t -> Phase_2b -> LBS.ByteString
encode_Phase_2b oprot record = T.serializeVal oprot $ from_Phase_2b record
to_Phase_2b :: T.ThriftVal -> Phase_2b
to_Phase_2b (T.TStruct fields) = Phase_2b{
  phase_2b_phase_1bs = P.maybe (phase_2b_phase_1bs default_Phase_2b) (\(_,_val410) -> (case _val410 of {T.TSet _ _val411 -> (Set.fromList $ P.map (\_v412 -> (case _v412 of {T.TStruct _val413 -> (to_Signed_Message (T.TStruct _val413)); _ -> P.error "wrong type"})) _val411); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Phase_2b _ = P.error "not a struct"
read_Phase_2b :: (T.Transport t, T.Protocol p) => p t -> P.IO Phase_2b
read_Phase_2b iprot = to_Phase_2b <$> T.readVal iprot (T.T_STRUCT typemap_Phase_2b)
decode_Phase_2b :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Phase_2b
decode_Phase_2b iprot bs = to_Phase_2b $ T.deserializeVal iprot (T.T_STRUCT typemap_Phase_2b) bs
typemap_Phase_2b :: T.TypeMap
typemap_Phase_2b = Map.fromList [(1,("phase_1bs",(T.T_SET (T.T_STRUCT typemap_Signed_Message))))]
default_Phase_2b :: Phase_2b
default_Phase_2b = Phase_2b{
  phase_2b_phase_1bs = Set.empty}
data Invalid_Phase_2b = Invalid_Phase_2b  { invalid_Phase_2b_offending_phase_2b :: Phase_2b
  , invalid_Phase_2b_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Phase_2b
instance H.Hashable Invalid_Phase_2b where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Phase_2b_offending_phase_2b record   `H.hashWithSalt` invalid_Phase_2b_explanation record  
instance QC.Arbitrary Invalid_Phase_2b where 
  arbitrary = M.liftM Invalid_Phase_2b (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Phase_2b = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Phase_2b{invalid_Phase_2b_offending_phase_2b = invalid_Phase_2b_offending_phase_2b obj} then P.Nothing else P.Just $ default_Invalid_Phase_2b{invalid_Phase_2b_offending_phase_2b = invalid_Phase_2b_offending_phase_2b obj}
    , if obj == default_Invalid_Phase_2b{invalid_Phase_2b_explanation = invalid_Phase_2b_explanation obj} then P.Nothing else P.Just $ default_Invalid_Phase_2b{invalid_Phase_2b_explanation = invalid_Phase_2b_explanation obj}
    ]
from_Invalid_Phase_2b :: Invalid_Phase_2b -> T.ThriftVal
from_Invalid_Phase_2b record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v416 -> P.Just (1, ("offending_phase_2b",from_Phase_2b _v416))) $ invalid_Phase_2b_offending_phase_2b record
  , (\_v416 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v416))) <$> invalid_Phase_2b_explanation record
  ]
write_Invalid_Phase_2b :: (T.Protocol p, T.Transport t) => p t -> Invalid_Phase_2b -> P.IO ()
write_Invalid_Phase_2b oprot record = T.writeVal oprot $ from_Invalid_Phase_2b record
encode_Invalid_Phase_2b :: (T.Protocol p, T.Transport t) => p t -> Invalid_Phase_2b -> LBS.ByteString
encode_Invalid_Phase_2b oprot record = T.serializeVal oprot $ from_Invalid_Phase_2b record
to_Invalid_Phase_2b :: T.ThriftVal -> Invalid_Phase_2b
to_Invalid_Phase_2b (T.TStruct fields) = Invalid_Phase_2b{
  invalid_Phase_2b_offending_phase_2b = P.maybe (invalid_Phase_2b_offending_phase_2b default_Invalid_Phase_2b) (\(_,_val418) -> (case _val418 of {T.TStruct _val419 -> (to_Phase_2b (T.TStruct _val419)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Phase_2b_explanation = P.maybe (P.Nothing) (\(_,_val418) -> P.Just (case _val418 of {T.TString _val420 -> E.decodeUtf8 _val420; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Invalid_Phase_2b _ = P.error "not a struct"
read_Invalid_Phase_2b :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Phase_2b
read_Invalid_Phase_2b iprot = to_Invalid_Phase_2b <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Phase_2b)
decode_Invalid_Phase_2b :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Phase_2b
decode_Invalid_Phase_2b iprot bs = to_Invalid_Phase_2b $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Phase_2b) bs
typemap_Invalid_Phase_2b :: T.TypeMap
typemap_Invalid_Phase_2b = Map.fromList [(1,("offending_phase_2b",(T.T_STRUCT typemap_Phase_2b))),(3,("explanation",T.T_STRING))]
default_Invalid_Phase_2b :: Invalid_Phase_2b
default_Invalid_Phase_2b = Invalid_Phase_2b{
  invalid_Phase_2b_offending_phase_2b = default_Phase_2b,
  invalid_Phase_2b_explanation = P.Nothing}
data Proof_of_Consensus = Proof_of_Consensus  { proof_of_Consensus_phase_2bs :: (Set.HashSet Signed_Message)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Proof_of_Consensus where
  hashWithSalt salt record = salt   `H.hashWithSalt` proof_of_Consensus_phase_2bs record  
instance QC.Arbitrary Proof_of_Consensus where 
  arbitrary = M.liftM Proof_of_Consensus (QC.arbitrary)
  shrink obj | obj == default_Proof_of_Consensus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Proof_of_Consensus{proof_of_Consensus_phase_2bs = proof_of_Consensus_phase_2bs obj} then P.Nothing else P.Just $ default_Proof_of_Consensus{proof_of_Consensus_phase_2bs = proof_of_Consensus_phase_2bs obj}
    ]
from_Proof_of_Consensus :: Proof_of_Consensus -> T.ThriftVal
from_Proof_of_Consensus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v423 -> P.Just (1, ("phase_2bs",T.TSet (T.T_STRUCT typemap_Signed_Message) $ P.map (\_v425 -> from_Signed_Message _v425) $ Set.toList _v423))) $ proof_of_Consensus_phase_2bs record
  ]
write_Proof_of_Consensus :: (T.Protocol p, T.Transport t) => p t -> Proof_of_Consensus -> P.IO ()
write_Proof_of_Consensus oprot record = T.writeVal oprot $ from_Proof_of_Consensus record
encode_Proof_of_Consensus :: (T.Protocol p, T.Transport t) => p t -> Proof_of_Consensus -> LBS.ByteString
encode_Proof_of_Consensus oprot record = T.serializeVal oprot $ from_Proof_of_Consensus record
to_Proof_of_Consensus :: T.ThriftVal -> Proof_of_Consensus
to_Proof_of_Consensus (T.TStruct fields) = Proof_of_Consensus{
  proof_of_Consensus_phase_2bs = P.maybe (proof_of_Consensus_phase_2bs default_Proof_of_Consensus) (\(_,_val427) -> (case _val427 of {T.TSet _ _val428 -> (Set.fromList $ P.map (\_v429 -> (case _v429 of {T.TStruct _val430 -> (to_Signed_Message (T.TStruct _val430)); _ -> P.error "wrong type"})) _val428); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Proof_of_Consensus _ = P.error "not a struct"
read_Proof_of_Consensus :: (T.Transport t, T.Protocol p) => p t -> P.IO Proof_of_Consensus
read_Proof_of_Consensus iprot = to_Proof_of_Consensus <$> T.readVal iprot (T.T_STRUCT typemap_Proof_of_Consensus)
decode_Proof_of_Consensus :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Proof_of_Consensus
decode_Proof_of_Consensus iprot bs = to_Proof_of_Consensus $ T.deserializeVal iprot (T.T_STRUCT typemap_Proof_of_Consensus) bs
typemap_Proof_of_Consensus :: T.TypeMap
typemap_Proof_of_Consensus = Map.fromList [(1,("phase_2bs",(T.T_SET (T.T_STRUCT typemap_Signed_Message))))]
default_Proof_of_Consensus :: Proof_of_Consensus
default_Proof_of_Consensus = Proof_of_Consensus{
  proof_of_Consensus_phase_2bs = Set.empty}
data Invalid_Proof_of_Consensus = Invalid_Proof_of_Consensus  { invalid_Proof_of_Consensus_offending_proof_of_consensus :: Proof_of_Consensus
  , invalid_Proof_of_Consensus_explanation :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception Invalid_Proof_of_Consensus
instance H.Hashable Invalid_Proof_of_Consensus where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalid_Proof_of_Consensus_offending_proof_of_consensus record   `H.hashWithSalt` invalid_Proof_of_Consensus_explanation record  
instance QC.Arbitrary Invalid_Proof_of_Consensus where 
  arbitrary = M.liftM Invalid_Proof_of_Consensus (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Invalid_Proof_of_Consensus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Invalid_Proof_of_Consensus{invalid_Proof_of_Consensus_offending_proof_of_consensus = invalid_Proof_of_Consensus_offending_proof_of_consensus obj} then P.Nothing else P.Just $ default_Invalid_Proof_of_Consensus{invalid_Proof_of_Consensus_offending_proof_of_consensus = invalid_Proof_of_Consensus_offending_proof_of_consensus obj}
    , if obj == default_Invalid_Proof_of_Consensus{invalid_Proof_of_Consensus_explanation = invalid_Proof_of_Consensus_explanation obj} then P.Nothing else P.Just $ default_Invalid_Proof_of_Consensus{invalid_Proof_of_Consensus_explanation = invalid_Proof_of_Consensus_explanation obj}
    ]
from_Invalid_Proof_of_Consensus :: Invalid_Proof_of_Consensus -> T.ThriftVal
from_Invalid_Proof_of_Consensus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v433 -> P.Just (1, ("offending_proof_of_consensus",from_Proof_of_Consensus _v433))) $ invalid_Proof_of_Consensus_offending_proof_of_consensus record
  , (\_v433 -> (3, ("explanation",T.TString $ E.encodeUtf8 _v433))) <$> invalid_Proof_of_Consensus_explanation record
  ]
write_Invalid_Proof_of_Consensus :: (T.Protocol p, T.Transport t) => p t -> Invalid_Proof_of_Consensus -> P.IO ()
write_Invalid_Proof_of_Consensus oprot record = T.writeVal oprot $ from_Invalid_Proof_of_Consensus record
encode_Invalid_Proof_of_Consensus :: (T.Protocol p, T.Transport t) => p t -> Invalid_Proof_of_Consensus -> LBS.ByteString
encode_Invalid_Proof_of_Consensus oprot record = T.serializeVal oprot $ from_Invalid_Proof_of_Consensus record
to_Invalid_Proof_of_Consensus :: T.ThriftVal -> Invalid_Proof_of_Consensus
to_Invalid_Proof_of_Consensus (T.TStruct fields) = Invalid_Proof_of_Consensus{
  invalid_Proof_of_Consensus_offending_proof_of_consensus = P.maybe (invalid_Proof_of_Consensus_offending_proof_of_consensus default_Invalid_Proof_of_Consensus) (\(_,_val435) -> (case _val435 of {T.TStruct _val436 -> (to_Proof_of_Consensus (T.TStruct _val436)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invalid_Proof_of_Consensus_explanation = P.maybe (P.Nothing) (\(_,_val435) -> P.Just (case _val435 of {T.TString _val437 -> E.decodeUtf8 _val437; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Invalid_Proof_of_Consensus _ = P.error "not a struct"
read_Invalid_Proof_of_Consensus :: (T.Transport t, T.Protocol p) => p t -> P.IO Invalid_Proof_of_Consensus
read_Invalid_Proof_of_Consensus iprot = to_Invalid_Proof_of_Consensus <$> T.readVal iprot (T.T_STRUCT typemap_Invalid_Proof_of_Consensus)
decode_Invalid_Proof_of_Consensus :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Invalid_Proof_of_Consensus
decode_Invalid_Proof_of_Consensus iprot bs = to_Invalid_Proof_of_Consensus $ T.deserializeVal iprot (T.T_STRUCT typemap_Invalid_Proof_of_Consensus) bs
typemap_Invalid_Proof_of_Consensus :: T.TypeMap
typemap_Invalid_Proof_of_Consensus = Map.fromList [(1,("offending_proof_of_consensus",(T.T_STRUCT typemap_Proof_of_Consensus))),(3,("explanation",T.T_STRING))]
default_Invalid_Proof_of_Consensus :: Invalid_Proof_of_Consensus
default_Invalid_Proof_of_Consensus = Invalid_Proof_of_Consensus{
  invalid_Proof_of_Consensus_offending_proof_of_consensus = default_Proof_of_Consensus,
  invalid_Proof_of_Consensus_explanation = P.Nothing}
