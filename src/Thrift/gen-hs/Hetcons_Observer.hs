{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (1.0.0-dev)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Hetcons_Observer where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Hetcons_Types
import qualified Hetcons_Observer_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Ping_args = Ping_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Ping_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Ping_args where 
  arbitrary = QC.elements [Ping_args]
from_Ping_args :: Ping_args -> T.ThriftVal
from_Ping_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Ping_args :: (T.Protocol p, T.Transport t) => p t -> Ping_args -> P.IO ()
write_Ping_args oprot record = T.writeVal oprot $ from_Ping_args record
encode_Ping_args :: (T.Protocol p, T.Transport t) => p t -> Ping_args -> LBS.ByteString
encode_Ping_args oprot record = T.serializeVal oprot $ from_Ping_args record
to_Ping_args :: T.ThriftVal -> Ping_args
to_Ping_args (T.TStruct fields) = Ping_args{

  }
to_Ping_args _ = P.error "not a struct"
read_Ping_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Ping_args
read_Ping_args iprot = to_Ping_args <$> T.readVal iprot (T.T_STRUCT typemap_Ping_args)
decode_Ping_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Ping_args
decode_Ping_args iprot bs = to_Ping_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Ping_args) bs
typemap_Ping_args :: T.TypeMap
typemap_Ping_args = Map.fromList []
default_Ping_args :: Ping_args
default_Ping_args = Ping_args{
}
data Ping_result = Ping_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Ping_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Ping_result where 
  arbitrary = QC.elements [Ping_result]
from_Ping_result :: Ping_result -> T.ThriftVal
from_Ping_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Ping_result :: (T.Protocol p, T.Transport t) => p t -> Ping_result -> P.IO ()
write_Ping_result oprot record = T.writeVal oprot $ from_Ping_result record
encode_Ping_result :: (T.Protocol p, T.Transport t) => p t -> Ping_result -> LBS.ByteString
encode_Ping_result oprot record = T.serializeVal oprot $ from_Ping_result record
to_Ping_result :: T.ThriftVal -> Ping_result
to_Ping_result (T.TStruct fields) = Ping_result{

  }
to_Ping_result _ = P.error "not a struct"
read_Ping_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Ping_result
read_Ping_result iprot = to_Ping_result <$> T.readVal iprot (T.T_STRUCT typemap_Ping_result)
decode_Ping_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Ping_result
decode_Ping_result iprot bs = to_Ping_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Ping_result) bs
typemap_Ping_result :: T.TypeMap
typemap_Ping_result = Map.fromList []
default_Ping_result :: Ping_result
default_Ping_result = Ping_result{
}
data Phase_2b_args = Phase_2b_args  { phase_2b_args_phase_2b_message :: Signed_Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Phase_2b_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` phase_2b_args_phase_2b_message record  
instance QC.Arbitrary Phase_2b_args where 
  arbitrary = M.liftM Phase_2b_args (QC.arbitrary)
  shrink obj | obj == default_Phase_2b_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Phase_2b_args{phase_2b_args_phase_2b_message = phase_2b_args_phase_2b_message obj} then P.Nothing else P.Just $ default_Phase_2b_args{phase_2b_args_phase_2b_message = phase_2b_args_phase_2b_message obj}
    ]
from_Phase_2b_args :: Phase_2b_args -> T.ThriftVal
from_Phase_2b_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v527 -> P.Just (1, ("phase_2b_message",from_Signed_Message _v527))) $ phase_2b_args_phase_2b_message record
  ]
write_Phase_2b_args :: (T.Protocol p, T.Transport t) => p t -> Phase_2b_args -> P.IO ()
write_Phase_2b_args oprot record = T.writeVal oprot $ from_Phase_2b_args record
encode_Phase_2b_args :: (T.Protocol p, T.Transport t) => p t -> Phase_2b_args -> LBS.ByteString
encode_Phase_2b_args oprot record = T.serializeVal oprot $ from_Phase_2b_args record
to_Phase_2b_args :: T.ThriftVal -> Phase_2b_args
to_Phase_2b_args (T.TStruct fields) = Phase_2b_args{
  phase_2b_args_phase_2b_message = P.maybe (phase_2b_args_phase_2b_message default_Phase_2b_args) (\(_,_val529) -> (case _val529 of {T.TStruct _val530 -> (to_Signed_Message (T.TStruct _val530)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Phase_2b_args _ = P.error "not a struct"
read_Phase_2b_args :: (T.Transport t, T.Protocol p) => p t -> P.IO Phase_2b_args
read_Phase_2b_args iprot = to_Phase_2b_args <$> T.readVal iprot (T.T_STRUCT typemap_Phase_2b_args)
decode_Phase_2b_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Phase_2b_args
decode_Phase_2b_args iprot bs = to_Phase_2b_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Phase_2b_args) bs
typemap_Phase_2b_args :: T.TypeMap
typemap_Phase_2b_args = Map.fromList [(1,("phase_2b_message",(T.T_STRUCT typemap_Signed_Message)))]
default_Phase_2b_args :: Phase_2b_args
default_Phase_2b_args = Phase_2b_args{
  phase_2b_args_phase_2b_message = default_Signed_Message}
data Phase_2b_result = Phase_2b_result  { phase_2b_result_no_supported_hash_sha2_descriptor_provided :: P.Maybe No_Supported_Hash_Sha2_Descriptor_Provided
  , phase_2b_result_descriptor_does_not_match_hash_sha2 :: P.Maybe Descriptor_Does_Not_Match_Hash_Sha2
  , phase_2b_result_no_supported_hash_sha3_descriptor_provided :: P.Maybe No_Supported_Hash_Sha3_Descriptor_Provided
  , phase_2b_result_descriptor_does_not_match_hash_sha3 :: P.Maybe Descriptor_Does_Not_Match_Hash_Sha3
  , phase_2b_result_no_supported_hash_type_descriptor_provided :: P.Maybe No_Supported_Hash_Type_Descriptor_Provided
  , phase_2b_result_descriptor_does_not_match_hash :: P.Maybe Descriptor_Does_Not_Match_Hash
  , phase_2b_result_invalid_public_crypto_key_X509 :: P.Maybe Invalid_Public_Crypto_Key_X509
  , phase_2b_result_invalid_public_crypto_key_PGP :: P.Maybe Invalid_Public_Crypto_Key_PGP
  , phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided :: P.Maybe No_Supported_Public_Crypto_Key_Type_Descriptor_Provided
  , phase_2b_result_descriptor_does_not_match_public_crypto_key :: P.Maybe Descriptor_Does_Not_Match_Public_Crypto_Key
  , phase_2b_result_descriptor_does_not_match_crypto_ID_hash :: P.Maybe Descriptor_Does_Not_Match_Crypto_ID_Hash
  , phase_2b_result_no_supported_crypto_ID_type_descriptor_provided :: P.Maybe No_Supported_Crypto_ID_Type_Descriptor_Provided
  , phase_2b_result_descriptor_does_not_match_crypto_ID :: P.Maybe Descriptor_Does_Not_Match_Crypto_ID
  , phase_2b_result_invalid_signed_hash :: P.Maybe Invalid_Signed_Hash
  , phase_2b_result_descriptor_does_not_match_signed_hash :: P.Maybe Descriptor_Does_Not_Match_Signed_Hash
  , phase_2b_result_unparsable_hashable_message :: P.Maybe Unparsable_Hashable_Message
  , phase_2b_result_invalid_address :: P.Maybe Invalid_Address
  , phase_2b_result_impossible_observer_graph :: P.Maybe Impossible_Observer_Graph
  , phase_2b_result_invalid_proposal_1a :: P.Maybe Invalid_Proposal_1a
  , phase_2b_result_invalid_Phase_1b :: P.Maybe Invalid_Phase_1b
  , phase_2b_result_invalid_Phase_2a :: P.Maybe Invalid_Phase_2a
  , phase_2b_result_invalid_Phase_2b :: P.Maybe Invalid_Phase_2b
  , phase_2b_result_invalid_Proof_of_Consensus :: P.Maybe Invalid_Proof_of_Consensus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Phase_2b_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` phase_2b_result_no_supported_hash_sha2_descriptor_provided record   `H.hashWithSalt` phase_2b_result_descriptor_does_not_match_hash_sha2 record   `H.hashWithSalt` phase_2b_result_no_supported_hash_sha3_descriptor_provided record   `H.hashWithSalt` phase_2b_result_descriptor_does_not_match_hash_sha3 record   `H.hashWithSalt` phase_2b_result_no_supported_hash_type_descriptor_provided record   `H.hashWithSalt` phase_2b_result_descriptor_does_not_match_hash record   `H.hashWithSalt` phase_2b_result_invalid_public_crypto_key_X509 record   `H.hashWithSalt` phase_2b_result_invalid_public_crypto_key_PGP record   `H.hashWithSalt` phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided record   `H.hashWithSalt` phase_2b_result_descriptor_does_not_match_public_crypto_key record   `H.hashWithSalt` phase_2b_result_descriptor_does_not_match_crypto_ID_hash record   `H.hashWithSalt` phase_2b_result_no_supported_crypto_ID_type_descriptor_provided record   `H.hashWithSalt` phase_2b_result_descriptor_does_not_match_crypto_ID record   `H.hashWithSalt` phase_2b_result_invalid_signed_hash record   `H.hashWithSalt` phase_2b_result_descriptor_does_not_match_signed_hash record   `H.hashWithSalt` phase_2b_result_unparsable_hashable_message record   `H.hashWithSalt` phase_2b_result_invalid_address record   `H.hashWithSalt` phase_2b_result_impossible_observer_graph record   `H.hashWithSalt` phase_2b_result_invalid_proposal_1a record   `H.hashWithSalt` phase_2b_result_invalid_Phase_1b record   `H.hashWithSalt` phase_2b_result_invalid_Phase_2a record   `H.hashWithSalt` phase_2b_result_invalid_Phase_2b record   `H.hashWithSalt` phase_2b_result_invalid_Proof_of_Consensus record  
instance QC.Arbitrary Phase_2b_result where 
  arbitrary = M.liftM Phase_2b_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Phase_2b_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Phase_2b_result{phase_2b_result_no_supported_hash_sha2_descriptor_provided = phase_2b_result_no_supported_hash_sha2_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_no_supported_hash_sha2_descriptor_provided = phase_2b_result_no_supported_hash_sha2_descriptor_provided obj}
    , if obj == default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash_sha2 = phase_2b_result_descriptor_does_not_match_hash_sha2 obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash_sha2 = phase_2b_result_descriptor_does_not_match_hash_sha2 obj}
    , if obj == default_Phase_2b_result{phase_2b_result_no_supported_hash_sha3_descriptor_provided = phase_2b_result_no_supported_hash_sha3_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_no_supported_hash_sha3_descriptor_provided = phase_2b_result_no_supported_hash_sha3_descriptor_provided obj}
    , if obj == default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash_sha3 = phase_2b_result_descriptor_does_not_match_hash_sha3 obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash_sha3 = phase_2b_result_descriptor_does_not_match_hash_sha3 obj}
    , if obj == default_Phase_2b_result{phase_2b_result_no_supported_hash_type_descriptor_provided = phase_2b_result_no_supported_hash_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_no_supported_hash_type_descriptor_provided = phase_2b_result_no_supported_hash_type_descriptor_provided obj}
    , if obj == default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash = phase_2b_result_descriptor_does_not_match_hash obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash = phase_2b_result_descriptor_does_not_match_hash obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_public_crypto_key_X509 = phase_2b_result_invalid_public_crypto_key_X509 obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_public_crypto_key_X509 = phase_2b_result_invalid_public_crypto_key_X509 obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_public_crypto_key_PGP = phase_2b_result_invalid_public_crypto_key_PGP obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_public_crypto_key_PGP = phase_2b_result_invalid_public_crypto_key_PGP obj}
    , if obj == default_Phase_2b_result{phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided = phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided = phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided obj}
    , if obj == default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_public_crypto_key = phase_2b_result_descriptor_does_not_match_public_crypto_key obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_public_crypto_key = phase_2b_result_descriptor_does_not_match_public_crypto_key obj}
    , if obj == default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_crypto_ID_hash = phase_2b_result_descriptor_does_not_match_crypto_ID_hash obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_crypto_ID_hash = phase_2b_result_descriptor_does_not_match_crypto_ID_hash obj}
    , if obj == default_Phase_2b_result{phase_2b_result_no_supported_crypto_ID_type_descriptor_provided = phase_2b_result_no_supported_crypto_ID_type_descriptor_provided obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_no_supported_crypto_ID_type_descriptor_provided = phase_2b_result_no_supported_crypto_ID_type_descriptor_provided obj}
    , if obj == default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_crypto_ID = phase_2b_result_descriptor_does_not_match_crypto_ID obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_crypto_ID = phase_2b_result_descriptor_does_not_match_crypto_ID obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_signed_hash = phase_2b_result_invalid_signed_hash obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_signed_hash = phase_2b_result_invalid_signed_hash obj}
    , if obj == default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_signed_hash = phase_2b_result_descriptor_does_not_match_signed_hash obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_signed_hash = phase_2b_result_descriptor_does_not_match_signed_hash obj}
    , if obj == default_Phase_2b_result{phase_2b_result_unparsable_hashable_message = phase_2b_result_unparsable_hashable_message obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_unparsable_hashable_message = phase_2b_result_unparsable_hashable_message obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_address = phase_2b_result_invalid_address obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_address = phase_2b_result_invalid_address obj}
    , if obj == default_Phase_2b_result{phase_2b_result_impossible_observer_graph = phase_2b_result_impossible_observer_graph obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_impossible_observer_graph = phase_2b_result_impossible_observer_graph obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_proposal_1a = phase_2b_result_invalid_proposal_1a obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_proposal_1a = phase_2b_result_invalid_proposal_1a obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_Phase_1b = phase_2b_result_invalid_Phase_1b obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_Phase_1b = phase_2b_result_invalid_Phase_1b obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_Phase_2a = phase_2b_result_invalid_Phase_2a obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_Phase_2a = phase_2b_result_invalid_Phase_2a obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_Phase_2b = phase_2b_result_invalid_Phase_2b obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_Phase_2b = phase_2b_result_invalid_Phase_2b obj}
    , if obj == default_Phase_2b_result{phase_2b_result_invalid_Proof_of_Consensus = phase_2b_result_invalid_Proof_of_Consensus obj} then P.Nothing else P.Just $ default_Phase_2b_result{phase_2b_result_invalid_Proof_of_Consensus = phase_2b_result_invalid_Proof_of_Consensus obj}
    ]
from_Phase_2b_result :: Phase_2b_result -> T.ThriftVal
from_Phase_2b_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v533 -> (1, ("no_supported_hash_sha2_descriptor_provided",from_No_Supported_Hash_Sha2_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_hash_sha2_descriptor_provided record, (\_v533 -> (2, ("descriptor_does_not_match_hash_sha2",from_Descriptor_Does_Not_Match_Hash_Sha2 _v533))) <$> phase_2b_result_descriptor_does_not_match_hash_sha2 record, (\_v533 -> (3, ("no_supported_hash_sha3_descriptor_provided",from_No_Supported_Hash_Sha3_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_hash_sha3_descriptor_provided record, (\_v533 -> (4, ("descriptor_does_not_match_hash_sha3",from_Descriptor_Does_Not_Match_Hash_Sha3 _v533))) <$> phase_2b_result_descriptor_does_not_match_hash_sha3 record, (\_v533 -> (5, ("no_supported_hash_type_descriptor_provided",from_No_Supported_Hash_Type_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_hash_type_descriptor_provided record, (\_v533 -> (6, ("descriptor_does_not_match_hash",from_Descriptor_Does_Not_Match_Hash _v533))) <$> phase_2b_result_descriptor_does_not_match_hash record, (\_v533 -> (7, ("invalid_public_crypto_key_X509",from_Invalid_Public_Crypto_Key_X509 _v533))) <$> phase_2b_result_invalid_public_crypto_key_X509 record, (\_v533 -> (8, ("invalid_public_crypto_key_PGP",from_Invalid_Public_Crypto_Key_PGP _v533))) <$> phase_2b_result_invalid_public_crypto_key_PGP record, (\_v533 -> (9, ("no_supported_public_crypto_key_type_descriptor_provided",from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided record, (\_v533 -> (10, ("descriptor_does_not_match_public_crypto_key",from_Descriptor_Does_Not_Match_Public_Crypto_Key _v533))) <$> phase_2b_result_descriptor_does_not_match_public_crypto_key record, (\_v533 -> (11, ("descriptor_does_not_match_crypto_ID_hash",from_Descriptor_Does_Not_Match_Crypto_ID_Hash _v533))) <$> phase_2b_result_descriptor_does_not_match_crypto_ID_hash record, (\_v533 -> (12, ("no_supported_crypto_ID_type_descriptor_provided",from_No_Supported_Crypto_ID_Type_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_crypto_ID_type_descriptor_provided record, (\_v533 -> (13, ("descriptor_does_not_match_crypto_ID",from_Descriptor_Does_Not_Match_Crypto_ID _v533))) <$> phase_2b_result_descriptor_does_not_match_crypto_ID record, (\_v533 -> (14, ("invalid_signed_hash",from_Invalid_Signed_Hash _v533))) <$> phase_2b_result_invalid_signed_hash record, (\_v533 -> (15, ("descriptor_does_not_match_signed_hash",from_Descriptor_Does_Not_Match_Signed_Hash _v533))) <$> phase_2b_result_descriptor_does_not_match_signed_hash record, (\_v533 -> (16, ("unparsable_hashable_message",from_Unparsable_Hashable_Message _v533))) <$> phase_2b_result_unparsable_hashable_message record, (\_v533 -> (17, ("invalid_address",from_Invalid_Address _v533))) <$> phase_2b_result_invalid_address record, (\_v533 -> (18, ("impossible_observer_graph",from_Impossible_Observer_Graph _v533))) <$> phase_2b_result_impossible_observer_graph record, (\_v533 -> (19, ("invalid_proposal_1a",from_Invalid_Proposal_1a _v533))) <$> phase_2b_result_invalid_proposal_1a record, (\_v533 -> (20, ("invalid_Phase_1b",from_Invalid_Phase_1b _v533))) <$> phase_2b_result_invalid_Phase_1b record, (\_v533 -> (21, ("invalid_Phase_2a",from_Invalid_Phase_2a _v533))) <$> phase_2b_result_invalid_Phase_2a record, (\_v533 -> (22, ("invalid_Phase_2b",from_Invalid_Phase_2b _v533))) <$> phase_2b_result_invalid_Phase_2b record, (\_v533 -> (23, ("invalid_Proof_of_Consensus",from_Invalid_Proof_of_Consensus _v533))) <$> phase_2b_result_invalid_Proof_of_Consensus record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v533 -> (1, ("no_supported_hash_sha2_descriptor_provided",from_No_Supported_Hash_Sha2_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_hash_sha2_descriptor_provided record
    , (\_v533 -> (2, ("descriptor_does_not_match_hash_sha2",from_Descriptor_Does_Not_Match_Hash_Sha2 _v533))) <$> phase_2b_result_descriptor_does_not_match_hash_sha2 record
    , (\_v533 -> (3, ("no_supported_hash_sha3_descriptor_provided",from_No_Supported_Hash_Sha3_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_hash_sha3_descriptor_provided record
    , (\_v533 -> (4, ("descriptor_does_not_match_hash_sha3",from_Descriptor_Does_Not_Match_Hash_Sha3 _v533))) <$> phase_2b_result_descriptor_does_not_match_hash_sha3 record
    , (\_v533 -> (5, ("no_supported_hash_type_descriptor_provided",from_No_Supported_Hash_Type_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_hash_type_descriptor_provided record
    , (\_v533 -> (6, ("descriptor_does_not_match_hash",from_Descriptor_Does_Not_Match_Hash _v533))) <$> phase_2b_result_descriptor_does_not_match_hash record
    , (\_v533 -> (7, ("invalid_public_crypto_key_X509",from_Invalid_Public_Crypto_Key_X509 _v533))) <$> phase_2b_result_invalid_public_crypto_key_X509 record
    , (\_v533 -> (8, ("invalid_public_crypto_key_PGP",from_Invalid_Public_Crypto_Key_PGP _v533))) <$> phase_2b_result_invalid_public_crypto_key_PGP record
    , (\_v533 -> (9, ("no_supported_public_crypto_key_type_descriptor_provided",from_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided record
    , (\_v533 -> (10, ("descriptor_does_not_match_public_crypto_key",from_Descriptor_Does_Not_Match_Public_Crypto_Key _v533))) <$> phase_2b_result_descriptor_does_not_match_public_crypto_key record
    , (\_v533 -> (11, ("descriptor_does_not_match_crypto_ID_hash",from_Descriptor_Does_Not_Match_Crypto_ID_Hash _v533))) <$> phase_2b_result_descriptor_does_not_match_crypto_ID_hash record
    , (\_v533 -> (12, ("no_supported_crypto_ID_type_descriptor_provided",from_No_Supported_Crypto_ID_Type_Descriptor_Provided _v533))) <$> phase_2b_result_no_supported_crypto_ID_type_descriptor_provided record
    , (\_v533 -> (13, ("descriptor_does_not_match_crypto_ID",from_Descriptor_Does_Not_Match_Crypto_ID _v533))) <$> phase_2b_result_descriptor_does_not_match_crypto_ID record
    , (\_v533 -> (14, ("invalid_signed_hash",from_Invalid_Signed_Hash _v533))) <$> phase_2b_result_invalid_signed_hash record
    , (\_v533 -> (15, ("descriptor_does_not_match_signed_hash",from_Descriptor_Does_Not_Match_Signed_Hash _v533))) <$> phase_2b_result_descriptor_does_not_match_signed_hash record
    , (\_v533 -> (16, ("unparsable_hashable_message",from_Unparsable_Hashable_Message _v533))) <$> phase_2b_result_unparsable_hashable_message record
    , (\_v533 -> (17, ("invalid_address",from_Invalid_Address _v533))) <$> phase_2b_result_invalid_address record
    , (\_v533 -> (18, ("impossible_observer_graph",from_Impossible_Observer_Graph _v533))) <$> phase_2b_result_impossible_observer_graph record
    , (\_v533 -> (19, ("invalid_proposal_1a",from_Invalid_Proposal_1a _v533))) <$> phase_2b_result_invalid_proposal_1a record
    , (\_v533 -> (20, ("invalid_Phase_1b",from_Invalid_Phase_1b _v533))) <$> phase_2b_result_invalid_Phase_1b record
    , (\_v533 -> (21, ("invalid_Phase_2a",from_Invalid_Phase_2a _v533))) <$> phase_2b_result_invalid_Phase_2a record
    , (\_v533 -> (22, ("invalid_Phase_2b",from_Invalid_Phase_2b _v533))) <$> phase_2b_result_invalid_Phase_2b record
    , (\_v533 -> (23, ("invalid_Proof_of_Consensus",from_Invalid_Proof_of_Consensus _v533))) <$> phase_2b_result_invalid_Proof_of_Consensus record
    ]
    )
write_Phase_2b_result :: (T.Protocol p, T.Transport t) => p t -> Phase_2b_result -> P.IO ()
write_Phase_2b_result oprot record = T.writeVal oprot $ from_Phase_2b_result record
encode_Phase_2b_result :: (T.Protocol p, T.Transport t) => p t -> Phase_2b_result -> LBS.ByteString
encode_Phase_2b_result oprot record = T.serializeVal oprot $ from_Phase_2b_result record
to_Phase_2b_result :: T.ThriftVal -> Phase_2b_result
to_Phase_2b_result (T.TStruct fields) = Phase_2b_result{
  phase_2b_result_no_supported_hash_sha2_descriptor_provided = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val536 -> (to_No_Supported_Hash_Sha2_Descriptor_Provided (T.TStruct _val536)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  phase_2b_result_descriptor_does_not_match_hash_sha2 = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val537 -> (to_Descriptor_Does_Not_Match_Hash_Sha2 (T.TStruct _val537)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  phase_2b_result_no_supported_hash_sha3_descriptor_provided = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val538 -> (to_No_Supported_Hash_Sha3_Descriptor_Provided (T.TStruct _val538)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  phase_2b_result_descriptor_does_not_match_hash_sha3 = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val539 -> (to_Descriptor_Does_Not_Match_Hash_Sha3 (T.TStruct _val539)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  phase_2b_result_no_supported_hash_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val540 -> (to_No_Supported_Hash_Type_Descriptor_Provided (T.TStruct _val540)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  phase_2b_result_descriptor_does_not_match_hash = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val541 -> (to_Descriptor_Does_Not_Match_Hash (T.TStruct _val541)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  phase_2b_result_invalid_public_crypto_key_X509 = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val542 -> (to_Invalid_Public_Crypto_Key_X509 (T.TStruct _val542)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  phase_2b_result_invalid_public_crypto_key_PGP = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val543 -> (to_Invalid_Public_Crypto_Key_PGP (T.TStruct _val543)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val544 -> (to_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided (T.TStruct _val544)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  phase_2b_result_descriptor_does_not_match_public_crypto_key = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val545 -> (to_Descriptor_Does_Not_Match_Public_Crypto_Key (T.TStruct _val545)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  phase_2b_result_descriptor_does_not_match_crypto_ID_hash = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val546 -> (to_Descriptor_Does_Not_Match_Crypto_ID_Hash (T.TStruct _val546)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  phase_2b_result_no_supported_crypto_ID_type_descriptor_provided = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val547 -> (to_No_Supported_Crypto_ID_Type_Descriptor_Provided (T.TStruct _val547)); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  phase_2b_result_descriptor_does_not_match_crypto_ID = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val548 -> (to_Descriptor_Does_Not_Match_Crypto_ID (T.TStruct _val548)); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  phase_2b_result_invalid_signed_hash = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val549 -> (to_Invalid_Signed_Hash (T.TStruct _val549)); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  phase_2b_result_descriptor_does_not_match_signed_hash = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val550 -> (to_Descriptor_Does_Not_Match_Signed_Hash (T.TStruct _val550)); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  phase_2b_result_unparsable_hashable_message = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val551 -> (to_Unparsable_Hashable_Message (T.TStruct _val551)); _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  phase_2b_result_invalid_address = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val552 -> (to_Invalid_Address (T.TStruct _val552)); _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  phase_2b_result_impossible_observer_graph = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val553 -> (to_Impossible_Observer_Graph (T.TStruct _val553)); _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  phase_2b_result_invalid_proposal_1a = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val554 -> (to_Invalid_Proposal_1a (T.TStruct _val554)); _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  phase_2b_result_invalid_Phase_1b = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val555 -> (to_Invalid_Phase_1b (T.TStruct _val555)); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  phase_2b_result_invalid_Phase_2a = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val556 -> (to_Invalid_Phase_2a (T.TStruct _val556)); _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  phase_2b_result_invalid_Phase_2b = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val557 -> (to_Invalid_Phase_2b (T.TStruct _val557)); _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  phase_2b_result_invalid_Proof_of_Consensus = P.maybe (P.Nothing) (\(_,_val535) -> P.Just (case _val535 of {T.TStruct _val558 -> (to_Invalid_Proof_of_Consensus (T.TStruct _val558)); _ -> P.error "wrong type"})) (Map.lookup (23) fields)
  }
to_Phase_2b_result _ = P.error "not a struct"
read_Phase_2b_result :: (T.Transport t, T.Protocol p) => p t -> P.IO Phase_2b_result
read_Phase_2b_result iprot = to_Phase_2b_result <$> T.readVal iprot (T.T_STRUCT typemap_Phase_2b_result)
decode_Phase_2b_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Phase_2b_result
decode_Phase_2b_result iprot bs = to_Phase_2b_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Phase_2b_result) bs
typemap_Phase_2b_result :: T.TypeMap
typemap_Phase_2b_result = Map.fromList [(1,("no_supported_hash_sha2_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Sha2_Descriptor_Provided))),(2,("descriptor_does_not_match_hash_sha2",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha2))),(3,("no_supported_hash_sha3_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Sha3_Descriptor_Provided))),(4,("descriptor_does_not_match_hash_sha3",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash_Sha3))),(5,("no_supported_hash_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Hash_Type_Descriptor_Provided))),(6,("descriptor_does_not_match_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Hash))),(7,("invalid_public_crypto_key_X509",(T.T_STRUCT typemap_Invalid_Public_Crypto_Key_X509))),(8,("invalid_public_crypto_key_PGP",(T.T_STRUCT typemap_Invalid_Public_Crypto_Key_PGP))),(9,("no_supported_public_crypto_key_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Public_Crypto_Key_Type_Descriptor_Provided))),(10,("descriptor_does_not_match_public_crypto_key",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Public_Crypto_Key))),(11,("descriptor_does_not_match_crypto_ID_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID_Hash))),(12,("no_supported_crypto_ID_type_descriptor_provided",(T.T_STRUCT typemap_No_Supported_Crypto_ID_Type_Descriptor_Provided))),(13,("descriptor_does_not_match_crypto_ID",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Crypto_ID))),(14,("invalid_signed_hash",(T.T_STRUCT typemap_Invalid_Signed_Hash))),(15,("descriptor_does_not_match_signed_hash",(T.T_STRUCT typemap_Descriptor_Does_Not_Match_Signed_Hash))),(16,("unparsable_hashable_message",(T.T_STRUCT typemap_Unparsable_Hashable_Message))),(17,("invalid_address",(T.T_STRUCT typemap_Invalid_Address))),(18,("impossible_observer_graph",(T.T_STRUCT typemap_Impossible_Observer_Graph))),(19,("invalid_proposal_1a",(T.T_STRUCT typemap_Invalid_Proposal_1a))),(20,("invalid_Phase_1b",(T.T_STRUCT typemap_Invalid_Phase_1b))),(21,("invalid_Phase_2a",(T.T_STRUCT typemap_Invalid_Phase_2a))),(22,("invalid_Phase_2b",(T.T_STRUCT typemap_Invalid_Phase_2b))),(23,("invalid_Proof_of_Consensus",(T.T_STRUCT typemap_Invalid_Proof_of_Consensus)))]
default_Phase_2b_result :: Phase_2b_result
default_Phase_2b_result = Phase_2b_result{
  phase_2b_result_no_supported_hash_sha2_descriptor_provided = P.Nothing,
  phase_2b_result_descriptor_does_not_match_hash_sha2 = P.Nothing,
  phase_2b_result_no_supported_hash_sha3_descriptor_provided = P.Nothing,
  phase_2b_result_descriptor_does_not_match_hash_sha3 = P.Nothing,
  phase_2b_result_no_supported_hash_type_descriptor_provided = P.Nothing,
  phase_2b_result_descriptor_does_not_match_hash = P.Nothing,
  phase_2b_result_invalid_public_crypto_key_X509 = P.Nothing,
  phase_2b_result_invalid_public_crypto_key_PGP = P.Nothing,
  phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided = P.Nothing,
  phase_2b_result_descriptor_does_not_match_public_crypto_key = P.Nothing,
  phase_2b_result_descriptor_does_not_match_crypto_ID_hash = P.Nothing,
  phase_2b_result_no_supported_crypto_ID_type_descriptor_provided = P.Nothing,
  phase_2b_result_descriptor_does_not_match_crypto_ID = P.Nothing,
  phase_2b_result_invalid_signed_hash = P.Nothing,
  phase_2b_result_descriptor_does_not_match_signed_hash = P.Nothing,
  phase_2b_result_unparsable_hashable_message = P.Nothing,
  phase_2b_result_invalid_address = P.Nothing,
  phase_2b_result_impossible_observer_graph = P.Nothing,
  phase_2b_result_invalid_proposal_1a = P.Nothing,
  phase_2b_result_invalid_Phase_1b = P.Nothing,
  phase_2b_result_invalid_Phase_2a = P.Nothing,
  phase_2b_result_invalid_Phase_2b = P.Nothing,
  phase_2b_result_invalid_Proof_of_Consensus = P.Nothing}
process_ping (seqid, iprot, oprot, handler) = do
  args <- read_Ping_args iprot
  (X.catch
    (do
      Iface.ping handler
      let res = default_Ping_result
      T.writeMessageBegin oprot ("ping", T.M_REPLY, seqid)
      write_Ping_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("ping", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_phase_2b (seqid, iprot, oprot, handler) = do
  args <- read_Phase_2b_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (X.catch
            (X.catch
              (X.catch
                (X.catch
                  (X.catch
                    (X.catch
                      (X.catch
                        (X.catch
                          (X.catch
                            (X.catch
                              (X.catch
                                (X.catch
                                  (X.catch
                                    (X.catch
                                      (X.catch
                                        (X.catch
                                          (X.catch
                                            (X.catch
                                              (X.catch
                                                (X.catch
                                                  (do
                                                    Iface.phase_2b handler (phase_2b_args_phase_2b_message args)
                                                    let res = default_Phase_2b_result
                                                    T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                                    write_Phase_2b_result oprot res
                                                    T.writeMessageEnd oprot
                                                    T.tFlush (T.getTransport oprot))
                                                  (\e  -> do
                                                    let res = default_Phase_2b_result{phase_2b_result_no_supported_hash_sha2_descriptor_provided = P.Just e}
                                                    T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                                    write_Phase_2b_result oprot res
                                                    T.writeMessageEnd oprot
                                                    T.tFlush (T.getTransport oprot)))
                                                (\e  -> do
                                                  let res = default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash_sha2 = P.Just e}
                                                  T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                                  write_Phase_2b_result oprot res
                                                  T.writeMessageEnd oprot
                                                  T.tFlush (T.getTransport oprot)))
                                              (\e  -> do
                                                let res = default_Phase_2b_result{phase_2b_result_no_supported_hash_sha3_descriptor_provided = P.Just e}
                                                T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                                write_Phase_2b_result oprot res
                                                T.writeMessageEnd oprot
                                                T.tFlush (T.getTransport oprot)))
                                            (\e  -> do
                                              let res = default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash_sha3 = P.Just e}
                                              T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                              write_Phase_2b_result oprot res
                                              T.writeMessageEnd oprot
                                              T.tFlush (T.getTransport oprot)))
                                          (\e  -> do
                                            let res = default_Phase_2b_result{phase_2b_result_no_supported_hash_type_descriptor_provided = P.Just e}
                                            T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                            write_Phase_2b_result oprot res
                                            T.writeMessageEnd oprot
                                            T.tFlush (T.getTransport oprot)))
                                        (\e  -> do
                                          let res = default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_hash = P.Just e}
                                          T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                          write_Phase_2b_result oprot res
                                          T.writeMessageEnd oprot
                                          T.tFlush (T.getTransport oprot)))
                                      (\e  -> do
                                        let res = default_Phase_2b_result{phase_2b_result_invalid_public_crypto_key_X509 = P.Just e}
                                        T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                        write_Phase_2b_result oprot res
                                        T.writeMessageEnd oprot
                                        T.tFlush (T.getTransport oprot)))
                                    (\e  -> do
                                      let res = default_Phase_2b_result{phase_2b_result_invalid_public_crypto_key_PGP = P.Just e}
                                      T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                      write_Phase_2b_result oprot res
                                      T.writeMessageEnd oprot
                                      T.tFlush (T.getTransport oprot)))
                                  (\e  -> do
                                    let res = default_Phase_2b_result{phase_2b_result_no_supported_public_crypto_key_type_descriptor_provided = P.Just e}
                                    T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                    write_Phase_2b_result oprot res
                                    T.writeMessageEnd oprot
                                    T.tFlush (T.getTransport oprot)))
                                (\e  -> do
                                  let res = default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_public_crypto_key = P.Just e}
                                  T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                  write_Phase_2b_result oprot res
                                  T.writeMessageEnd oprot
                                  T.tFlush (T.getTransport oprot)))
                              (\e  -> do
                                let res = default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_crypto_ID_hash = P.Just e}
                                T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                                write_Phase_2b_result oprot res
                                T.writeMessageEnd oprot
                                T.tFlush (T.getTransport oprot)))
                            (\e  -> do
                              let res = default_Phase_2b_result{phase_2b_result_no_supported_crypto_ID_type_descriptor_provided = P.Just e}
                              T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                              write_Phase_2b_result oprot res
                              T.writeMessageEnd oprot
                              T.tFlush (T.getTransport oprot)))
                          (\e  -> do
                            let res = default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_crypto_ID = P.Just e}
                            T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                            write_Phase_2b_result oprot res
                            T.writeMessageEnd oprot
                            T.tFlush (T.getTransport oprot)))
                        (\e  -> do
                          let res = default_Phase_2b_result{phase_2b_result_invalid_signed_hash = P.Just e}
                          T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                          write_Phase_2b_result oprot res
                          T.writeMessageEnd oprot
                          T.tFlush (T.getTransport oprot)))
                      (\e  -> do
                        let res = default_Phase_2b_result{phase_2b_result_descriptor_does_not_match_signed_hash = P.Just e}
                        T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                        write_Phase_2b_result oprot res
                        T.writeMessageEnd oprot
                        T.tFlush (T.getTransport oprot)))
                    (\e  -> do
                      let res = default_Phase_2b_result{phase_2b_result_unparsable_hashable_message = P.Just e}
                      T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                      write_Phase_2b_result oprot res
                      T.writeMessageEnd oprot
                      T.tFlush (T.getTransport oprot)))
                  (\e  -> do
                    let res = default_Phase_2b_result{phase_2b_result_invalid_address = P.Just e}
                    T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                    write_Phase_2b_result oprot res
                    T.writeMessageEnd oprot
                    T.tFlush (T.getTransport oprot)))
                (\e  -> do
                  let res = default_Phase_2b_result{phase_2b_result_impossible_observer_graph = P.Just e}
                  T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                  write_Phase_2b_result oprot res
                  T.writeMessageEnd oprot
                  T.tFlush (T.getTransport oprot)))
              (\e  -> do
                let res = default_Phase_2b_result{phase_2b_result_invalid_proposal_1a = P.Just e}
                T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
                write_Phase_2b_result oprot res
                T.writeMessageEnd oprot
                T.tFlush (T.getTransport oprot)))
            (\e  -> do
              let res = default_Phase_2b_result{phase_2b_result_invalid_Phase_1b = P.Just e}
              T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
              write_Phase_2b_result oprot res
              T.writeMessageEnd oprot
              T.tFlush (T.getTransport oprot)))
          (\e  -> do
            let res = default_Phase_2b_result{phase_2b_result_invalid_Phase_2a = P.Just e}
            T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
            write_Phase_2b_result oprot res
            T.writeMessageEnd oprot
            T.tFlush (T.getTransport oprot)))
        (\e  -> do
          let res = default_Phase_2b_result{phase_2b_result_invalid_Phase_2b = P.Just e}
          T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
          write_Phase_2b_result oprot res
          T.writeMessageEnd oprot
          T.tFlush (T.getTransport oprot)))
      (\e  -> do
        let res = default_Phase_2b_result{phase_2b_result_invalid_Proof_of_Consensus = P.Just e}
        T.writeMessageBegin oprot ("phase_2b", T.M_REPLY, seqid)
        write_Phase_2b_result oprot res
        T.writeMessageEnd oprot
        T.tFlush (T.getTransport oprot)))
    ((\_ -> do
      T.writeMessageBegin oprot ("phase_2b", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "ping" -> process_ping (seqid,iprot,oprot,handler)
  "phase_2b" -> process_phase_2b (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
